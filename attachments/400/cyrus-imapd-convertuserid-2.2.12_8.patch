diff -N -C 3 -r cyrus-imapd-2.2.12.old/config.h.in cyrus-imapd-2.2.12/config.h.in
*** cyrus-imapd-2.2.12.old/config.h.in	2005-02-14 20:59:41 +0300
--- cyrus-imapd-2.2.12/config.h.in	2005-11-22 18:57:51 +0300
***************
*** 64,69 ****
--- 64,72 ----
  /* Do we have a decent regex library? */
  #undef ENABLE_REGEX
  
+ /* Enable converting userids via LDAP support? */
+ #undef ENABLE_CONVERT_USERID
+ 
  /* Enable Netscape Menu Option Hack? */
  #undef ENABLE_X_NETSCAPE_HACK
  
diff -N -C 3 -r cyrus-imapd-2.2.12.old/configure cyrus-imapd-2.2.12/configure
*** cyrus-imapd-2.2.12.old/configure	2005-02-14 20:59:46 +0300
--- cyrus-imapd-2.2.12/configure	2005-11-22 18:57:52 +0300
***************
*** 852,857 ****
--- 852,858 ----
    --enable-cmulocal       enable CMU-specific local support
    --enable-oldsievename   enable the use of 'imap' as the sieve service name
    --enable-listext        enable IMAP List extensions
+   --enable-convertuserid  enable converting userids via LDAP support
    --enable-netscapehack   enable Netscape hack for the menu option
                            in Communicator to Administrate Mail
    --enable-gssapi=<DIR>   enable GSSAPI authentication yes
***************
*** 11180,11185 ****
--- 11181,11198 ----
  	fi
  fi;
  
+ # Check whether --enable-convertuserid or --disable-convertuserid was given.
+ if test "${enable_convertuserid+set}" = set; then
+   enableval="$enable_convertuserid"
+   if test "$enableval" = yes; then
+ 
+ cat >>confdefs.h <<\_ACEOF
+ #define ENABLE_CONVERT_USERID
+ _ACEOF
+ 	IMAP_PROGS="$IMAP_PROGS ldapd"
+ 	fi
+ fi;
+ 
  # Check whether --enable-netscapehack or --disable-netscapehack was given.
  if test "${enable_netscapehack+set}" = set; then
    enableval="$enable_netscapehack"
diff -N -C 3 -r cyrus-imapd-2.2.12.old/configure.in cyrus-imapd-2.2.12/configure.in
*** cyrus-imapd-2.2.12.old/configure.in	2005-01-19 02:46:00 +0300
--- cyrus-imapd-2.2.12/configure.in	2005-11-22 18:57:52 +0300
***************
*** 917,922 ****
--- 917,929 ----
  		AC_DEFINE(ENABLE_LISTEXT,[],[Enable the LISTEXT extension?])
  	fi)
  
+ AC_ARG_ENABLE(convertuserid,
+ 	[  --enable-convertuserid  enable converting userids via LDAP support],
+ 	if test "$enableval" = yes; then
+ 		AC_DEFINE(ENABLE_CONVERT_USERID,[],[Enable converting userids via LDAP support?])
+ 		IMAP_PROGS="$IMAP_PROGS ldapd"
+ 	fi)
+ 
  AC_ARG_ENABLE(netscapehack,
  	[  --enable-netscapehack   enable Netscape hack for the menu option
                            in Communicator to Administrate Mail],
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/charset_convert.c cyrus-imapd-2.2.12/imap/charset_convert.c
*** cyrus-imapd-2.2.12.old/imap/charset_convert.c	1970-01-01 03:00:00 +0300
--- cyrus-imapd-2.2.12/imap/charset_convert.c	2005-11-22 18:58:30 +0300
***************
*** 0 ****
--- 1,545 ----
+ /* This file was taken from PHP 5 and was modified by
+    Alexander Drozdov <dzal_mail@mtu-net.ru> */
+ #include <stdlib.h>
+ 
+ #include "charset_convert.h"
+ 
+ #define UCS4MAX 0x70000000U
+ 
+ #define UCS2MAX 0x00010000U
+ #define SUPMIN  0x00010000U
+ #define SUPMAX  0x00200000U
+ 
+ #define MASK    0xffffffU
+ #define THROUGH 0x78000000U              /* 000000h - FFFFFFh */
+ 
+ typedef unsigned int uint;
+ 
+ typedef struct _convert_state {
+     int cache;
+     int status;
+ } convert_state;
+ 
+ typedef int (*converted_out_cb_t)(uint c, void *);
+ typedef int (*convert_cb_t)(uint c, convert_state *, converted_out_cb_t, void *);
+ typedef int (*flush_cb_t)(convert_state *, converted_out_cb_t, void *);
+ 
+ #define CK(statement)	do { if ((statement)) return (-1); } while (0)
+ 
+ static int utf8_encode(uint c, convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+ {
+     /* skip wrong symbols */
+     if (c > UCS4MAX)
+ 	return 0;
+     
+     if (c < 0x80) {
+ 	CK(out_cb(c, out_cb_param));
+     } else if (c < 0x800) {
+ 	CK(out_cb(((c >> 6) & 0x1f) | 0xc0, out_cb_param));
+ 	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+     } else if (c < 0x10000) {
+ 	CK(out_cb(((c >> 12) & 0x0f) | 0xe0, out_cb_param));
+ 	CK(out_cb(((c >> 6) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+     } else if (c < 0x200000) {
+ 	CK(out_cb(((c >> 18) & 0x07) | 0xf0, out_cb_param));
+ 	CK(out_cb(((c >> 12) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb(((c >> 6) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+     } else if (c < 0x4000000) {
+ 	CK(out_cb(((c >> 24) & 0x03) | 0xf8, out_cb_param));
+ 	CK(out_cb(((c >> 18) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb(((c >> 12) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb(((c >> 6) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+     } else {
+ 	CK(out_cb(((c >> 30) & 0x01) | 0xfc, out_cb_param));
+ 	CK(out_cb(((c >> 24) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb(((c >> 18) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb(((c >> 12) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb(((c >> 6) & 0x3f) | 0x80, out_cb_param));
+ 	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+     }
+ 
+     return 0;
+ }
+ 
+ static int utf8_decode(uint c, convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+ {
+     if (c < 0x80) {
+ 	CK(out_cb(c, out_cb_param));
+ 	filter->status = 0;
+     } else if (c < 0xc0) {
+ 	uint s;
+ 
+ 	switch (filter->status & 0xff) {
+ 	case 0x10: /* 2byte code 2nd char */
+ 	case 0x21: /* 3byte code 3rd char */
+ 	case 0x32: /* 4byte code 4th char */
+ 	case 0x43: /* 5byte code 5th char */
+ 	case 0x54: /* 6byte code 6th char */
+ 	    filter->status = 0;
+ 	    s = filter->cache | (c & 0x3f);
+ 	    if (s >= 0x80)
+ 		CK(out_cb(s, out_cb_param));
+ 	    break;
+ 	case 0x20: /* 3byte code 2nd char */
+ 	case 0x31: /* 4byte code 3rd char */
+ 	case 0x42: /* 5byte code 4th char */
+ 	case 0x53: /* 6byte code 5th char */
+ 	    filter->cache |= ((c & 0x3f) << 6);
+ 	    filter->status++;
+ 	    break;
+ 	case 0x30: /* 4byte code 2nd char */
+ 	case 0x41: /* 5byte code 3rd char */
+ 	case 0x52: /* 6byte code 4th char */
+ 	    filter->cache |= ((c & 0x3f) << 12);
+ 	    filter->status++;
+ 	    break;
+ 	case 0x40: /* 5byte code 2nd char */
+ 	case 0x51: /* 6byte code 3rd char */
+ 	    filter->cache |= ((c & 0x3f) << 18);
+ 	    filter->status++;
+ 	    break;
+ 	case 0x50: /* 6byte code 2nd char */
+ 	    filter->cache |= ((c & 0x3f) << 24);
+ 	    filter->status++;
+ 	    break;
+ 	default:
+ 	    filter->status = 0;
+ 	    break;
+ 	}
+     } else if (c < 0xe0) { /* 2byte code first char */
+ 	filter->status = 0x10;
+ 	filter->cache = (c & 0x1f) << 6;
+     } else if (c < 0xf0) { /* 3byte code first char */
+ 	filter->status = 0x20;
+ 	filter->cache = (c & 0xf) << 12;
+     } else if (c < 0xf8) { /* 4byte code first char */
+ 	filter->status = 0x30;
+ 	filter->cache = (c & 0x7) << 18;
+     } else if (c < 0xfc) { /* 5byte code first char */
+ 	filter->status = 0x40;
+ 	filter->cache = (c & 0x3) << 24;
+     } else if (c < 0xfe)  { /* 6 byte code first char */
+ 	filter->status = 0x50;
+ 	filter->cache = (c & 0x1) << 30;
+     } else {
+ 	filter->status = 0;
+ 	filter->cache = 0;
+     }
+ 
+     return 0;
+ }
+ 
+ static const unsigned char utf7imap_base64_table[] =
+ {
+  /* 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', */
+    0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,
+  /* 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', */
+    0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,
+  /* 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', */
+    0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,
+  /* 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', */
+    0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+  /* '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', ',', '\0' */
+    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x2b,0x2c,0x00
+ };
+ 
+ static int mutf7_encode(uint c, convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+ {
+     int n, s;
+ 
+     n = 0;
+     if (c == 0x26) {
+ 	n = 1;
+     } else if ((c >= 0x20 && c <= 0x7e) || c == 0) {
+ 	n = 2;
+     } else if (c >= 0 && c < UCS2MAX) {
+ 	;
+     } else if (c >= SUPMIN && c < SUPMAX) {
+ 	s = ((c >> 10) - 0x40) | 0xd800;
+ 	CK(out_cb(s, out_cb_param));
+ 	s = (c & 0x3ff) | 0xdc00;
+ 	CK(out_cb(s, out_cb_param));
+ 	return 0;
+     } else {
+ 	return -1;
+     }
+ 
+     switch (filter->status) {
+     case 0:
+ 	if (n != 0) {	/* directly encode characters */
+ 	    CK(out_cb(c, out_cb_param));
+ 	    if (n == 1) {
+ 		CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	    }
+ 	} else {	/* Modified Base64 */
+ 	    CK(out_cb(0x26, out_cb_param));		/* '&' */
+ 	    filter->status = 1;
+ 	    filter->cache = c;
+ 	}
+ 	break;
+ 
+ 	/* encode Modified Base64 */
+     case 1:
+ 	s = filter->cache;
+ 	CK(out_cb(utf7imap_base64_table[(s >> 10) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(s >> 4) & 0x3f], out_cb_param));
+ 	if (n != 0) {
+ 	    CK(out_cb(utf7imap_base64_table[(s << 2) & 0x3c], out_cb_param));
+ 	    CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	    CK(out_cb(c, out_cb_param));
+ 	    if (n == 1) {
+ 		CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	    }
+ 	    filter->status = 0;
+ 	} else {
+ 	    filter->status = 2;
+ 	    filter->cache = ((s & 0xf) << 16) | c;
+ 	}
+ 	break;
+ 
+     case 2:
+ 	s = filter->cache;
+ 	CK(out_cb(utf7imap_base64_table[(s >> 14) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(s >> 8) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(s >> 2) & 0x3f], out_cb_param));
+ 	if (n != 0) {
+ 	    CK(out_cb(utf7imap_base64_table[(s << 4) & 0x30], out_cb_param));
+ 	    CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	    CK(out_cb(c, out_cb_param));
+ 	    if (n == 1) {
+ 		CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	    }
+ 	    filter->status = 0;
+ 	} else {
+ 	    filter->status = 3;
+ 	    filter->cache = ((s & 0x3) << 16) | c;
+ 	}
+ 	break;
+ 
+     case 3:
+ 	s = filter->cache;
+ 	CK(out_cb(utf7imap_base64_table[(s >> 12) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(s >> 6) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[s & 0x3f], out_cb_param));
+ 	if (n != 0) {
+ 	    CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	    CK(out_cb(c, out_cb_param));
+ 	    if (n == 1) {
+ 		CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	    }
+ 	    filter->status = 0;
+ 	} else {
+ 	    filter->status = 1;
+ 	    filter->cache = c;
+ 	}
+ 	break;
+ 
+     default:
+ 	filter->status = 0;
+ 	break;
+     }
+ 
+     return 0;
+ }
+ 
+ static int mutf7_decode(uint c, convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+ {
+     int s, n;
+ 
+     n = -1;
+     if (filter->status != 0) {		/* Modified Base64 */
+ 	if (c >= 0x41 && c <= 0x5a) {		/* A - Z */
+ 	    n = c - 65;
+ 	} else if (c >= 0x61 && c <= 0x7a) {	/* a - z */
+ 	    n = c - 71;
+ 	} else if (c >= 0x30 && c <= 0x39) {	/* 0 - 9 */
+ 	    n = c + 4;
+ 	} else if (c == 0x2b) {			/* '+' */
+ 	    n = 62;
+ 	} else if (c == 0x2c) {			/* ',' */
+ 	    n = 63;
+ 	}
+ 	if (n < 0 || n > 63) {
+ 	    if (c == 0x2d) {
+ 		if (filter->status == 1) {		/* "&-" -> "&" */
+ 		    CK(out_cb(0x26, out_cb_param));
+ 		}
+ 	    } else if (c >= 0 && c < 0x80) {	/* ASCII exclude '-' */
+ 		CK(out_cb(c, out_cb_param));
+ 	    } else {		/* illegal character */
+ 		s = c & MASK;
+ 		s |= THROUGH;
+ 		CK(out_cb(s, out_cb_param));
+ 	    }
+ 	    filter->cache = 0;
+ 	    filter->status = 0;
+ 	    return 0;
+ 	}
+     }
+ 
+     switch (filter->status) {
+ 	/* directly encoded characters */
+     case 0:
+ 	if (c == 0x26) {	/* '&'  shift character */
+ 	    filter->status++;
+ 	} else if (c >= 0 && c < 0x80) {	/* ASCII */
+ 	    CK(out_cb(c, out_cb_param));
+ 	} else {		/* illegal character */
+ 	    s = c & MASK;
+ 	    s |= THROUGH;
+ 	    CK(out_cb(s, out_cb_param));
+ 	}
+ 	break;
+ 
+ 	/* decode Modified Base64 */
+     case 1:
+     case 2:
+ 	filter->cache |= n << 10;
+ 	filter->status = 3;
+ 	break;
+     case 3:
+ 	filter->cache |= n << 4;
+ 	filter->status = 4;
+ 	break;
+     case 4:
+ 	s = ((n >> 2) & 0xf) | (filter->cache & 0xffff);
+ 	n = (n & 0x3) << 14;
+ 	filter->status = 5;
+ 	if (s >= 0xd800 && s < 0xdc00) {
+ 	    s = (((s & 0x3ff) << 16) + 0x400000) | n;
+ 	    filter->cache = s;
+ 	} else if (s >= 0xdc00 && s < 0xe000) {
+ 	    s &= 0x3ff;
+ 	    s |= (filter->cache & 0xfff0000) >> 6;
+ 	    filter->cache = n;
+ 	    if (s >= SUPMIN && s < SUPMAX) {
+ 		CK(out_cb(s, out_cb_param));
+ 	    } else {		/* illegal character */
+ 		s &= MASK;
+ 		s |= THROUGH;
+ 		CK(out_cb(s, out_cb_param));
+ 	    }
+ 	} else {
+ 	    filter->cache = n;
+ 	    CK(out_cb(s, out_cb_param));
+ 	}
+ 	break;
+ 
+     case 5:
+ 	filter->cache |= n << 8;
+ 	filter->status = 6;
+ 	break;
+     case 6:
+ 	filter->cache |= n << 2;
+ 	filter->status = 7;
+ 	break;
+     case 7:
+ 	s = ((n >> 4) & 0x3) | (filter->cache & 0xffff);
+ 	n = (n & 0xf) << 12;
+ 	filter->status = 8;
+ 	if (s >= 0xd800 && s < 0xdc00) {
+ 	    s = (((s & 0x3ff) << 16) + 0x400000) | n;
+ 	    filter->cache = s;
+ 	} else if (s >= 0xdc00 && s < 0xe000) {
+ 	    s &= 0x3ff;
+ 	    s |= (filter->cache & 0xfff0000) >> 6;
+ 	    filter->cache = n;
+ 	    if (s >= SUPMIN && s < SUPMAX) {
+ 		CK(out_cb(s, out_cb_param));
+ 	    } else {		/* illegal character */
+ 		s &= MASK;
+ 		s |= THROUGH;
+ 		CK(out_cb(s, out_cb_param));
+ 	    }
+ 	} else {
+ 	    filter->cache = n;
+ 	    CK(out_cb(s, out_cb_param));
+ 	}
+ 	break;
+ 
+     case 8:
+ 	filter->cache |= n << 6;
+ 	filter->status = 9;
+ 	break;
+     case 9:
+ 	s = n | (filter->cache & 0xffff);
+ 	filter->status = 2;
+ 	if (s >= 0xd800 && s < 0xdc00) {
+ 	    s = (((s & 0x3ff) << 16) + 0x400000);
+ 	    filter->cache = s;
+ 	} else if (s >= 0xdc00 && s < 0xe000) {
+ 	    s &= 0x3ff;
+ 	    s |= (filter->cache & 0xfff0000) >> 6;
+ 	    filter->cache = 0;
+ 	    if (s >= SUPMIN && s < SUPMAX) {
+ 		CK(out_cb(s, out_cb_param));
+ 	    } else {		/* illegal character */
+ 		s &= MASK;
+ 		s |= THROUGH;
+ 		CK(out_cb(s, out_cb_param));
+ 	    }
+ 	} else {
+ 	    filter->cache = 0;
+ 	    CK(out_cb(s, out_cb_param));
+ 	}
+ 	break;
+ 
+     default:
+ 	filter->status = 0;
+ 	break;
+     }
+ 
+     return 0;
+ }
+ static int mutf7_encode_flush(convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+ {
+     int status, cache;
+ 
+     status = filter->status;
+     cache = filter->cache;
+     filter->status = 0;
+     filter->cache = 0;
+     /* flush fragments */
+     switch (status) {
+     case 1:
+ 	CK(out_cb(utf7imap_base64_table[(cache >> 10) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(cache >> 4) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(cache << 2) & 0x3c], out_cb_param));
+ 	CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	break;
+ 
+     case 2:
+ 	CK(out_cb(utf7imap_base64_table[(cache >> 14) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(cache >> 8) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(cache >> 2) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(cache << 4) & 0x30], out_cb_param));
+ 	CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	break;
+ 
+     case 3:
+ 	CK(out_cb(utf7imap_base64_table[(cache >> 12) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[(cache >> 6) & 0x3f], out_cb_param));
+ 	CK(out_cb(utf7imap_base64_table[cache & 0x3f], out_cb_param));
+ 	CK(out_cb(0x2d, out_cb_param));		/* '-' */
+ 	break;
+     }
+     return 0;
+ }
+ 
+ typedef struct _convert_opts {
+     convert_cb_t encode_cb;
+     convert_cb_t decode_cb;
+     flush_cb_t flush_encode;
+     flush_cb_t flush_decode;
+ } convert_opts;
+ 
+ typedef struct _param_convert {
+     int len;
+     char *out;
+     convert_opts *opts;
+     convert_state filter;
+ } param_convert;
+ 
+ /* just a counter */
+ static int count_len_cb(uint c, void *param)
+ {
+     (*(int *)param)++;
+     return 0;
+ }
+ 
+ static int write_out_cb(uint c, void *param)
+ {
+     param_convert *r_param=(param_convert *)param;
+ 
+     r_param->out[r_param->len]=(char)c;
+     r_param->len++;
+     return 0;
+ }
+ 
+ /* 'c' is wchar. we need to call encode_cb function to calculate the
+    output buffer size */
+ static int get_len_cb(uint c, void *param)
+ {
+     return ((param_convert *)param)->opts->encode_cb(c, &((param_convert *)param)->filter, count_len_cb, (void *)&((param_convert *)param)->len);
+ }
+ 
+ static int real_out_cb(uint c, void *param)
+ {
+     return ((param_convert *)param)->opts->encode_cb(c, &((param_convert *)param)->filter, write_out_cb, param);
+ }
+ 
+ static char *do_conversion(convert_opts *opts, char *in, int inlen, int *outlen)
+ {
+     param_convert param;
+     convert_state filter;
+     int i;
+ 
+     param.len = 0;
+     param.opts = opts;
+     bzero(&param.filter, sizeof(param.filter));
+     bzero(&filter, sizeof(filter));
+ 
+     for(i=0; i<inlen; i++)
+ 	if(opts->decode_cb((uint)(unsigned char)in[i], &filter, get_len_cb, (void *)&param))
+ 	    return NULL;
+ 
+     if(opts->flush_decode)
+ 	if(opts->flush_decode(&filter, get_len_cb, (void *)&param))
+ 	    return NULL;
+     if(opts->flush_encode)
+ 	if(opts->flush_encode(&param.filter, count_len_cb, (void *)&param.len))
+ 	    return NULL;
+ 
+     if(!(param.out=(char *)malloc(param.len)))
+ 	return NULL;
+     param.len=0;
+     bzero(&param.filter, sizeof(param.filter));
+     bzero(&filter, sizeof(filter));
+     
+     for(i=0; i<inlen; i++)
+ 	if(opts->decode_cb((uint)(unsigned char)in[i], &filter, real_out_cb, (void *)&param)) {
+ 	    free(param.out);
+ 	    return NULL;
+ 	}
+ 
+     if(opts->flush_decode)
+ 	if(opts->flush_decode(&filter, real_out_cb, (void *)&param)) {
+ 	    free(param.out);
+ 	    return NULL;
+ 	}
+     if(opts->flush_encode)
+ 	if(opts->flush_encode(&param.filter, write_out_cb, (void *)&param.len)) {
+ 	    free(param.out);
+ 	    return NULL;
+ 	}
+ 
+     *outlen = param.len;
+     return param.out;
+ }
+ 
+ extern char *utf8_to_mutf7(char *in, int inlen, int *outlen)
+ {
+     convert_opts opts;
+ 
+     opts.encode_cb = mutf7_encode;
+     opts.decode_cb = utf8_decode;
+     opts.flush_encode = mutf7_encode_flush;
+     opts.flush_decode = NULL;
+ 
+     return do_conversion(&opts, in, inlen, outlen);
+ }
+ 
+ extern char *mutf7_to_utf8(char *in, int inlen, int *outlen)
+ {
+     convert_opts opts;
+ 
+     opts.encode_cb = utf8_encode;
+     opts.decode_cb = mutf7_decode;
+     opts.flush_encode = NULL;
+     opts.flush_decode = NULL;
+ 
+     return do_conversion(&opts, in, inlen, outlen);
+ }
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/charset_convert.h cyrus-imapd-2.2.12/imap/charset_convert.h
*** cyrus-imapd-2.2.12.old/imap/charset_convert.h	1970-01-01 03:00:00 +0300
--- cyrus-imapd-2.2.12/imap/charset_convert.h	2005-11-22 18:58:31 +0300
***************
*** 0 ****
--- 1,7 ----
+ #ifndef _CHARSET_CONVERT_H
+ #define _CHARSET_CONVERT_H
+ 
+ extern char *utf8_to_mutf7(char *in, int inlen, int *outlen);
+ extern char *mutf7_to_utf8(char *in, int inlen, int *outlen);
+ 
+ #endif /* _CHARSET_CONVERT_H */
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/idle_idled.c cyrus-imapd-2.2.12/imap/idle_idled.c
*** cyrus-imapd-2.2.12.old/imap/idle_idled.c	2003-10-23 00:05:11 +0400
--- cyrus-imapd-2.2.12/imap/idle_idled.c	2005-11-22 18:57:52 +0300
***************
*** 210,216 ****
      /* send */
      if (sendto(notify_sock, (void *) &idledata,
  	       IDLEDATA_BASE_SIZE+strlen(idledata.mboxname)+1, /* 1 for NULL */
! 	       0, (struct sockaddr *) &idle_remote, idle_remote_len) == -1) {
        syslog(LOG_ERR, "error sending to idled: %x", msg);
        return 0;
      }
--- 210,216 ----
      /* send */
      if (sendto(notify_sock, (void *) &idledata,
  	       IDLEDATA_BASE_SIZE+strlen(idledata.mboxname)+1, /* 1 for NULL */
! 	       0, (struct sockaddr *) &idle_remote, idle_remote_len) == (ssize_t)-1) {
        syslog(LOG_ERR, "error sending to idled: %x", msg);
        return 0;
      }
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/imapd.c cyrus-imapd-2.2.12/imap/imapd.c
*** cyrus-imapd-2.2.12.old/imap/imapd.c	2005-11-07 18:24:43 +0300
--- cyrus-imapd-2.2.12/imap/imapd.c	2005-11-22 18:57:53 +0300
***************
*** 80,85 ****
--- 80,88 ----
  #include "mailbox.h"
  #include "message.h"
  #include "mboxname.h"
+ #ifdef ENABLE_CONVERT_USERID
+ #include "ldapd.h"
+ #endif
  #include "mboxlist.h"
  #include "mbdump.h"
  #include "mkgmtime.h"
***************
*** 112,117 ****
--- 115,124 ----
  static char imapd_clienthost[NI_MAXHOST*2+1] = "[local]";
  static int imapd_logfd = -1;
  char *imapd_userid;
+ #ifdef ENABLE_CONVERT_USERID
+ int imapd_convertuserid=0;
+ int imapd_nonconverteduserid_allowed=0;
+ #endif
  static char *imapd_magicplus = NULL;
  struct auth_state *imapd_authstate = 0;
  static int imapd_userisadmin = 0;
***************
*** 476,481 ****
--- 483,493 ----
      }
  #endif
  
+ #ifdef ENABLE_CONVERT_USERID
+     if(imapd_convertuserid)
+ 	mboxname_cleanup();
+ #endif /* ENABLE_CONVERT_USERID */
+ 
      cyrus_reset_stdio(); 
  
      strcpy(imapd_clienthost, "[local]");
***************
*** 552,557 ****
--- 564,574 ----
  				   0, '.', 0))
  	fatal("cannot initialize the internal namespace", EC_TEMPFAIL);
  
+ #ifdef ENABLE_CONVERT_USERID
+     if(convertuserid_init())
+        fatal("convertuserid_init() failed", EC_CONFIG);
+ #endif /* ENABLE_CONVERT_USERID */
+ 
      /* open the mboxlist, we'll need it for real work */
      mboxlist_init(0);
      mboxlist_open(NULL);
***************
*** 593,598 ****
--- 610,630 ----
      return 0;
  }
  
+ static int imapd_config_reread()
+ {
+ #ifdef ENABLE_CONVERT_USERID
+     template_option opts[]={
+ 	{(void *)IMAPOPT_CONVERTUSERID, TEMPLATEOPT_TYPE_KNOWNOPT},
+ 	{(void *)IMAPOPT_CONVERTUSERID_EXEMPTS, TEMPLATEOPT_TYPE_KNOWNOPT},
+ 	{(void *)IMAPOPT_CONVERTUSERID_ALLOW_NONCONVERTED, TEMPLATEOPT_TYPE_KNOWNOPT},
+     };
+ 
+     return config_reread(opts, sizeof(opts)/sizeof(opts[0]));
+ #else
+     return 0;
+ #endif
+ }
+ 
  /*
   * run for each accepted connection
   */
***************
*** 623,628 ****
--- 655,663 ----
      imapd_in = prot_new(0, 0);
      imapd_out = prot_new(1, 1);
  
+     if(imapd_config_reread())
+ 	fatal("Can't reread configuration files", EC_CONFIG);
+ 
      /* Find out name of client host */
      salen = sizeof(imapd_remoteaddr);
      if (getpeername(0, (struct sockaddr *)&imapd_remoteaddr, &salen) == 0 &&
***************
*** 707,712 ****
--- 742,750 ----
  /* Called by service API to shut down the service */
  void service_abort(int error)
  {
+ #ifdef ENABLE_CONVERT_USERID
+     convertuserid_cleanup();
+ #endif /* ENABLE_CONVERT_USERID */
      shut_down(error);
  }
  
***************
*** 1698,1703 ****
--- 1736,1784 ----
      }
  }
  
+ static void imapd_loggeduser_init()
+ {
+ #ifdef ENABLE_CONVERT_USERID
+     char *exempts;
+ 
+     if(!imapd_namespace.isalt)
+ 	return;
+     
+     imapd_convertuserid = config_getswitch(IMAPOPT_CONVERTUSERID);
+     exempts = (char *)config_getstring(IMAPOPT_CONVERTUSERID_EXEMPTS);
+ 
+     if(exempts) {
+ 	/* look for userid inside 'exempts' string */
+ 	char *p=exempts;
+ 	char *n;
+ 	int userid_len=strlen(imapd_userid);
+ 
+ 	do {
+ 	    for(; *p==' '; p++);
+ 	    if(*p) {
+ 		int res;
+ 		int c_len;
+ 
+ 		n=strchr(p, ' ');
+ 		
+ 		c_len = n ? (n-p): strlen(p);
+ 
+ 		if(c_len==userid_len && !memcmp(imapd_userid, p, userid_len)) {
+ 		    /* userid has been found! switch convertuserid
+ 		       option */
+ 		    imapd_convertuserid = !imapd_convertuserid;
+ 		    break;
+ 		}
+ 
+ 		p=n;
+ 	    }
+ 	} while(p);
+     }
+     if(imapd_convertuserid)
+ 	imapd_nonconverteduserid_allowed = config_getswitch(IMAPOPT_CONVERTUSERID_ALLOW_NONCONVERTED);
+ #endif
+ }
+ 
  static void userid_tointernal(struct namespace *namespace, char *userid)
  {
      char hiersep_orig = namespace->hier_sep;
***************
*** 1897,1902 ****
--- 1978,1984 ----
  
      /* Translate any separators in userid */
      userid_tointernal(&imapd_namespace, imapd_userid);
+     imapd_loggeduser_init();
  
      freebuf(&passwdbuf);
  
***************
*** 2044,2049 ****
--- 2126,2132 ----
  
      /* Translate any separators in userid */
      userid_tointernal(&imapd_namespace, imapd_userid);
+     imapd_loggeduser_init();
  
      autocreate_inbox();
  
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/imapd.h cyrus-imapd-2.2.12/imap/imapd.h
*** cyrus-imapd-2.2.12.old/imap/imapd.h	2005-11-07 18:05:36 +0300
--- cyrus-imapd-2.2.12/imap/imapd.h	2005-11-22 18:57:53 +0300
***************
*** 51,56 ****
--- 51,61 ----
  
  /* Userid client has logged in as */
  extern char *imapd_userid;
+ #ifdef ENABLE_CONVERT_USERID
+ /* convert other users ids between namespaces (switch) */
+ int imapd_convertuserid;
+ int imapd_nonconverteduserid_allowed;
+ #endif /* ENABLE_CONVERT_USERID */
  
  /* Authorization state for logged in userid */
  extern struct auth_state *imapd_authstate;
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/ldapd.c cyrus-imapd-2.2.12/imap/ldapd.c
*** cyrus-imapd-2.2.12.old/imap/ldapd.c	1970-01-01 03:00:00 +0300
--- cyrus-imapd-2.2.12/imap/ldapd.c	2005-11-23 13:56:28 +0300
***************
*** 0 ****
--- 1,401 ----
+ #ifdef HAVE_CONFIG_H
+ #include <config.h>
+ #endif
+ 
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
+ #include <sys/un.h>
+ #include <syslog.h>
+ #include <sys/stat.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <errno.h>
+ #define _GNU_SOURCE
+ #include <getopt.h>
+ #include <assert.h>
+ #ifdef HAVE_UNISTD_H
+ #include <unistd.h>
+ #endif
+ #include <lber.h>
+ #include <ldap.h>
+ 
+ #include "ldapd.h"
+ #include "global.h"
+ #include "charset_convert.h"
+ #include "exitcodes.h"
+ 
+ /* global state */
+ const int config_need_data = 0;
+ 
+ static LDAP *ldap_session=NULL;
+ 
+ #define LDAP_FILTER_TEMPLATESIZE 7
+ 
+ /* options which was read from configuration files */
+ static const char *ldap_host;
+ static const char *ldapd_localhost;
+ static int ldap_port;
+ static const char *ldap_user;
+ static const char *ldap_password;
+ static const char *ldap_base;
+ static const char *ldap_attr_int;
+ static const char *ldap_attr_ext;
+ static char *ldap_filter_int;
+ static char *ldap_filter_ext;
+ static int ldap_filter_int_len;
+ static int ldap_filter_ext_len;
+ 
+ static int n_listeners=0;
+ 
+ void fatal(const char *msg, int err)
+ {
+     syslog(LOG_CRIT, "%s", msg);
+     syslog(LOG_NOTICE, "exiting");
+ 
+     cyrus_done();
+     
+     exit(err);
+ }
+ 
+ void ldap_cleanup()
+ {
+     if(ldap_session) {
+ 	ldap_unbind_s(ldap_session);
+ 	ldap_session=NULL;
+     }
+ }
+ 
+ /* 'domain' and 'domainlen' variables are ignored now */
+ static int get_id_from_ldap(const char *in, int in_len, const char *domain, int domainlen, char *out, int *out_len, int int2ext)
+ {
+     LDAPMessage *ldap_res;
+     char *in_ldap;
+     int in_ldap_len;
+     const char *ldap_filter_template;
+     int ldap_filter_template_len;
+     char *ldap_filter;
+     char *ldap_attrs[2];
+ 
+     /* Input buffer 'in' is MUTF-7 string in case if
+        external=>internal. We need to convert it to UTF-8 encoding
+        before querying to LDAP. */
+     if(!int2ext) {
+ 	char *in_test;
+ 	int in_test_len;
+ 
+ 	if(!(in_ldap = mutf7_to_utf8((char *)in, in_len, &in_ldap_len))) {
+ 	    syslog(LOG_DEBUG, "mutf7_to_utf8() failed.\n");
+ 	    return 1;
+ 	}
+ 
+ 	/* Check if 'in' is a valid imap-utf-7 string. Note that we
+ 	   also disallow here to have multiple mutf-7 representations
+ 	   of a Unicode string. */
+ 	if(!(in_test = utf8_to_mutf7(in_ldap, in_ldap_len, &in_test_len))) {
+ 	    syslog(LOG_DEBUG, "utf8_to_mutf7() failed while checking user unput.\n");
+ 	    free(in_ldap);
+ 	    return 1;
+ 	}
+ 
+ 	if(in_test_len!=in_len || memcmp(in, in_test, in_len)) {
+ 	    syslog(LOG_DEBUG, "Incorrect MUTF-7 string received.\n");
+ 	    free(in_ldap);
+ 	    free(in_test);
+ 	    return 1;
+ 	}
+ 	free(in_test);
+ 
+ 	ldap_filter_template = ldap_filter_ext;
+ 	ldap_filter_template_len = ldap_filter_ext_len;
+ 	ldap_attrs[0] = (char *)ldap_attr_int;
+     }
+     else {
+ 	in_ldap = (char *)in;
+ 	in_ldap_len = in_len;
+ 	ldap_filter_template = ldap_filter_int;
+ 	ldap_filter_template_len = ldap_filter_int_len;
+ 	ldap_attrs[0] = (char *)ldap_attr_ext;
+     }
+ 
+     /* if the connection to LDAP server is not established then try to
+        establish it */
+     if(!ldap_session) {
+ 	void *optval=LDAP_OPT_ON;
+ 
+ 	if(!(ldap_session = ldap_init(ldap_host, ldap_port)) ||
+ 	   ldap_set_option(ldap_session, LDAP_OPT_RESTART, optval)==-1 ||
+ 	   ldap_simple_bind_s(ldap_session, ldap_user, ldap_password)!=LDAP_SUCCESS) {
+ 	    syslog(LOG_DEBUG, "Cannot initialize LDAP client library!\n");
+ 	    ldap_cleanup();
+ 	    return 1;
+ 	}
+     }
+ 
+     /* the allocated buffer is bigger than needed: template have
+        "%.*s" string within it which is replaced to in_ldap string */
+     ldap_filter = (char *)malloc(ldap_filter_template_len+in_ldap_len);
+     if(!ldap_filter) {
+ 	if(in_ldap != in)
+ 	    free(in_ldap);
+ 	return 1;
+     }
+     sprintf(ldap_filter, ldap_filter_template, in_ldap_len, in_ldap);
+ 
+     ldap_attrs[1]=NULL;
+ 
+     if(ldap_search_s(ldap_session, ldap_base, LDAP_SCOPE_SUBTREE, ldap_filter, ldap_attrs, 0, &ldap_res)!=LDAP_SUCCESS) {
+ 	syslog(LOG_DEBUG, "ldap_search_s() failed!\n");
+ 	if(in_ldap != in)
+ 	    free(in_ldap);
+ 	free(ldap_filter);
+ 	/* disconnect from LDAP server (we will try to connect again
+ 	   later) */
+ 	ldap_cleanup();
+ 	return 1;
+     }
+     else {
+ 	char **vals=NULL;
+ 	char *nonencoded_out;
+ 	int nonencoded_len;
+ 	int count_entries;
+ 
+ 	if(in_ldap != in)
+ 	    free(in_ldap);
+ 	free(ldap_filter);
+ 
+ 	assert(ldap_res);
+ 	/* the external name hasn't been found or there are more than
+ 	   one result records */
+ 	if((count_entries=ldap_count_entries(ldap_session, ldap_res))!=1) {
+ 	    if(count_entries)
+ 		syslog(LOG_DEBUG, "ldap_count_entries() returned %i.\n", count_entries);
+ 	    ldap_msgfree(ldap_res);
+ 
+ 	    return 1;
+ 	}
+ 	else {
+ 	    LDAPMessage *entry;
+ 	    char *attr;
+ 
+ 	    entry = ldap_first_entry(ldap_session, ldap_res);
+ 	    assert(entry);
+ 
+ 	    vals = ldap_get_values(ldap_session, entry, ldap_attrs[0]);
+ 	    assert(vals && ldap_count_values(vals));
+ 
+ 	    /* save 'vals[0]' as an external name and 'in' as an internal
+ 	       one */
+ 	    nonencoded_out = vals[0];
+ 	    nonencoded_len = strlen(nonencoded_out);
+ 	}
+ 
+ 	/* 'nonencoded_out' buffer is an UTF-8 buffer. We need to
+ 	   convert it to MUTF-7 encoding in case if it is an external
+ 	   userid. */
+ 	if(int2ext) {
+ 	    char *temp_out = utf8_to_mutf7(nonencoded_out, nonencoded_len, out_len);
+ 	    if(!temp_out) {
+ 		syslog(LOG_DEBUG, "utf8_to_mutf7() failed.\n");
+ 		return 1;
+ 	    }
+ 	    if(*out_len > MAX_MAILBOX_NAME) {
+ 		*out_len = 0;
+ 		free(temp_out);
+ 		return 1;
+ 	    }
+ 	    memcpy(out, temp_out, *out_len);
+ 	    free(temp_out);
+ 	}
+ 	else {
+ 	    memcpy(out, nonencoded_out, nonencoded_len);
+ 	    *out_len = nonencoded_len;
+ 	}
+ 
+ 	if(vals)
+ 	    ldap_value_free(vals);
+ 	if(ldap_res)
+ 	    ldap_msgfree(ldap_res);
+     }
+ 
+     return 0;
+ }
+ 
+ /* read convertuserid LDAP configuration options from configuration
+    files */
+ static int read_ldap_options()
+ {
+     int ldap_attr_int_len;
+     int ldap_attr_ext_len;
+ 
+     ldap_host = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_HOST);
+     ldapd_localhost = config_getstring(IMAPOPT_CONVERTUSERID_LOCALHOST);
+ 
+     ldap_port = config_getint(IMAPOPT_CONVERTUSERID_LDAP_PORT);
+     if(!ldap_port)
+ 	ldap_port=LDAP_PORT;
+ 
+     ldap_user = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_USER);
+     ldap_password = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_PASSWORD);
+ 
+     ldap_base = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_BASE);
+ 
+     ldap_attr_int = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_ATTR_INT);
+     if(!ldap_attr_int) {
+ 	syslog(LOG_ERR, "convertuserid_ldap_attr_int option is not set\n");
+ 	return 1;
+     }
+     ldap_attr_ext = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_ATTR_EXT);
+     if(!ldap_attr_ext) {
+ 	syslog(LOG_ERR, "convertuserid_ldap_attr_ext option is not set\n");
+ 	return 1;
+     }
+     ldap_attr_int_len = strlen(ldap_attr_int);
+     ldap_filter_int_len = ldap_attr_int_len + LDAP_FILTER_TEMPLATESIZE;
+     ldap_filter_int = (char *)malloc(ldap_filter_int_len);
+     if(!ldap_filter_int) {
+ 	syslog(LOG_ERR, "memory allocation was failed\n");
+ 	return 1;
+     }
+     ldap_attr_ext_len = strlen(ldap_attr_ext);
+     ldap_filter_ext_len = ldap_attr_ext_len + LDAP_FILTER_TEMPLATESIZE;
+     ldap_filter_ext = (char *)malloc(ldap_filter_ext_len);
+     if(!ldap_filter_ext) {
+ 	syslog(LOG_ERR, "memory allocation was failed\n");
+ 	free(ldap_filter_int);
+ 	return 1;
+     }
+     sprintf(ldap_filter_int,"(%s=%%.*s)",ldap_attr_int);
+     sprintf(ldap_filter_ext,"(%s=%%.*s)",ldap_attr_ext);
+ 
+     return 0;
+ }
+ 
+ int main(int argc, char **argv)
+ {
+     int opt;
+     int s, len;
+     struct sockaddr_in local;
+     ldap_data_t ldapdata;
+     ldap_data_result_t ldapdata_result;
+     struct sockaddr_in from;
+     socklen_t fromlen;
+     pid_t pid;
+     int fd;
+     char *alt_config = NULL;
+     int curchild;
+     int port_num;
+     struct option longopts[]={
+ 	{"prefork", 1, NULL, 'n'},
+ 	{NULL, 0, NULL, 0},
+     };
+ 
+     while ((opt = getopt_long(argc, argv, "C:n:", longopts, NULL)) != EOF) {
+ 	switch (opt) {
+         case 'C': /* alt config file */
+             alt_config = optarg;
+             break;
+ 	case 'n':
+ 	    n_listeners = atoi(optarg);
+ 	    if(n_listeners<=0) {
+ 		fprintf(stderr, "invalid number of listener processes\n");
+ 		exit(EC_USAGE);
+ 	    }
+ 	    break;
+ 	default:
+ 	    fprintf(stderr, "invalid argument\n");
+ 	    exit(EC_USAGE);
+ 	    break;
+ 	}
+     }
+ 
+     /* set default number of listeners if needed */
+     if(!n_listeners)
+ 	n_listeners=1;
+ 
+     cyrus_init(alt_config, "ldapd", 0);
+ 
+     port_num = config_getint(IMAPOPT_CONVERTUSERID_UDPPORT);
+ 
+     if(read_ldap_options())
+ 	exit(1);
+ 
+     /* create socket we are going to use for listening */
+     if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
+ 	perror("socket");
+ 	cyrus_done();
+ 	exit(1);
+     }
+ 
+     local.sin_family = AF_INET;
+     inet_pton(AF_INET, ldapd_localhost, &local.sin_addr);
+     local.sin_port = htons(port_num);
+     len=sizeof(local);
+ 
+     if (bind(s, (struct sockaddr *)&local, len) == -1) {
+ 	perror("bind");
+ 	cyrus_done();
+ 	exit(1);
+     }
+ 
+     for(curchild=0; curchild<n_listeners; curchild++) {
+ 	pid = fork();
+ 	if (pid == -1) {
+ 	    perror("fork");
+ 	    cyrus_done();
+ 	    exit(1);
+ 	}
+ 	
+ 	if (pid != 0) { /* parent */
+ 	    continue;
+ 	}
+ 	/* child */
+ 	break;
+     }
+ 
+     if (pid != 0) { /* parent */
+ 	cyrus_done();
+ 	exit(0);
+     }
+ 	
+     /* child */
+ 
+     for (;;) {
+ 	int n;
+ 
+ 	fromlen = sizeof(from);
+ 	n = recvfrom(s, (void*) &ldapdata, sizeof(ldap_data_t), 0,
+ 		     (struct sockaddr *) &from, &fromlen);
+ 
+ 	if (n > 0) {
+ 	    if (n <= LDAPDATA_BASE_SIZE ||
+ 		ldapdata.userlen < n-LDAPDATA_BASE_SIZE)
+ 		syslog(LOG_ERR, "Invalid message received, size=%d\n", n);
+ 	    else {
+ 		int resultlen=0;
+ 
+ 		ldapdata_result.code=get_id_from_ldap(
+ 		    ldapdata.buf, ldapdata.userlen,
+ 		    ldapdata.buf+ldapdata.userlen, n-LDAPDATA_BASE_SIZE-ldapdata.userlen,
+ 		    ldapdata_result.buf, &resultlen,
+ 		    ldapdata.int2ext);
+ 		if(sendto(s, (void *)&ldapdata_result, resultlen+LDAPDATA_RESULT_BASE_SIZE,0,(struct sockaddr *)&from,fromlen)==-1)
+ 		    syslog(LOG_ERR, "Cannot send an answer: %s\n", strerror(errno));
+ 	    }
+ 	}
+     }
+ 
+     cyrus_done();
+ 
+     /* never gets here */      
+     exit(1);
+ }
+ 
+ void printstring(const char *s __attribute__((unused)))
+ { 
+     /* needed to link against annotate.o */
+     fatal("printstring() executed!!!",
+           EC_SOFTWARE);
+ }
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/ldapd.h cyrus-imapd-2.2.12/imap/ldapd.h
*** cyrus-imapd-2.2.12.old/imap/ldapd.h	1970-01-01 03:00:00 +0300
--- cyrus-imapd-2.2.12/imap/ldapd.h	2005-11-22 18:58:30 +0300
***************
*** 0 ****
--- 1,27 ----
+ #ifndef _LDAPD_H
+ #define _LDAPD_H
+ 
+ #include "mailbox.h"
+ 
+ /* socket to communicate with the ldapd */
+ #define FNAME_CONVERTUSERID_SOCK "/socket/ldap"
+ 
+ typedef struct ldap_data_s {
+     unsigned long int2ext;
+     unsigned long userlen; /* length of the username buffer */
+ 
+     /* non-null-terminated buffer for username and domain */
+     char buf[MAX_MAILBOX_NAME*2];
+ } ldap_data_t;
+ 
+ typedef struct ldap_data_result_s {
+     unsigned long code;
+ 
+     /* non-null-terminated buffer for converted username */
+     char buf[MAX_MAILBOX_NAME];
+ } ldap_data_result_t;
+ 
+ #define LDAPDATA_BASE_SIZE	(2 * sizeof(unsigned long))
+ #define LDAPDATA_RESULT_BASE_SIZE	(sizeof(unsigned long))
+ 
+ #endif /* _LDAPD_H */
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/Makefile.in cyrus-imapd-2.2.12/imap/Makefile.in
*** cyrus-imapd-2.2.12.old/imap/Makefile.in	2005-11-07 18:05:24 +0300
--- cyrus-imapd-2.2.12/imap/Makefile.in	2005-11-22 18:57:53 +0300
***************
*** 69,75 ****
  SIEVE_LIBS = @SIEVE_LIBS@
  IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
  LIB_WRAP = @LIB_WRAP@
! LIBS = $(IMAP_LIBS) $(IMAP_COM_ERR_LIBS)
  DEPLIBS = ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
  
  CFLAGS = @CFLAGS@
--- 69,75 ----
  SIEVE_LIBS = @SIEVE_LIBS@
  IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
  LIB_WRAP = @LIB_WRAP@
! LIBS = $(IMAP_LIBS) $(IMAP_COM_ERR_LIBS) -lredblack -lldap
  DEPLIBS = ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
  
  CFLAGS = @CFLAGS@
***************
*** 104,110 ****
  	convert_code.o duplicate.o saslclient.o saslserver.o signals.o \
  	annotate.o search_engines.o squat.o squat_internal.o mbdump.o \
  	imapparse.o telemetry.o user.o notify.o protocol.o quota_db.o \
! 	autosieve.o $(SEEN) $(IDLE)
  
  IMAPDOBJS=pushstats.o backend.o imapd.o index.o tls.o version.o
  
--- 104,110 ----
  	convert_code.o duplicate.o saslclient.o saslserver.o signals.o \
  	annotate.o search_engines.o squat.o squat_internal.o mbdump.o \
  	imapparse.o telemetry.o user.o notify.o protocol.o quota_db.o \
! 	autosieve.o charset_convert.o $(SEEN) $(IDLE)
  
  IMAPDOBJS=pushstats.o backend.o imapd.o index.o tls.o version.o
  
***************
*** 190,195 ****
--- 190,199 ----
  	$(CC) $(LDFLAGS) -o idled \
  	 idled.o mutex_fake.o libimap.a $(SIEVE_LIBS) $(DEPLIBS) $(LIBS)
  
+ ldapd: ldapd.o mutex_fake.o libimap.a $(DEPLIBS)
+ 	$(CC) $(LDFLAGS) -o ldapd \
+ 	 ldapd.o mutex_fake.o libimap.a $(SIEVE_LIBS) $(DEPLIBS) $(LIBS)
+ 
  lmtpd: lmtpd.o $(LMTPOBJS) $(SIEVE_OBJS) mutex_fake.o libimap.a $(SIEVE_LIBS) \
  	$(DEPLIBS) $(SERVICE)
  	$(CC) $(LDFLAGS) -o lmtpd \
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/mboxlist.c cyrus-imapd-2.2.12/imap/mboxlist.c
*** cyrus-imapd-2.2.12.old/imap/mboxlist.c	2005-11-07 18:24:43 +0300
--- cyrus-imapd-2.2.12/imap/mboxlist.c	2005-11-22 18:57:53 +0300
***************
*** 1759,1794 ****
      /* don't list mailboxes outside of the default domain */
      if (!rock->domainlen && !rock->isadmin && strchr(key, '!')) return 0; 
  
-     minmatch = 0;
- 
-     memcpy(namebuf, key, keylen);
-     namebuf[keylen] = '\0';
- 
-     /* right work with an alternate (not the build-in)
-        namespace -- sorcerer */
-     if(keylen >= sizeof(namebuf)) {
- 	syslog(LOG_ERR, "oversize keylen in mboxlist.c:find_p()");
- 	return 0;
-     }
-     if(rock->inboxoffset) {
- 	namebuf[rock->inboxoffset] = rock->inboxcase[0];
- 	namebuf[rock->inboxoffset+1] = rock->inboxcase[1];
- 	namebuf[rock->inboxoffset+2] = rock->inboxcase[2];
- 	namebuf[rock->inboxoffset+3] = rock->inboxcase[3];
- 	namebuf[rock->inboxoffset+4] = rock->inboxcase[4];
-     }
- 
-     /* if cant get the external name then skip the current
-        key -- sorcerer */
-     if((rock->namespace->mboxname_toexternal)(rock->namespace, namebuf+rock->inboxoffset, auth_canonuser(rock->auth_state), namebuf_out))
- 	return 0;
- 
-     matchlen = glob_test(g, namebuf_out,
- 			 strlen(namebuf_out), &minmatch);
- 
-     /* If its not a match, skip it -- partial matches are ok. */
-     if(matchlen == -1) return 0;
- 
      if (rock->find_namespace != NAMESPACE_INBOX &&
  	rock->usermboxname &&
  	keylen >= rock->usermboxnamelen &&
--- 1759,1764 ----
***************
*** 1842,1847 ****
--- 1812,1846 ----
  	}
      }
      
+     minmatch = 0;
+ 
+     memcpy(namebuf, key, keylen);
+     namebuf[keylen] = '\0';
+ 
+     /* right work with an alternate namespace -- sorcerer */
+     if(keylen >= sizeof(namebuf)) {
+ 	syslog(LOG_ERR, "oversize keylen in mboxlist.c:find_p()");
+ 	return 0;
+     }
+     if(rock->inboxoffset) {
+ 	namebuf[rock->inboxoffset] = rock->inboxcase[0];
+ 	namebuf[rock->inboxoffset+1] = rock->inboxcase[1];
+ 	namebuf[rock->inboxoffset+2] = rock->inboxcase[2];
+ 	namebuf[rock->inboxoffset+3] = rock->inboxcase[3];
+ 	namebuf[rock->inboxoffset+4] = rock->inboxcase[4];
+     }
+ 
+     /* if cant get the external name then skip the current
+        key -- sorcerer */
+     if((rock->namespace->mboxname_toexternal)(rock->namespace, namebuf+rock->inboxoffset, auth_canonuser(rock->auth_state), namebuf_out))
+ 	return 0;
+ 
+     matchlen = glob_test(g, namebuf_out,
+ 			 strlen(namebuf_out), &minmatch);
+ 
+     /* If its not a match, skip it -- partial matches are ok. */
+     if(matchlen == -1) return 0;
+ 
      /* if we get here, close enough for us to spend the time
         acting interested */
      return 1;
***************
*** 1880,1890 ****
  	}
  
        	/* make sure it's in the mailboxes db */
! 	if (rock->checkmboxlist) {
! 	    r = mboxlist_lookup(namebuf, NULL, NULL, NULL);
! 	} else {
! 	    r = 0;		/* don't bother checking */
! 	}
  
  	/* right work with an alternate (not the build-in)
  	   namespace // sorcerer */
--- 1879,1889 ----
  	}
  
        	/* make sure it's in the mailboxes db */
!  	if (rock->checkmboxlist) {
!  	    r = mboxlist_lookup(namebuf, NULL, NULL, NULL);
!  	} else {
! 	    r = 0;
!  	}
  
  	/* right work with an alternate (not the build-in)
  	   namespace // sorcerer */
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/mboxname.c cyrus-imapd-2.2.12/imap/mboxname.c
*** cyrus-imapd-2.2.12.old/imap/mboxname.c	2005-11-07 18:24:44 +0300
--- cyrus-imapd-2.2.12/imap/mboxname.c	2005-11-22 18:57:53 +0300
***************
*** 57,62 ****
--- 57,72 ----
  
  #include "mboxname.h"
  #include "mboxlist.h"
+ #include "imapd.h"
+ 
+ #ifdef ENABLE_CONVERT_USERID
+ #include <sys/socket.h>
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
+ #include <redblack.h>
+ #include <syslog.h>
+ #include "ldapd.h"
+ #endif /* ENABLE_CONVERT_USERID */
  
  /* Mailbox patterns which the design of the server prohibits */
  static char *badmboxpatterns[] = {
***************
*** 95,100 ****
--- 105,444 ----
  };
  #define CHARMOD64(c)  (index_mod64[(unsigned char)(c)])
  
+ #ifdef ENABLE_CONVERT_USERID
+ typedef struct _rbt_data_t {
+     char *domain;
+     char *id_in;
+     int id_in_len;
+     char *id_out;
+     int id_out_len;
+ } rbt_data_t;
+ 
+ static struct rbtree *rbt_int_to_ext=NULL;
+ static struct rbtree *rbt_ext_to_int=NULL;
+ 
+ static int convertuserid_socket=-1;
+ 
+ int rbt_data_compare(const void *p1, const void *p2, const void *config)
+ {
+     rbt_data_t *d1=(rbt_data_t *)p1;
+     rbt_data_t *d2=(rbt_data_t *)p2;
+     int res;
+ 
+     if(!(res=strcmp(d1->domain, d2->domain))) {
+ 	char *str1, *str2;
+ 	int str1_len, str2_len;
+ 	int min_len;
+ 
+ 	if(config) {
+ 	    str1=d1->id_in;
+ 	    str1_len=d1->id_in_len;
+ 	    str2=d2->id_in;
+ 	    str2_len=d2->id_in_len;
+ 	}
+ 	else {
+ 	    str1=d1->id_out;
+ 	    str1_len=d1->id_out_len;
+ 	    str2=d2->id_out;
+ 	    str2_len=d2->id_out_len;
+ 	}
+ 	min_len = (str1_len < str2_len)? str1_len : str2_len;
+ 	if(!(res=memcmp(str1, str2, min_len))) {
+ 	    if(min_len==str1_len)
+ 		res = (min_len==str2_len)?0:-1;
+ 	    else
+ 		res = -1;
+ 	}
+     }
+     return res;
+ }
+ 
+ #define DONT_ALLOCATE_IN  0x1
+ #define DONT_ALLOCATE_OUT 0x2
+ 
+ rbt_data_t *rbt_init_userid_data(const char *domain, const char *in, int in_len, const char *out, int out_len, int flags)
+ {
+     rbt_data_t *res=(rbt_data_t *)malloc(sizeof(rbt_data_t));
+ 
+     if(!res)
+ 	return NULL;
+ 
+     res->domain = strdup(domain);
+     if(!res->domain) {
+ 	free(res);
+ 	return NULL;
+     }
+ 
+     if(in == out && (flags & (DONT_ALLOCATE_IN|DONT_ALLOCATE_OUT)))
+ 	flags |= (DONT_ALLOCATE_IN|DONT_ALLOCATE_OUT);
+ 
+     if(flags & DONT_ALLOCATE_IN)
+ 	res->id_in = (char *)in;
+     else if(!(res->id_in = (char *)malloc(in_len))) {
+ 	free(res->domain);
+ 	free(res);
+ 	return NULL;
+     }
+     else
+ 	memcpy(res->id_in, in, in_len);
+ 
+     if(in == out && !flags) {
+ 	out = res->id_in;
+ 	flags |= DONT_ALLOCATE_OUT;
+     }
+ 
+     if(flags & DONT_ALLOCATE_OUT)
+ 	res->id_out = (char *)out;
+     else if(!(res->id_out = (char *)malloc(out_len))) {
+ 	free(res->domain);
+ 	if(!(flags & DONT_ALLOCATE_IN))
+ 	    free(res->id_in);
+ 	free(res);
+ 	return NULL;
+     }
+     else
+ 	memcpy(res->id_out, out, out_len);
+ 
+     res->id_in_len = in_len;
+     res->id_out_len = out_len;
+ 
+     return res;
+ }
+ 
+ void rbt_free_userid_data(rbt_data_t *data)
+ {
+     free(data->domain);
+     free(data->id_in);
+     if(data->id_in!=data->id_out)
+ 	free(data->id_out);
+     free(data);
+ }
+ 
+ #define INTERNAL              0x1
+ #define LDAP_NAME_MUST_EXISTS 0x2
+ #define DONT_RETURN_EXISTENT  0x4
+ 
+ extern int convertuserid_init()
+ {
+     const char *convertuserid_sock;
+     int locallen;
+     int pathlen;
+     mode_t oldumask;
+     int port_num;
+     struct sockaddr_in convertuserid_remote;
+     int convertuserid_remote_len;
+ 
+     /* if the socket is already open, return */
+     if (convertuserid_socket != -1) {
+ 	syslog(LOG_ERR, "convertuserid_init: must not be called twice");
+ 	return -1;
+     }
+ 
+     port_num = config_getint(IMAPOPT_CONVERTUSERID_UDPPORT);
+     if(!port_num) {
+ 	syslog(LOG_ERR, "Invalid value of convertuserid_udpport config option\n");
+ 	return -1;
+     }
+ 
+     if ((convertuserid_socket = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
+ 	syslog(LOG_ERR, "convertuserid_init: can't create a socket");
+ 	return -1;
+     }
+ 
+     convertuserid_remote.sin_family = AF_INET;
+     convertuserid_remote.sin_port = htons(port_num);
+     inet_pton(AF_INET, config_getstring(IMAPOPT_CONVERTUSERID_LOCALHOST), &convertuserid_remote.sin_addr);
+     convertuserid_remote_len = sizeof(convertuserid_remote);
+ 
+     if(connect(convertuserid_socket, (struct sockaddr *)&convertuserid_remote, convertuserid_remote_len)==-1) {
+ 	syslog(LOG_ERR, "convertuserid_init: can't connect (datagram)");
+ 	return -1;
+     }
+ 
+     return 0;
+ }
+ 
+ static char *mboxname_get_id_from_ldap(const char *in, int in_len, const char *domain, int *out_len, int flags)
+ {
+     ldap_data_t senddata;
+     int domainlen=strlen(domain);
+     ssize_t size;
+ 
+     senddata.int2ext = flags&INTERNAL;
+     senddata.userlen = in_len;
+     memcpy(senddata.buf, in, in_len);
+     memcpy(senddata.buf+in_len, domain, domainlen);
+ 
+     size=send(convertuserid_socket, (void *)&senddata, LDAPDATA_BASE_SIZE+in_len+domainlen, 0);
+     if(size == (ssize_t)-1) {
+ 	syslog(LOG_ERR, "Cannot send convertuserid query: %s.\n", strerror(errno));
+ 	return NULL;
+     }
+     if(size != LDAPDATA_BASE_SIZE+in_len+domainlen)
+ 	syslog(LOG_ERR, "Cannot send full convertuserid query.\n");
+ 
+     if(size) {
+ 	ldap_data_result_t recvdata;
+ 	char *out;
+ 
+ 	size = recv(convertuserid_socket, (void *)&recvdata, sizeof(recvdata), 0);
+ 	if(size==(ssize_t)-1) {
+ 	    syslog(LOG_ERR, "Cannot receive convertuserid answer: %s.\n", strerror(errno));
+ 	    return NULL;
+ 	}
+ 	if(size<LDAPDATA_RESULT_BASE_SIZE) {
+ 	    syslog(LOG_ERR, "Wrong size of convertuserid answer.\n");
+ 	    return NULL;
+ 	}
+ 	/* answer is "can't convert userid" or result string is
+ 	   empty */
+ 	if(recvdata.code || size==LDAPDATA_RESULT_BASE_SIZE)
+ 	    return NULL;
+ 	size-=LDAPDATA_RESULT_BASE_SIZE;
+ 	out=(char *)malloc(size);
+ 	if(!out)
+ 	    return NULL;
+ 	memcpy(out, recvdata.buf, size);
+ 	*out_len = size;
+ 	return out;
+     }
+ 
+     return NULL;
+ }
+ 
+ static char *mboxname_get_id(const char *in, int in_len, const char *domain, int *out_len, struct rbtree **c_int, struct rbtree **c_ext, int flags)
+ {
+     rbt_data_t data;
+     rbt_data_t *saved_data;
+     char *out;
+     int need_alloc=0;
+     int nonexistent=0;
+ 
+     if(!*c_int)
+ 	if(!(*c_int = rbinit(rbt_data_compare, (void *)((flags&INTERNAL)>0))))
+ 	    return NULL;
+     if(!*c_ext)
+ 	if(!(*c_ext = rbinit(rbt_data_compare, (void *)(!(flags&INTERNAL)))))
+ 	    return NULL;
+     data.domain = (char *)domain;
+ 	   
+     if(flags&INTERNAL) {
+ 	data.id_in = (char *)in;
+ 	data.id_in_len = in_len;
+ 	data.id_out = NULL;
+ 	data.id_out_len = 0;
+     }
+     else {
+ 	data.id_out = (char *)in;
+ 	data.id_out_len = in_len;
+ 	data.id_in = NULL;
+ 	data.id_in_len = 0;
+     }
+ 
+     /* firstly look for the name in the local (in-memory) storage */
+     if((saved_data=(rbt_data_t *)rbfind((void *)&data, *c_int))) {
+ 	if(flags&INTERNAL) {
+ 	    *out_len = saved_data->id_out_len;
+ 	    return saved_data->id_out;
+ 	}
+ 	else {
+ 	    *out_len = saved_data->id_in_len;
+ 	    return saved_data->id_in;
+ 	} 
+     }
+ 
+     out = mboxname_get_id_from_ldap(in, in_len, domain, out_len, flags);
+ 
+     if(!out) {
+ 	if(flags & LDAP_NAME_MUST_EXISTS)
+ 	    return NULL;
+ 	/* save the internal name as external if LDAP fetching fails */
+ 	else {
+ 	    out=(char *)in;
+ 	    *out_len=in_len;
+ 	    need_alloc=1;
+ 	    nonexistent=1;
+ 	}
+     }
+     
+     /* Now we have 'out' and '*out_len' variables. Save 'in' and
+        'out' in our memory databases */
+     if(flags&INTERNAL)
+ 	saved_data=rbt_init_userid_data(domain, in, in_len, out, *out_len, need_alloc?0:DONT_ALLOCATE_OUT);
+     else
+ 	saved_data=rbt_init_userid_data(domain, out, *out_len, in, in_len, need_alloc?0:DONT_ALLOCATE_IN);
+     
+     if(!rbsearch(saved_data,*c_int)) {
+ 	rbt_free_userid_data(saved_data);
+ 	saved_data=NULL;
+     }
+     else if(!rbsearch(saved_data,*c_ext)) {
+ 	rbdelete(saved_data, *c_int);
+ 	rbt_free_userid_data(saved_data);
+ 	saved_data=NULL;
+     }
+ 
+     /* If we can't save data in the memory storage then return NULL
+        because we are not sure if data in ldap storage will not be
+        changed when this function is called next time. */
+     if(!saved_data)
+ 	return NULL;
+ 
+     if(!nonexistent && (flags & DONT_RETURN_EXISTENT))
+ 	return NULL;
+ 	    
+     return out;
+ }
+ 
+ static void rbt_walk_cb(const void *nodep, const VISIT which, const int depth, void *arg)
+ {
+     if(which == endorder || which == leaf)
+ 	rbt_free_userid_data((rbt_data_t *)nodep);
+ }
+ 
+ /* destroying all the data needed for names transformation (this
+    function is called when client terminates his connection) */
+ extern void mboxname_cleanup()
+ {
+     rbt_data_t *data;
+ 
+     if(rbt_int_to_ext) {
+ 	rbwalk(rbt_int_to_ext, rbt_walk_cb, NULL);
+ 	    
+ 	rbdestroy(rbt_int_to_ext);
+ 	rbt_int_to_ext=NULL;
+     }
+     if(rbt_ext_to_int) {
+ 	rbdestroy(rbt_ext_to_int);
+ 	rbt_ext_to_int=NULL;
+     }
+ }
+ extern int convertuserid_cleanup()
+ {
+     close(convertuserid_socket);
+ }
+ 
+ #endif /* ENABLE_CONVERT_USERID */
+ 
+ static char *mboxname_get_external_id(const char *in, int in_len, const char *domain, int *out_len, int flags)
+ {
+ #ifndef ENABLE_CONVERT_USERID
+     *out_len = in_len;
+     return (char *)in;
+ #else
+     return mboxname_get_id(in, in_len, domain, out_len, &rbt_int_to_ext, &rbt_ext_to_int, INTERNAL|(flags&(LDAP_NAME_MUST_EXISTS|DONT_RETURN_EXISTENT)));
+ #endif
+ }
+ 
+ static char *mboxname_get_internal_id(const char *in, int in_len, const char *domain, int *out_len)
+ {
+ #ifndef ENABLE_CONVERT_USERID
+     *out_len = in_len;
+     return (char *)in;
+ #else
+     return mboxname_get_id(in, in_len, domain, out_len, &rbt_ext_to_int, &rbt_int_to_ext, LDAP_NAME_MUST_EXISTS);
+ #endif
+ }
  
  static int mboxname_check_hierseps(struct namespace *namespace, const char *name, int namelen)
  {
***************
*** 205,211 ****
  				   const char *name,
  				   const char *userid, char *result)
  {
!     char *cp;
      int userlen, domainlen = 0, namelen;
      int prefixlen;
      size_t resultlen;
--- 549,555 ----
  				   const char *name,
  				   const char *userid, char *result)
  {
!     char *cp, *domain="";
      int userlen, domainlen = 0, namelen;
      int prefixlen;
      size_t resultlen;
***************
*** 222,228 ****
      if (config_virtdomains) {
  	if (userid && (cp = strchr(userid, '@'))) {
  	    /* user logged in as user@domain */
! 	    userlen = cp++ - userid;
  	    if (!(config_defdomain && !strcasecmp(config_defdomain, cp))) {
  		/* don't prepend default domain */
  		domainlen = strlen(cp)+1;
--- 566,573 ----
      if (config_virtdomains) {
  	if (userid && (cp = strchr(userid, '@'))) {
  	    /* user logged in as user@domain */
! 	    userlen = cp - userid;
! 	    domain = ++cp;
  	    if (!(config_defdomain && !strcasecmp(config_defdomain, cp))) {
  		/* don't prepend default domain */
  		domainlen = strlen(cp)+1;
***************
*** 233,238 ****
--- 578,584 ----
  	}
  	if ((cp = strrchr(name, '@'))) {
  	    /* mailbox specified as mbox@domain */
+ 	    domain = cp+1;
  	    namelen = cp - name;
  
  	    if (config_defdomain && !strcasecmp(config_defdomain, cp+1)) {
***************
*** 290,307 ****
  
      if (!strncmp(name, namespace->prefix[NAMESPACE_USER], prefixlen-1) &&
  	(namelen == prefixlen-1 || name[prefixlen-1] == namespace->hier_sep)) {
  
  	if (namelen == prefixlen-1) {
  	    /* can't create folders using undelimited prefix */
  	    return IMAP_MAILBOX_BADNAME;
  	}
  
! 	if (domainlen+namelen-prefixlen+5 > MAX_MAILBOX_NAME) {
! 	    return IMAP_MAILBOX_BADNAME;
  	}
  
! 	sprintf(result, "user.%.*s", namelen-prefixlen, name+prefixlen);
  
  	/* Translate any separators in userid+mailbox */
  	mboxname_hiersep_tointernal(namespace, result+5, 0);
  	return 0;
--- 636,714 ----
  
      if (!strncmp(name, namespace->prefix[NAMESPACE_USER], prefixlen-1) &&
  	(namelen == prefixlen-1 || name[prefixlen-1] == namespace->hier_sep)) {
+ 	char modified_username[MAX_MAILBOX_NAME+1];
+ 	char *int_id="";
+ 	size_t int_id_len=0;
+ 	size_t ext_id_len=0;
  
  	if (namelen == prefixlen-1) {
  	    /* can't create folders using undelimited prefix */
  	    return IMAP_MAILBOX_BADNAME;
  	}
  
! 	if(!imapd_convertuserid) {
! 	    if (domainlen+namelen-prefixlen+5 > MAX_MAILBOX_NAME)
! 		return IMAP_MAILBOX_BADNAME;
! 	    name+=prefixlen;
  	}
+ 	else {
+ 	    char *sep;
  
! 	    name+=prefixlen;
! 	    sep=strchr(name,namespace->hier_sep);
! 	    if(!sep || sep-name >= namelen-prefixlen)
! 		ext_id_len = namelen-prefixlen;
! 	    else
! 		ext_id_len = sep-name;
! 
! 	    if(!ext_id_len)
! 		return IMAP_MAILBOX_BADNAME;
! 	    
! 	    /* we must transform hierarchy separators in the _user_id_
! 	       into internal representations before querying the
! 	       internal user id because the revert transformation
! 	       works with usernames only and knows nothing about
! 	       separators -- sorcerer */
! 	    memcpy(modified_username, name, ext_id_len);
! 	    mboxname_hiersep_tointernal(namespace, modified_username,ext_id_len);
! 
! 	    int_id = mboxname_get_internal_id(modified_username, ext_id_len, domain, &int_id_len);
! 	    if(!int_id) {
! 		char temp_mbname[MAX_MAILBOX_NAME+1];
! 
! 		if(!imapd_nonconverteduserid_allowed)
! 		    return IMAP_MAILBOX_NONEXISTENT;
! 
! 		/* build internal mailbox name with given userid to
! 		   check if this mailbox exists */
! 		if(domainlen+namelen-prefixlen+5 > MAX_MAILBOX_NAME)
! 		    return IMAP_MAILBOX_BADNAME;
  
+ 		memcpy(temp_mbname, "user.", 5);
+ 		memcpy(temp_mbname+5, modified_username, ext_id_len);
+ 		memcpy(temp_mbname+5+ext_id_len, name+ext_id_len, namelen-prefixlen-ext_id_len);
+ 		temp_mbname[5+namelen-prefixlen]=0;
+ 
+ 		mboxname_hiersep_tointernal(namespace, temp_mbname+5, 0);
+ 		if(mboxlist_lookup(temp_mbname, NULL, NULL, NULL))
+ 		    return IMAP_MAILBOX_NONEXISTENT;
+ 		    
+ 		/* look for internal id with the value of given
+ 		   external id */
+ 		int_id = mboxname_get_external_id(modified_username, ext_id_len, domain, &int_id_len, DONT_RETURN_EXISTENT);
+ 		/* convert error or the internal id exists in LDAP as
+ 		   external */
+ 		if(!int_id)
+ 		    return IMAP_MAILBOX_NONEXISTENT;
+ 		/* otherwise use internal id */
+ 	    }
+ 	    if(domainlen+namelen-prefixlen+5-ext_id_len+int_id_len > MAX_MAILBOX_NAME)
+ 		return IMAP_MAILBOX_BADNAME;
+ 	    name+=ext_id_len;
+ 	}
+ 
+ 	sprintf(result, "user.%.*s%.*s", int_id_len, int_id, namelen-prefixlen-ext_id_len, name);
+ 	
  	/* Translate any separators in userid+mailbox */
  	mboxname_hiersep_tointernal(namespace, result+5, 0);
  	return 0;
***************
*** 399,405 ****
  static int mboxname_toexternal_alt(struct namespace *namespace, const char *name,
  				  const char *userid, char *result)
  {
!     char *domain;
      size_t userlen, resultlen;
  
      /* Blank the result, just in case */
--- 806,812 ----
  static int mboxname_toexternal_alt(struct namespace *namespace, const char *name,
  				  const char *userid, char *result)
  {
!     char *domain=NULL;
      size_t userlen, resultlen;
  
      /* Blank the result, just in case */
***************
*** 415,427 ****
  	size_t domainlen = strlen(domain);
  
  	userlen = domain - userid;
  
! 	if (!strncmp(name, domain+1, domainlen-1) &&
! 	    name[domainlen-1] == '!') {
! 	    name += domainlen;
  	}
      }
  
      /* Personal (INBOX) namespace */
      if (!strncasecmp(name, "inbox", 5) &&
  	(name[5] == '\0' || name[5] == '.')) {
--- 822,840 ----
  	size_t domainlen = strlen(domain);
  
  	userlen = domain - userid;
+ 	domain++;
+ 	domainlen--;
  
! 	if (!strncmp(name, domain, domainlen) &&
! 	    name[domainlen] == '!') {
! 	    name += domainlen+1;
  	}
      }
  
+     /* set the empty domain if it doesn't exists */
+     if(!domain)
+ 	domain="";
+ 
      /* Personal (INBOX) namespace */
      if (!strncasecmp(name, "inbox", 5) &&
  	(name[5] == '\0' || name[5] == '.')) {
***************
*** 445,462 ****
      else if (!strncmp(name, "user", 4) &&
  	     (name[4] == '\0' || name[4] == '.')) {
  	size_t prefixlen = strlen(namespace->prefix[NAMESPACE_USER]);
  
! 	if ((prefixlen > MAX_MAILBOX_NAME) || 
! 	    ((name[4] == '.') && 
! 	     ((prefixlen+1+strlen(name+5)) > MAX_MAILBOX_NAME)))
  	    return IMAP_MAILBOX_BADNAME;
  
  	sprintf(result, "%.*s",
  		prefixlen-1, namespace->prefix[NAMESPACE_USER]);
  	resultlen = strlen(result);
! 	if (name[4] == '.') {
! 	    sprintf(result+resultlen, "%c%s", namespace->hier_sep, name+5);
! 	}
      }
  
      /* Shared namespace */
--- 858,909 ----
      else if (!strncmp(name, "user", 4) &&
  	     (name[4] == '\0' || name[4] == '.')) {
  	size_t prefixlen = strlen(namespace->prefix[NAMESPACE_USER]);
+ 	char *ext_id="";
+ 	size_t ext_id_len=0;
  
! 	if (prefixlen > MAX_MAILBOX_NAME)
  	    return IMAP_MAILBOX_BADNAME;
+ 	
+ 	if(name[4] == '.') {
+ 	    if(!imapd_convertuserid) {
+ 		if((prefixlen+1+strlen(name+5)) > MAX_MAILBOX_NAME)
+ 		    return IMAP_MAILBOX_BADNAME;
+ 		name+=5;
+ 	    }
+ 	    /* fetching the user's identifier // sorcerer */
+ 	    else {
+ 		char *sep;
+ 		size_t int_id_len;
+ 
+ 		name+=5;
+ 		sep=strchr(name,'.');
+ 		if(sep)
+ 		    int_id_len=sep-name;
+ 		else
+ 		    int_id_len=strlen(name);
+ 
+ 		if(!int_id_len)
+ 		    return IMAP_MAILBOX_BADNAME;
+ 
+ 		/* we assume that the user domain is same as the name's
+ 		   domain */
+ 		ext_id = mboxname_get_external_id(name, int_id_len, domain, &ext_id_len, (!imapd_nonconverteduserid_allowed)?LDAP_NAME_MUST_EXISTS:0);
+ 		if(!ext_id)
+ 		    return IMAP_MAILBOX_NONEXISTENT;
+ 		if(prefixlen + ext_id_len + strlen(name+int_id_len) > MAX_MAILBOX_NAME)
+ 		    return IMAP_MAILBOX_BADNAME;
+ 		name+=int_id_len;
+ 	    }
+ 	}
  
  	sprintf(result, "%.*s",
  		prefixlen-1, namespace->prefix[NAMESPACE_USER]);
  	resultlen = strlen(result);
! 
! 	/* in the case if fetching id isn't enabled, ext_id variable
! 	   will be empty and name variable will consist of the full
! 	   mailbox name without namespace->prefix[NAMESPACE_USER] */
! 	sprintf(result+resultlen, "%c%.*s%s", namespace->hier_sep, ext_id_len, ext_id, name);
      }
  
      /* Shared namespace */
diff -N -C 3 -r cyrus-imapd-2.2.12.old/imap/mboxname.h cyrus-imapd-2.2.12/imap/mboxname.h
*** cyrus-imapd-2.2.12.old/imap/mboxname.h	2005-11-07 18:24:44 +0300
--- cyrus-imapd-2.2.12/imap/mboxname.h	2005-11-22 18:57:53 +0300
***************
*** 78,83 ****
--- 78,91 ----
  			    void *rock, int force);
  };
  
+ #ifdef ENABLE_CONVERT_USERID
+ /* convert userid initialization and cleanup */
+ int convertuserid_init();
+ int convertuserid_cleanup();
+ /* destroy additional information which is needed to transform userids */
+ void mboxname_cleanup();
+ #endif /* ENABLE_CONVERT_USERID */
+ 
  /* create namespace based on given options */
  int mboxname_init_namespace_ext(struct namespace *namespace, int isadmin, char hier_sep, int isalt);
  /* Create namespace based on config options. */
diff -N -C 3 -r cyrus-imapd-2.2.12.old/lib/hash.c cyrus-imapd-2.2.12/lib/hash.c
*** cyrus-imapd-2.2.12.old/lib/hash.c	2004-05-24 18:32:34 +0400
--- cyrus-imapd-2.2.12/lib/hash.c	2005-11-22 18:57:54 +0300
***************
*** 317,322 ****
--- 317,355 ----
        }
  }
  
+ /* Same as hash_enumerate() but has ability to delete keys while going
+    through a hash table. Return non-zero value from the callback
+    function if you want to delete a key. Delete any external data
+    yourself. */
+ void hash_walk(hash_table *table, int (*func)(char *, void *, void *),
+ 		    void *rock)
+ {
+     unsigned i;
+     bucket *temp, *temp_old, *temp_next;
+ 
+     for (i=0;i<table->size; i++) {
+ 	if ((table->table)[i] != NULL) {
+ 	    for (temp = (table->table)[i], temp_old=NULL;
+ 		 NULL != temp;
+ 		 temp = temp_next) {
+ 
+ 		temp_next = temp->next;
+ 		if(func(temp -> key, temp->data, rock)) {
+ 		    if(temp_old)
+ 			temp_old->next = temp_next;
+ 		    else
+ 			(table->table)[i] = temp_next;
+ 		    if(!table->pool) {
+ 			free(temp->key);
+ 			free(temp);
+ 		    }
+ 		}
+ 		else
+ 		    temp_old=temp;
+ 	    }
+ 	}
+     }
+ }
  
  #ifdef TEST
  
diff -N -C 3 -r cyrus-imapd-2.2.12.old/lib/hash.h cyrus-imapd-2.2.12/lib/hash.h
*** cyrus-imapd-2.2.12.old/lib/hash.h	2003-10-22 22:50:12 +0400
--- cyrus-imapd-2.2.12/lib/hash.h	2005-11-22 18:57:54 +0300
***************
*** 78,83 ****
--- 78,90 ----
  void hash_enumerate(hash_table *table,void (*func)(char *,void *,void *),
  		    void *rock);
  
+ /* Same as hash_enumerate() but has ability to delete keys while going
+    through a hash table. Return non-zero value from the callback
+    function if you want to delete a key. Delete any external data
+    yourself. */
+ void hash_walk(hash_table *table, int (*func)(char *, void *, void *),
+ 	       void *rock);
+ 
  /*
  ** Frees a hash table.  For each node that was inserted in the table,
  ** it calls the function whose address it was passed, with a pointer
diff -N -C 3 -r cyrus-imapd-2.2.12.old/lib/imapoptions cyrus-imapd-2.2.12/lib/imapoptions
*** cyrus-imapd-2.2.12.old/lib/imapoptions	2005-11-07 18:05:36 +0300
--- cyrus-imapd-2.2.12/lib/imapoptions	2005-11-23 15:41:47 +0300
***************
*** 910,915 ****
--- 910,962 ----
     interface, otherwise the user is assumed to be in the default
     domain (if set). */
  
+ { "convertuserid", 0, SWITCH }
+ /* Enable user identifiers conversion via LDAP. This is a default
+    rule: it is possible to set exemptions on some set of users via
+    convertuserid_exempts config variable. If user's rule is 'convert'
+    then he doesn't see user identifiers via IMAP commands. Instead,
+    names got from LDAP are showed. This option is rereaded on each
+    new connected IMAP client, so you don't need to restart the server
+    to apply changes. */
+ 
+ { "convertuserid_exempts", NULL, STRING }
+ /* Exemtions (list of user identifiers) from convertuserid option.
+    This option is rereaded on each new connected IMAP client. */
+ 
+ { "convertuserid_allow_nonconverted", 0, SWITCH }
+ /* Allow to use original userids if there are no information on
+    them in LDAP. This option is rereaded on each new connected IMAP
+    client. */
+ 
+ { "convertuserid_localhost", "127.0.0.1", STRING }
+ /* IP-address which ldapd processes are binding to. You will never
+    need to change the default value. */
+ 
+ { "convertuserid_udpport", 10001, INT }
+ /* UDP port number where ldapd processes are listening on. ldapd is a
+    process which perfoms queries to LDAP. */
+ 
+ { "convertuserid_ldap_host", NULL, STRING }
+ /* LDAP server host used by ldapd. */
+ 
+ { "convertuserid_ldap_port", 389, INT }
+ /* LDAP server port used by ldapd. */
+ 
+ { "convertuserid_ldap_user", NULL, STRING }
+ /* LDAP user used by ldapd. */
+ 
+ { "convertuserid_ldap_password", NULL, STRING }
+ /* LDAP user's password used by ldapd. */
+ 
+ { "convertuserid_ldap_base", NULL, STRING }
+ /* LDAP base used by ldapd. */
+ 
+ { "convertuserid_ldap_attr_int", "uid", STRING }
+ /* Name of LDAP attribute storing internal names of users. */
+ 
+ { "convertuserid_ldap_attr_ext", "sn", STRING }
+ /* Name of LDAP attribute storing external names of users. */
+ 
  /*
  .SH SEE ALSO
  .PP
diff -N -C 3 -r cyrus-imapd-2.2.12.old/lib/libconfig.c cyrus-imapd-2.2.12/lib/libconfig.c
*** cyrus-imapd-2.2.12.old/lib/libconfig.c	2004-05-22 07:45:54 +0400
--- cyrus-imapd-2.2.12/lib/libconfig.c	2005-11-22 18:57:54 +0300
***************
*** 161,167 ****
      if(alt_config) config_filename = xstrdup(alt_config);
      else config_filename = xstrdup(CONFIG_FILENAME);
  
!     if(!construct_hash_table(&confighash, CONFIGHASHSIZE, 1)) {
  	fatal("could not construct configuration hash table", EC_CONFIG);
      }
  
--- 161,170 ----
      if(alt_config) config_filename = xstrdup(alt_config);
      else config_filename = xstrdup(CONFIG_FILENAME);
  
!     /* we don't use memory pool for this hash because we may delete
!        keys from it many times (deletions from pooled hash leak the
!        memory) */
!     if(!construct_hash_table(&confighash, CONFIGHASHSIZE, 0)) {
  	fatal("could not construct configuration hash table", EC_CONFIG);
      }
  
***************
*** 508,510 ****
--- 511,919 ----
      }
      fclose(infile);
  }
+ 
+ int config_template_compare(const char *optname, int optid, template_option *opts, int opts_len)
+ {
+     int i;
+ 
+     for(i=0; i<opts_len; i++) {
+ 	switch(opts[i].type) {
+ 	case TEMPLATEOPT_TYPE_KNOWNOPT:
+ 	    if(optid==(int)opts[i].val)
+ 		return 0;
+ 	    break;
+ 	case TEMPLATEOPT_TYPE_EXACTMATCH:
+ 	    if(!strcmp((char *)opts[i].val, optname))
+ 		return 0;
+ 	    break;
+ 	case TEMPLATEOPT_TYPE_PREFIX:
+ 	    if(!strncmp((char *)opts[i].val, optname, strlen((char *)opts[i].val)))
+ 		return 0;
+ 	    break;
+ 	}
+     }
+     return 1;
+ }
+ 
+ static int config_reread_file(const char *filename, template_option *opts, int opts_len)
+ {
+     enum opttype opt = IMAPOPT_ZERO;
+     int lineno = 0;
+     char buf[4096], errbuf[1024];
+     char *p, *q, *key, *fullkey, *srvkey, *val, *newval;
+     int service_specific;
+     int idlen = (config_ident ? strlen(config_ident) : 0);
+     FILE *infile;
+ 
+     if(!opts_len)
+ 	return 0;
+ 
+     /* read in config file */
+     infile = fopen(filename, "r");
+     if (!infile) {
+ 	strlcpy(buf, CYRUS_PATH, sizeof(buf));
+ 	strlcat(buf, filename, sizeof(buf));
+ 	infile = fopen(buf, "r");
+     }
+     if (!infile) {
+ 	syslog(LOG_ERR, "can't open configuration file %s: %s",filename, error_message(errno));
+ 	return -1;
+     }
+ 
+     /* check to see if we've already read this file */
+     if (hash_lookup(filename, &includehash)) {
+ 	syslog(LOG_ERR, "configuration file %s included twice", filename);
+ 	fclose(infile);
+ 	return -1;
+     }
+     else {
+ 	hash_insert(filename, (void*) 0xDEADBEEF, &includehash);
+     }
+     
+     while (fgets(buf, sizeof(buf), infile)) {
+ 	lineno++;
+ 
+ 	service_specific = 0;
+ 	
+ 	if (buf[0] && buf[strlen(buf)-1] == '\n') buf[strlen(buf)-1] = '\0';
+ 	for (p = buf; *p && isspace((int) *p); p++);
+ 	if (!*p || *p == '#') continue;
+ 
+ 	fullkey = key = p;
+ 	if (*p == '@') p++;  /* allow @ as the first char (for directives) */
+ 	while (*p && (isalnum((int) *p) || *p == '-' || *p == '_')) {
+ 	    if (isupper((unsigned char) *p)) *p = tolower((unsigned char) *p);
+ 	    p++;
+ 	}
+ 	if (*p != ':') {
+ 	    syslog(LOG_ERR,
+ 		   "invalid option name on line %d of configuration file %s",
+ 		    lineno, filename);
+ 	    fclose(infile);
+ 	    return -1;
+ 	}
+ 	*p++ = '\0';
+ 	
+ 	while (*p && isspace((int) *p)) p++;
+ 	
+ 	/* remove trailing whitespace */
+ 	for (q = p + strlen(p) - 1; q > p && isspace((int) *q); q--) {
+ 	    *q = '\0';
+ 	}
+ 	
+ 	if (!*p) {
+ 	    syslog(LOG_ERR,
+ 		   "empty option value on line %d of configuration file",
+ 		   lineno);
+ 	    fclose(infile);
+ 	    return -1;
+ 	}
+ 	
+ 	srvkey = NULL;
+ 
+ 	/* Look for directives */
+ 	if (key[0] == '@') {
+ 	    if (!strcasecmp(key, "@include")) {
+ 		if(config_reread_file(p,opts,opts_len)) {
+ 		    fclose(infile);
+ 		    return -1;
+ 		}
+ 		continue;
+ 	    }
+ 	    else {
+ 		syslog(LOG_ERR,
+ 		       "invalid directive on line %d of configuration file %s",
+ 		       lineno, filename);
+ 		fclose(infile);
+ 		return -1;
+ 	    }
+ 	}
+ 
+ 	/* Find if there is a <service>_ prefix */
+ 	if(config_ident && !strncasecmp(key, config_ident, idlen) 
+ 	   && key[idlen] == '_') {
+ 	    /* skip service_ prefix */
+ 	    srvkey = key + idlen + 1;
+ 	}
+ 	
+ 	/* look for a service_ prefix match in imapopts */
+ 	if(srvkey) {
+ 	    for (opt = IMAPOPT_ZERO; opt < IMAPOPT_LAST; opt++) {
+ 		if (!strcasecmp(imapopts[opt].optname, srvkey)) {
+ 		    key = srvkey;
+ 		    service_specific = 1;
+ 		    break;
+ 		}
+ 	    }
+ 	}
+ 	
+ 	/* Did not find a service_ specific match, try looking for an
+ 	 * exact match */
+ 	if(!service_specific) {
+ 	    for (opt = IMAPOPT_ZERO; opt < IMAPOPT_LAST; opt++) {
+ 		if (!strcasecmp(imapopts[opt].optname, key)) {
+ 		    break;
+ 		}
+ 	    }
+ 	}
+ 
+ 	/* If both of those loops failed, it goes verbatim into the
+ 	 * overflow hash table. */
+ 	
+ 	if (opt < IMAPOPT_LAST) {
+ 	    /* skip all options except those mached template */
+ 	    if(config_template_compare(imapopts[opt].optname,opt,opts,opts_len))
+ 		continue;
+ 
+ 	    /* Okay, we know about this configure option.
+ 	     * So first check that we have either
+ 	     *  1. not seen it
+ 	     *  2. seen its generic form, but this is a service specific form
+ 	     *
+ 	     *  If we have already seen a service-specific form, and this is
+ 	     *  a generic form, just skip it and don't moan.
+ 	     */
+ 	    if((imapopts[opt].seen == 1 && !service_specific) 
+ 	     ||(imapopts[opt].seen == 2 && service_specific)) {
+ 		syslog(LOG_ERR,
+ 		       "option '%s' was specified twice in config file (second occurance on line %d)",
+ 		       fullkey, lineno);
+ 		fclose(infile);
+ 		return -1;
+ 	    } else if(imapopts[opt].seen == 2 && !service_specific) {
+ 		continue;
+ 	    }
+ 
+ 	    /* If we've seen it already, we're replacing it, so we need
+ 	     * to free the current string if there is one */
+ 	    if(imapopts[opt].seen && imapopts[opt].t == OPT_STRING)
+ 		free((char *)imapopts[opt].val.s);
+ 
+             if(service_specific)
+ 		imapopts[opt].seen = 2;
+ 	    else
+ 		imapopts[opt].seen = 1;
+ 	    
+ 	    /* this is a known option */
+ 	    switch (imapopts[opt].t) {
+ 	    case OPT_STRING: 
+ 	    {		    
+ 		imapopts[opt].val.s = xstrdup(p);
+ 
+ 		if(opt == IMAPOPT_CONFIGDIRECTORY)
+ 		    config_dir = imapopts[opt].val.s;
+ 
+ 		break;
+ 	    }
+ 	    case OPT_INT:
+ 	    {
+ 		long val;
+ 		char *ptr;
+ 		
+ 		val = strtol(p, &ptr, 0);
+ 		if (!ptr || *ptr != '\0') {
+ 		    /* error during conversion */
+ 		    syslog(LOG_ERR,
+ 			   "non-integer value for %s in line %d",
+ 			   imapopts[opt].optname, lineno);
+ 		    fclose(infile);
+ 		    return -1;
+ 		}
+ 
+ 		imapopts[opt].val.i = val;
+ 		break;
+ 	    }
+ 	    case OPT_SWITCH:
+ 	    {
+ 		if (*p == '0' || *p == 'n' ||
+ 		    (*p == 'o' && p[1] == 'f') || *p == 'f') {
+ 		    imapopts[opt].val.b = 0;
+ 		}
+ 		else if (*p == '1' || *p == 'y' ||
+ 			 (*p == 'o' && p[1] == 'n') || *p == 't') {
+ 		    imapopts[opt].val.b = 1;
+ 		}
+ 		else {
+ 		    /* error during conversion */
+ 		    syslog(LOG_ERR,
+ 			   "non-switch value for %s in line %d",
+ 			   imapopts[opt].optname, lineno);
+ 		    fclose(infile);
+ 		    return -1;
+ 		}
+ 		break;
+ 	    }
+ 	    case OPT_ENUM:
+ 	    case OPT_STRINGLIST:
+ 	    {
+ 		const struct enum_option_s *e = imapopts[opt].enum_options;
+ 
+ 		if (imapopts[opt].t == OPT_ENUM) {
+ 		    /* normalize on/off values */
+ 		    if (!strcmp(p, "1") || !strcmp(p, "yes") ||
+ 			!strcmp(p, "t") || !strcmp(p, "true")) {
+ 			p = "on";
+ 		    } else if (!strcmp(p, "0") || !strcmp(p, "no") ||
+ 			       !strcmp(p, "f") || !strcmp(p, "false")) {
+ 			p = "off";
+ 		    }
+ 		}
+ 
+ 		while (e->name) {
+ 		    if (!strcmp(e->name, p)) break;
+ 		    e++;
+ 		}
+ 		if (e->name) {
+ 		    if (imapopts[opt].t == OPT_ENUM)
+ 			imapopts[opt].val.e = e->val;
+ 		    else
+ 			imapopts[opt].val.s = e->name;
+ 		} else {
+ 		    /* error during conversion */
+ 		    syslog(LOG_ERR,
+ 			   "invalid value for %s in line %d",
+ 			   imapopts[opt].optname, lineno);
+ 		    fclose(infile);
+ 		    return -1;
+ 		}
+ 		break;
+ 	    }
+ 	    case OPT_NOTOPT:
+ 	    default:
+ 		abort();
+ 	    }
+ 	} else {
+ 	    /* check to make sure it's valid for overflow */
+ 	    /* that is, partition names and anything that might be
+ 	     * used by SASL */
+ /*
+   xxx this would be nice if it wasn't for other services who might be
+       sharing this config file and whose names we cannot predict
+ 
+ 	    if(strncasecmp(key,"sasl_",5)
+ 	    && strncasecmp(key,"partition-",10)) {
+ 		sprintf(errbuf,
+ 			"option '%s' is unknown on line %d of config file",
+ 			fullkey, lineno);
+ 		fatal(errbuf, EC_CONFIG);
+ 	    }
+ */
+ 
+ 	    /* skip all options except those mached template */
+ 	    if(config_template_compare(key,0,opts,opts_len))
+ 		continue;
+ 
+ 	    /* Put it in the overflow hash table */
+ 	    newval = xstrdup(p);
+ 	    val = hash_insert(key, newval, &confighash);
+ 	    if(val != newval) {
+ 		syslog(LOG_ERR,
+ 		       "option '%s' was specified twice in config file (second occurance on line %d)",
+ 		       fullkey, lineno);
+ 		fclose(infile);
+ 		return -1;
+ 	    }
+ 	}
+     }
+     fclose(infile);
+     return 0;
+ }
+ 
+ typedef struct _config_delete_cb_param {
+     template_option *opts;
+     int opts_len;
+ } config_delete_cb_param;
+ 
+ int config_delete_cb(char *key, void *data, void *param)
+ {
+     if(!config_template_compare(
+ 	   (char *)key, 0,
+ 	   ((config_delete_cb_param *)param)->opts,
+ 	   ((config_delete_cb_param *)param)->opts_len)) {
+ 	free(data);
+ 	return -1;
+     }
+     return 0;
+ }
+ 
+ extern int config_reread(template_option *opts, int opts_len)
+ {
+     enum opttype opt = IMAPOPT_ZERO;
+     config_delete_cb_param param;
+     int cur_templ;
+     int res;
+ 
+     if(!opts_len)
+ 	return 0;
+ 
+     /* remove options that mached template */
+     for (opt = IMAPOPT_ZERO; opt < IMAPOPT_LAST; opt++) {
+ 	if(imapopts[opt].seen) {
+ 	    /* just set default values for known options */
+ 	    if(!config_template_compare(imapopts[opt].optname,opt,opts,opts_len)) {
+ 		if(imapopts[opt].t == OPT_STRING)
+ 		    free((char *)imapopts[opt].val.s);
+ 		imapopts[opt].val = imapopts[opt].def;
+ 		imapopts[opt].seen = 0;
+ 	    }
+ 	}
+     }
+ 
+     /* check if we need to walk through all hashed options or we just
+        need to delete N hashed options */
+     for(cur_templ=0; cur_templ<opts_len; cur_templ++) {
+ 	if(opts[cur_templ].type==TEMPLATEOPT_TYPE_PREFIX)
+ 	    break;
+ 	else if(opts[cur_templ].type==TEMPLATEOPT_TYPE_EXACTMATCH) {
+ 	    void *data;
+ 	    
+ 	    /* try to delete exact match option (if it exists, it will
+ 	       be deleted) */
+ 	    if((data=hash_del((char *)opts[cur_templ].val, &confighash)))
+ 		free(data);
+ 	}
+     }
+ 
+     /* if we've found a prefix (non-exact) template than walk through
+        all hashed options */
+     if(cur_templ<opts_len) {
+ 	param.opts=opts;
+ 	param.opts_len=opts_len;
+ 
+ 	hash_walk(&confighash, config_delete_cb, &param);
+     }
+ 
+     /* now call config_reread_file() as in config_read() */
+     if(!construct_hash_table(&includehash, INCLUDEHASHSIZE, 1)) {
+ 	fatal("could not construct include file  hash table", EC_CONFIG);
+     }
+ 
+     res=config_reread_file(config_filename, opts, opts_len);
+ 
+     free_hash_table(&includehash, NULL);
+ 
+     if(res)
+ 	return res;
+ 
+     /* Note if we don't change variables below then thay can point to
+        freed memory. TODO: right work with IMAPOPT_DEFAULTPARTITION
+        option and with other partitions pathes is needed. */
+ 
+     /* look up mailbox hashing */
+     config_hashimapspool = config_getswitch(IMAPOPT_HASHIMAPSPOOL);
+ 
+     /* are we supporting virtual domains?  */
+     config_virtdomains = config_getenum(IMAPOPT_VIRTDOMAINS);
+     config_defdomain = config_getstring(IMAPOPT_DEFAULTDOMAIN);
+ 
+     /* look up the hostname we should present to the user */
+     config_servername = config_getstring(IMAPOPT_SERVERNAME);
+     if (!config_servername) {
+ 	config_servername = xmalloc(sizeof(char) * 256);
+ 	gethostname((char *) config_servername, 256);
+     }
+ 
+     config_mupdate_server = config_getstring(IMAPOPT_MUPDATE_SERVER);
+ 
+     return 0;
+ }
diff -N -C 3 -r cyrus-imapd-2.2.12.old/lib/libconfig.h cyrus-imapd-2.2.12/lib/libconfig.h
*** cyrus-imapd-2.2.12.old/lib/libconfig.h	2003-12-29 23:22:55 +0300
--- cyrus-imapd-2.2.12/lib/libconfig.h	2005-11-22 18:57:54 +0300
***************
*** 46,54 ****
--- 46,65 ----
  #include "exitcodes.h"
  #include "imapopts.h"
  
+ /* types for structure template_option */
+ #define TEMPLATEOPT_TYPE_KNOWNOPT   0
+ #define TEMPLATEOPT_TYPE_EXACTMATCH 1
+ #define TEMPLATEOPT_TYPE_PREFIX     2
+ 
+ typedef struct _template_option {
+     void *val;
+     int type;
+ } template_option;
+ 
  /* these will assert() if they're called on the wrong type of
     option (imapopts.c) */
  extern void config_read(const char *alt_config);
+ extern int config_reread(template_option *opts, int opts_len);
  extern const char *config_getstring(enum imapopt opt);
  extern int config_getint(enum imapopt opt);
  extern int config_getswitch(enum imapopt opt);
diff -N -C 3 -r cyrus-imapd-2.2.12.old/man/ldapd.8 cyrus-imapd-2.2.12/man/ldapd.8
*** cyrus-imapd-2.2.12.old/man/ldapd.8	1970-01-01 03:00:00 +0300
--- cyrus-imapd-2.2.12/man/ldapd.8	2005-11-22 18:58:11 +0300
***************
*** 0 ****
--- 1,47 ----
+ .\" -*- nroff -*-
+ .TH LDAPD 8 "Project Cyrus" CMU
+ .SH NAME
+ ldapd \- connector from IMAP server to LDAP
+ .SH SYNOPSIS
+ .B ldapd
+ [
+ .B \-C
+ .I config-file
+ ]
+ [
+ .B \-n
+ .I nproc
+ |
+ .B \-\-prefork
+ .I nproc
+ ]
+ .br
+ .SH DESCRIPTION
+ .I Ldapd
+ is a process that performs queries from IMAP server to LDAP server.
+ It accepts queries via UDP protocol and sends answers to callers.
+ It can be invoked by
+ .IR master (8)
+ but it is possible to start \fIldapd\fR independently.
+ If you want to start \fIldapd\fR via \fBmaster(8)\fR, you have to
+ add launch rule to START section of
+ .IR cyrus.conf (5)
+ .PP
+ .I Ldapd
+ reads its configuration options out of the
+ .IR imapd.conf (5)
+ file unless specified otherwise by \fB-C\fR.
+ .SH OPTIONS
+ .TP
+ .BI \-C " config-file"
+ Read configuration options from \fIconfig-file\fR.
+ .TP
+ .BI \-n " nproc",\ \-\-prefork " nproc"
+ The number of \fIldapd\fR processes to work simultaneously. The default is 1.
+ .TP
+ .SH FILES
+ .TP
+ .B /etc/imapd.conf
+ .SH SEE ALSO
+ .PP
+ \fBimapd.conf(5)\fR, \fBmaster(8)\fR
diff -N -C 3 -r cyrus-imapd-2.2.12.old/man/Makefile.in cyrus-imapd-2.2.12/man/Makefile.in
*** cyrus-imapd-2.2.12.old/man/Makefile.in	2004-03-30 19:18:41 +0400
--- cyrus-imapd-2.2.12/man/Makefile.in	2005-11-22 18:57:54 +0300
***************
*** 62,72 ****
  	$(srcdir)/fud.8 $(srcdir)/imapd.8 $(srcdir)/pop3d.8 $(srcdir)/quota.8 \
  	$(srcdir)/reconstruct.8 $(srcdir)/rmnews.8 $(srcdir)/syncnews.8 \
  	$(srcdir)/mbpath.8 $(srcdir)/timsieved.8 $(srcdir)/master.8 \
! 	$(srcdir)/lmtpd.8 $(srcdir)/idled.8 $(srcdir)/ctl_mboxlist.8 \
! 	$(srcdir)/ctl_deliver.8 $(srcdir)/ctl_cyrusdb.8 $(srcdir)/ipurge.8 \
! 	$(srcdir)/tls_prune.8 $(srcdir)/squatter.8 $(srcdir)/cvt_cyrusdb.8 \
! 	$(srcdir)/notifyd.8 $(srcdir)/chk_cyrus.8 $(srcdir)/mbexamine.8 \
! 	$(srcdir)/nntpd.8 $(srcdir)/fetchnews.8 $(srcdir)/smmapd.8
  
  all: $(MAN1) $(MAN3) $(MAN5) $(MAN8)
  
--- 62,73 ----
  	$(srcdir)/fud.8 $(srcdir)/imapd.8 $(srcdir)/pop3d.8 $(srcdir)/quota.8 \
  	$(srcdir)/reconstruct.8 $(srcdir)/rmnews.8 $(srcdir)/syncnews.8 \
  	$(srcdir)/mbpath.8 $(srcdir)/timsieved.8 $(srcdir)/master.8 \
! 	$(srcdir)/ldapd.8 $(srcdir)/lmtpd.8 $(srcdir)/idled.8 \
! 	$(srcdir)/ctl_mboxlist.8 $(srcdir)/ctl_deliver.8 \
! 	$(srcdir)/ctl_cyrusdb.8 $(srcdir)/ipurge.8 $(srcdir)/tls_prune.8 \
! 	$(srcdir)/squatter.8 $(srcdir)/cvt_cyrusdb.8 $(srcdir)/notifyd.8 \
! 	$(srcdir)/chk_cyrus.8 $(srcdir)/mbexamine.8 $(srcdir)/nntpd.8 \
! 	$(srcdir)/fetchnews.8 $(srcdir)/smmapd.8
  
  all: $(MAN1) $(MAN3) $(MAN5) $(MAN8)
  
diff -N -C 3 -r cyrus-imapd-2.2.12.old/man/master.8 cyrus-imapd-2.2.12/man/master.8
*** cyrus-imapd-2.2.12.old/man/master.8	2004-12-17 19:32:23 +0300
--- cyrus-imapd-2.2.12/man/master.8	2005-11-22 18:57:54 +0300
***************
*** 152,155 ****
  .SH SEE ALSO
  .PP
  \fBcyrus.conf(5)\fR, \fBimapd.conf(5)\fR, \fBimapd(8)\fR,
! \fBpop3d(8)\fR, \fBlmtpd(8)\fR, \fBtimsieved(8)\fR, \fBidled(8)\fR
--- 152,156 ----
  .SH SEE ALSO
  .PP
  \fBcyrus.conf(5)\fR, \fBimapd.conf(5)\fR, \fBimapd(8)\fR,
! \fBpop3d(8)\fR, \fBldapd(8)\fR, \fBlmtpd(8)\fR,
! \fBtimsieved(8)\fR, \fBidled(8)\fR
diff -N -C 3 -r cyrus-imapd-2.2.12.old/master/conf/cmu-backend.conf cyrus-imapd-2.2.12/master/conf/cmu-backend.conf
*** cyrus-imapd-2.2.12.old/master/conf/cmu-backend.conf	2003-10-22 22:03:10 +0400
--- cyrus-imapd-2.2.12/master/conf/cmu-backend.conf	2005-11-23 15:34:24 +0300
***************
*** 6,11 ****
--- 6,13 ----
  
    recover	cmd="ctl_cyrusdb -r"
    mupdatepush   cmd="ctl_mboxlist -m"
+   # this is only necessary if using convertuserid extension
+ #  ldapd		cmd="ldapd -n 5"
  }
  
  # UNIX sockets start with a slash and are put into /var/imap/sockets
diff -N -C 3 -r cyrus-imapd-2.2.12.old/master/conf/cmu-frontend.conf cyrus-imapd-2.2.12/master/conf/cmu-frontend.conf
*** cyrus-imapd-2.2.12.old/master/conf/cmu-frontend.conf	2003-10-22 22:03:10 +0400
--- cyrus-imapd-2.2.12/master/conf/cmu-frontend.conf	2005-11-23 15:34:25 +0300
***************
*** 2,7 ****
--- 2,9 ----
    auth		cmd="/usr/local/bin/ksrvtgt -l 3600 imap @SHORTHOST@ ANDREW.CMU.EDU /imap/conf/srvtab"
  
    mboxlist	cmd="ctl_cyrusdb -r"
+   # this is only necessary if using convertuserid extension
+ #  ldapd		cmd="ldapd -n 5"
  }
  
  # UNIX sockets start with a slash and are put into /var/imap/sockets
diff -N -C 3 -r cyrus-imapd-2.2.12.old/master/conf/normal.conf cyrus-imapd-2.2.12/master/conf/normal.conf
*** cyrus-imapd-2.2.12.old/master/conf/normal.conf	2003-10-22 22:03:10 +0400
--- cyrus-imapd-2.2.12/master/conf/normal.conf	2005-11-23 15:34:26 +0300
***************
*** 6,11 ****
--- 6,13 ----
  
    # this is only necessary if using idled for IMAP IDLE
  #  idled		cmd="idled"
+   # this is only necessary if using convertuserid extension
+ #  ldapd		cmd="ldapd -n 5"
  }
  
  # UNIX sockets start with a slash and are put into /var/imap/socket
diff -N -C 3 -r cyrus-imapd-2.2.12.old/master/conf/prefork.conf cyrus-imapd-2.2.12/master/conf/prefork.conf
*** cyrus-imapd-2.2.12.old/master/conf/prefork.conf	2003-10-22 22:03:10 +0400
--- cyrus-imapd-2.2.12/master/conf/prefork.conf	2005-11-23 15:34:27 +0300
***************
*** 6,11 ****
--- 6,13 ----
  
    # this is only necessary if using idled for IMAP IDLE
  #  idled		cmd="idled"
+   # this is only necessary if using convertuserid extension
+ #  ldapd		cmd="ldapd -n 5"
  }
  
  # UNIX sockets start with a slash and are put into /var/imap/sockets
diff -N -C 3 -r cyrus-imapd-2.2.12.old/master/conf/small.conf cyrus-imapd-2.2.12/master/conf/small.conf
*** cyrus-imapd-2.2.12.old/master/conf/small.conf	2002-10-02 00:46:01 +0400
--- cyrus-imapd-2.2.12/master/conf/small.conf	2005-11-23 15:34:22 +0300
***************
*** 6,11 ****
--- 6,13 ----
  
    # this is only necessary if using idled for IMAP IDLE
  #  idled		cmd="idled"
+   # this is only necessary if using convertuserid extension
+ #  ldapd		cmd="ldapd -n 5"
  }
  
  # UNIX sockets start with a slash and are put into /var/imap/sockets
diff -N -C 3 -r cyrus-imapd-2.2.12.old/notifyd/Makefile.in cyrus-imapd-2.2.12/notifyd/Makefile.in
*** cyrus-imapd-2.2.12.old/notifyd/Makefile.in	2005-11-07 18:05:31 +0300
--- cyrus-imapd-2.2.12/notifyd/Makefile.in	2005-11-22 18:57:54 +0300
***************
*** 72,78 ****
  SIEVE_LIBS = @SIEVE_LIBS@
  IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
  LIB_WRAP = @LIB_WRAP@
! LIBS = @ZEPHYR_LIBS@ @LIBS@ $(IMAP_COM_ERR_LIBS)
  DEPLIBS=../imap/mutex_fake.o ../imap/libimap.a $(SIEVE_LIBS) ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
  
  PURIFY=/usr/local/bin/purify
--- 72,78 ----
  SIEVE_LIBS = @SIEVE_LIBS@
  IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
  LIB_WRAP = @LIB_WRAP@
! LIBS = @ZEPHYR_LIBS@ @LIBS@ $(IMAP_COM_ERR_LIBS) -lredblack -lldap
  DEPLIBS=../imap/mutex_fake.o ../imap/libimap.a $(SIEVE_LIBS) ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
  
  PURIFY=/usr/local/bin/purify
diff -N -C 3 -r cyrus-imapd-2.2.12.old/ptclient/Makefile.in cyrus-imapd-2.2.12/ptclient/Makefile.in
*** cyrus-imapd-2.2.12.old/ptclient/Makefile.in	2005-11-07 18:05:27 +0300
--- cyrus-imapd-2.2.12/ptclient/Makefile.in	2005-11-22 18:57:54 +0300
***************
*** 58,64 ****
  AFS_LIBS = @AFS_LIBS@
  IMAP_LIBS = @IMAP_LIBS@ @LIB_RT@
  SIEVE_LIBS = @SIEVE_LIBS@
! LIBS = $(IMAP_LIBS) @COM_ERR_LIBS@
  LIB_SASL = @LIB_SASL@
  LIB_WRAP = @LIB_WRAP@
  DEPLIBS = ../imap/libimap.a $(SIEVE_LIBS) ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@ 
--- 58,64 ----
  AFS_LIBS = @AFS_LIBS@
  IMAP_LIBS = @IMAP_LIBS@ @LIB_RT@
  SIEVE_LIBS = @SIEVE_LIBS@
! LIBS = $(IMAP_LIBS) @COM_ERR_LIBS@ -lredblack -lldap
  LIB_SASL = @LIB_SASL@
  LIB_WRAP = @LIB_WRAP@
  DEPLIBS = ../imap/libimap.a $(SIEVE_LIBS) ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@ 
diff -N -C 3 -r cyrus-imapd-2.2.12.old/README.convertuserid cyrus-imapd-2.2.12/README.convertuserid
*** cyrus-imapd-2.2.12.old/README.convertuserid	1970-01-01 03:00:00 +0300
--- cyrus-imapd-2.2.12/README.convertuserid	2005-11-23 15:44:26 +0300
***************
*** 0 ****
--- 1,14 ----
+ Cyrus IMAP convertuserid patch
+ -------------------------------
+ 
+ This patch is needed to add ability to the server to hide
+ real users indentifiers and to replace them to other ones
+ which are got from LDAP.
+ 
+ Steps you need to do to get convertuserid worked:
+ 1. Build the server with --enable-convertuserid 'configure' option;
+ 2. Set converuserid* options in imapd.conf. See imapd.conf(5)
+    for details. The default action (without any converuserid*
+    option set) is "don't convert";
+ 3. Add "ldapd" in START section of cyrus.conf. See ldapd(8) for
+    details.
diff -N -C 3 -r cyrus-imapd-2.2.12.old/timsieved/Makefile.in cyrus-imapd-2.2.12/timsieved/Makefile.in
*** cyrus-imapd-2.2.12.old/timsieved/Makefile.in	2004-05-28 22:03:10 +0400
--- cyrus-imapd-2.2.12/timsieved/Makefile.in	2005-11-22 18:57:55 +0300
***************
*** 71,77 ****
  IMAP_LIBS = @IMAP_LIBS@ @LIB_RT@
  IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
  LIB_WRAP = @LIB_WRAP@
! LIBS = $(IMAP_COM_ERR_LIBS)
  DEPLIBS=../sieve/libsieve.a ../imap/mutex_fake.o ../imap/libimap.a ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
  
  PURIFY=/usr/local/bin/purify
--- 71,77 ----
  IMAP_LIBS = @IMAP_LIBS@ @LIB_RT@
  IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
  LIB_WRAP = @LIB_WRAP@
! LIBS = $(IMAP_COM_ERR_LIBS) -lredblack -lldap
  DEPLIBS=../sieve/libsieve.a ../imap/mutex_fake.o ../imap/libimap.a ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
  
  PURIFY=/usr/local/bin/purify
diff -N -C 3 -r cyrus-imapd-2.2.12.old/tools/config2header cyrus-imapd-2.2.12/tools/config2header
*** cyrus-imapd-2.2.12.old/tools/config2header	2005-11-07 18:05:37 +0300
--- cyrus-imapd-2.2.12/tools/config2header	2005-11-22 18:57:55 +0300
***************
*** 126,132 ****
  
  struct imapopt_s imapopts[] =
  {
!   { IMAPOPT_ZERO, "", 0, { NULL }, OPT_NOTOPT, {  { NULL, IMAP_ENUM_ZERO } } },
  EOF
      ;
  
--- 126,132 ----
  
  struct imapopt_s imapopts[] =
  {
!   { IMAPOPT_ZERO, "", 0, { NULL }, { NULL }, OPT_NOTOPT, {  { NULL, IMAP_ENUM_ZERO } } },
  EOF
      ;
  
***************
*** 204,210 ****
  			: "{(void*)$2}";
  	}
  
! 	print CFILE "  { IMAPOPT_", uc($opt), ", \"$1\", 0, $def, OPT_$3, { $enums { NULL, IMAP_ENUM_ZERO } } },\n";
      } else {
  	#chomp;
  	#print "rejected '$_'\n";
--- 204,210 ----
  			: "{(void*)$2}";
  	}
  
! 	print CFILE "  { IMAPOPT_", uc($opt), ", \"$1\", 0, $def, $def, OPT_$3, { $enums { NULL, IMAP_ENUM_ZERO } } },\n";
      } else {
  	#chomp;
  	#print "rejected '$_'\n";
***************
*** 251,256 ****
--- 251,257 ----
      const char *optname;
      int seen;
      union config_value val;
+     union config_value def;
      const enum opttype t;
  EOF
  ;
***************
*** 265,271 ****
      ;
  
  print CFILE <<EOF
!   { IMAPOPT_LAST, NULL, 0, { NULL }, OPT_NOTOPT, {  { NULL, IMAP_ENUM_ZERO } } }
  };
  
  /* c code goes here */
--- 266,272 ----
      ;
  
  print CFILE <<EOF
!   { IMAPOPT_LAST, NULL, 0, { NULL }, { NULL }, OPT_NOTOPT, {  { NULL, IMAP_ENUM_ZERO } } }
  };
  
  /* c code goes here */
