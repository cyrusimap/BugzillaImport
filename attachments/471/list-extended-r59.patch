diff -r --exclude=.svn ../cyrushead/configure.in ./configure.in
936,937c936,937
< AC_ARG_ENABLE(listext,
< 	[  --enable-listext        enable IMAP List extensions],
---
> AC_ARG_ENABLE(list-extended,
> 	[  --enable-list-extended  enable IMAP LIST-EXTENDED List extensions],
939c939
< 		AC_DEFINE(ENABLE_LISTEXT,[],[Enable the LISTEXT extension?])
---
> 		AC_DEFINE(ENABLE_LIST_EXTENDED,[],[Enable the LIST-EXTENDED extension?])
diff -r --exclude=.svn ../cyrushead/doc/specs.html ./doc/specs.html
57c57
< <TR><TD><A HREF="http://www.ietf.org/internet-drafts/draft-ietf-imapext-list-extensions-13.txt">
---
> <TR><TD><A HREF="http://www.ietf.org/internet-drafts/draft-ietf-imapext-list-extensions-17.txt">
diff -r --exclude=.svn ../cyrushead/imap/imapd.c ./imap/imapd.c
74a75
> #include "hash.h"
157a159
> 
196a199,252
> static struct mbox_name_attribute {
>     int flag;
>     char *id;
> } mbox_name_attributes[] = {
>     /* from RFC 3501 */
>     { MBOX_ATTRIBUTE_NOINFERIORS,   "\\Noinferiors"   },
>     { MBOX_ATTRIBUTE_NOSELECT,      "\\Noselect"      },
>     { MBOX_ATTRIBUTE_MARKED,        "\\Marked"        },
>     { MBOX_ATTRIBUTE_UNMARKED,      "\\Unmarked"      },
> 
>     /* from draft-ietf-imapext-list-extensions-17.txt */
>     { MBOX_ATTRIBUTE_NONEXISTENT,   "\\NonExistent"   },
>     { MBOX_ATTRIBUTE_SUBSCRIBED,    "\\Subscribed"    },
>     { MBOX_ATTRIBUTE_REMOTE,        "\\Remote"        },
>     { MBOX_ATTRIBUTE_HASCHILDREN,   "\\HasChildren"   },
>     { MBOX_ATTRIBUTE_HASNOCHILDREN, "\\HasNoChildren" },
> 
>     { 0, NULL }
> };
> 
> /*
>  * These bitmasks define how List selection options can be combined:
>  * list_select_mod_opts may only be used if at least one list_select_base_opt
>  * is also present.
>  * For example, (RECURSIVEMATCH) and (RECURSIVEMATCH REMOTE) are invalid, but
>  * (RECURSIVEMATCH SUBSCRIBED) is ok.
>  */
> static const int list_select_base_opts = LIST_SEL_SUBSCRIBED;
> static const int list_select_mod_opts = LIST_SEL_RECURSIVEMATCH;
> 
> /* structure that list_data passes its callbacks */
> struct list_rock {
>     int opts;
>     char *last_name;
>     int last_attributes;
>     int trailing_percent; /* the mailbox name arg ends with a %
>                            * causes special behavior with non-extended LIST
> 			   * and LSUB */
> };
> 
> /* Information about one mailbox name that LIST returns */
> struct list_entry {
>     char *name;
>     int attributes; /* bitmap of MBOX_ATTRIBUTE_* */
> };
> 
> /* structure that list_data_recursivematch passes its callbacks */
> struct list_rock_recursivematch {
>     int opts;
>     struct hash_table table;    /* maps mailbox names to attributes (int *) */
>     int count;                  /* # of entries in table */
>     struct list_entry *array;
> };
> 
227a284,286
> void parse_list(char *tag);
> void do_list(char *tag, int listopts, char *reference,
> 	     struct strlist *patterns);
269,270c328,330
< #ifdef ENABLE_LISTEXT
< int getlistopts(char *tag, int *listopts);
---
> #ifdef ENABLE_LIST_EXTENDED
> int getlistselopts(char *tag, int *opts);
> int getlistretopts(char *tag, int *opts);
295,297c355,369
< static int listdata(char *name, int matchlen, int maycreate, void *rock);
< static void mstringdata(char *cmd, char *name, int matchlen, int maycreate,
< 			int listopts);
---
> 
> static int set_haschildren(char *name, int matchlen, int maycreate,
> 			   int *attributes);
> static void list_response(char *name, int attributes, int opts);
> static int set_subscribed(char *name, int matchlen, int maycreate,
> 			  int *attributes);
> static char *canonical_list_pattern(const char *reference, const char *pattern);
> static void canonical_list_patterns(char *reference, struct strlist *patterns);
> static int list_cb(char *name, int matchlen, int maycreate,
> 		  struct list_rock *rock);
> static int subscribed_cb(char *name, int matchlen, int maycreate,
> 			 struct list_rock *rock);
> static void list_data(char *reference, int listopts, struct strlist *patterns);
> static void list_data_remote(char *tag, int listopts, char *reference,
> 			     struct strlist *pattern);
1359,1379c1431,1434
< 		int listopts = LIST_CHILDREN;
< #ifdef ENABLE_LISTEXT
< 		/* Check for and parse LISTEXT options */
< 		c = prot_getc(imapd_in);
< 		if (c == '(') {
< 		    c = getlistopts(tag.s, &listopts);
< 		    if (c == EOF) {
< 			eatline(imapd_in, c);
< 			continue;
< 		    }
< 		}
< 		else
< 		    prot_ungetc(c, imapd_in);
< #endif /* ENABLE_LISTEXT */
< 		if (imapd_magicplus) listopts += LIST_SUBSCRIBED;
< 		c = getastring(imapd_in, imapd_out, &arg1);
< 		if (c != ' ') goto missingargs;
< 		c = getastring(imapd_in, imapd_out, &arg2);
< 		if (c == '\r') c = prot_getc(imapd_in);
< 		if (c != '\n') goto extraargs;
< 		cmd_list(tag.s, listopts, arg1.s, arg2.s);
---
> 		if (c != ' ')
> 		    goto missingargs;
> 
> 		parse_list(tag.s);
1389c1444,1445
< 		cmd_list(tag.s, LIST_LSUB | LIST_CHILDREN, arg1.s, arg2.s);
---
> 		cmd_list(tag.s, LIST_OPT_LSUB | LIST_SEL_SUBSCRIBED,
> 			 arg1.s, arg2.s);
1561c1617,1619
< 		cmd_list(tag.s, LIST_CHILDREN | LIST_REMOTE, arg1.s, arg2.s);
---
> 		cmd_list(tag.s,
> 			 LIST_OPT_RLIST | LIST_SEL_REMOTE | LIST_RET_CHILDREN,
> 			 arg1.s, arg2.s);
1571c1629,1631
< 		cmd_list(tag.s, LIST_LSUB | LIST_CHILDREN | LIST_REMOTE,
---
> 		cmd_list(tag.s,
> 			 LIST_OPT_RLIST | LIST_OPT_LSUB | LIST_SEL_REMOTE
> 			 | LIST_SEL_SUBSCRIBED | LIST_RET_CHILDREN,
1572a1633
> 
2590,2592c2651,2653
< #ifdef ENABLE_LISTEXT
<     prot_printf(imapd_out, " LISTEXT LIST-SUBSCRIBED");
< #endif /* ENABLE_LISTEXT */
---
> #ifdef ENABLE_LIST_EXTENDED
>     prot_printf(imapd_out, " LISTEXT LIST-SUBSCRIBED LIST-EXTENDED");
> #endif
5675c5736,5737
< static int mstringdatacalls;
---
> /* no times the callbacks for findall/findsub have been called */
> static int list_callback_calls;
5678c5740
<  * Perform a LIST or LSUB command
---
>  * Parse and perform a LIST command.
5680c5742
< void cmd_list(char *tag, int listopts, char *reference, char *pattern)
---
> void parse_list(char *tag)
5682,5697c5744,5748
<     char *buf = NULL;
<     int patlen = 0;
<     int reflen = 0;
<     static int ignorereference = 0;
<     clock_t start = clock();
<     char mytime[100];
<     int (*findall)(struct namespace *namespace,
< 		   const char *pattern, int isadmin, char *userid, 
< 		   struct auth_state *auth_state, int (*proc)(),
< 		   void *rock);
<     int (*findsub)(struct namespace *namespace,
< 		   const char *pattern, int isadmin, char *userid, 
< 		   struct auth_state *auth_state, int (*proc)(),
< 		   void *rock, int force);
< 
<     if (listopts & LIST_REMOTE) supports_referrals = !disable_referrals;
---
>     int listopts = 0;
>     static struct buf buf;
>     int c;
>     struct strlist *patterns = NULL;
>     char *reference;
5699,5702c5750,5759
<     /* Ignore the reference argument?
<        (the behavior in 1.5.10 & older) */
<     if (ignorereference == 0) {
< 	ignorereference = config_getswitch(IMAPOPT_IGNOREREFERENCE);
---
> #ifdef ENABLE_LIST_EXTENDED
>     /* Check for and parse LISTEXT selection options */
>     c = prot_getc(imapd_in);
>     if (c == '(') {
> 	listopts |= LIST_OPT_EXTENDED;
> 	c = getlistselopts(tag, &listopts);
> 	if (c == EOF) {
> 	    eatline(imapd_in, c);
> 	    return;
> 	}
5703a5761,5763
>     else
> 	prot_ungetc(c, imapd_in);
> #endif
5705,5706c5765
<     /* Reset state in mstringdata */
<     mstringdata(NULL, NULL, 0, 0, 0);
---
>     if (imapd_magicplus) listopts |= LIST_SEL_SUBSCRIBED | LIST_RET_SUBSCRIBED;
5708,5724c5767,5793
<     if (!pattern[0] && !(listopts & LIST_LSUB)) {
< 	/* Special case: query top-level hierarchy separator */
< 	prot_printf(imapd_out, "* LIST (\\Noselect) \"%c\" \"\"\r\n",
< 		    imapd_namespace.hier_sep);
<     } else if ((listopts & (LIST_LSUB | LIST_SUBSCRIBED)) &&
< 	       (backend_inbox || (backend_inbox = proxy_findinboxserver()))) {
< 	/* remote INBOX */
< 	if ((listopts & LIST_SUBSCRIBED) && (listopts & LIST_EXT) &&
< 	    CAPA(backend_inbox, CAPA_LISTSUBSCRIBED)) {
< 	    prot_printf(backend_inbox->out, "%s List (subscribed", tag);
< 	    if (listopts & LIST_CHILDREN)
< 		prot_printf(backend_inbox->out, " children");
< 	    if (listopts & LIST_REMOTE)
< 		prot_printf(backend_inbox->out, " remote");
< 	    prot_printf(backend_inbox->out, ") ");
< 	} else {
< 	    prot_printf(backend_inbox->out, "%s Lsub ", tag);
---
>     /* Read in reference name */
>     c = getastring(imapd_in, imapd_out, &buf);
>     if (c == EOF && !*buf.s) {
> 	prot_printf(imapd_out,
> 		    "%s BAD Missing required argument to List: reference name\r\n",
> 		    tag);
> 	eatline(imapd_in, c);
> 	return;
>     }
>     if (c != ' ') {
> 	prot_printf(imapd_out,
> 		    "%s BAD Missing required argument to List: mailbox pattern\r\n", tag);
> 	eatline(imapd_in, c);
> 	return;
>     }
>     reference = xstrdup(buf.s);
> 
>     /* Read in mailbox pattern(s) */
> #ifdef ENABLE_LIST_EXTENDED
>     c = prot_getc(imapd_in);
>     if (c == '(') {
> 	listopts |= LIST_OPT_EXTENDED | LIST_OPT_EXTENDED_V17;
> 	for (;;) {
> 	    c = getastring(imapd_in, imapd_out, &buf);
> 	    if (*buf.s)
> 		appendstrlist(&patterns, buf.s);
> 	    if (c != ' ') break;
5726,5744c5795,5817
< 	prot_printf(backend_inbox->out, 
< 		    "{%d+}\r\n%s {%d+}\r\n%s\r\n",
< 		    strlen(reference), reference,
< 		    strlen(pattern), pattern);
< 	pipe_lsub(backend_inbox, tag, 0, (listopts & LIST_LSUB) ? "LSUB" : "LIST");
<     } else {
< 	/* Do we need to concatenate fields? */
< 	if (!ignorereference || pattern[0] == imapd_namespace.hier_sep) {
< 	    /* Either
< 	     * - name begins with dot
< 	     * - we're configured to honor the reference argument */
< 
< 	    /* Allocate a buffer, figure out how to stick the arguments
< 	       together, do it, then do that instead of using pattern. */
< 	    patlen = strlen(pattern);
< 	    reflen = strlen(reference);
< 	    
< 	    buf = xmalloc(patlen + reflen + 1);
< 	    buf[0] = '\0';
---
> 	if (c != ')') {
> 	    prot_printf(imapd_out,
> 			"%s BAD Invalid syntax in List command\r\n", tag);
> 	    eatline(imapd_in, c);
> 	    goto freeargs;
> 	}
> 	c = prot_getc(imapd_in);
>     }
>     else {
> 	prot_ungetc(c, imapd_in);
> #endif
>     	c = getastring(imapd_in, imapd_out, &buf);
> 	if (c == EOF) {
> 	    prot_printf(imapd_out,
> 			"%s BAD Missing required argument to List: mailbox pattern\r\n",
> 			tag);
> 	    eatline(imapd_in, c);
> 	    goto freeargs;
> 	}
> 	appendstrlist(&patterns, buf.s);
> #ifdef ENABLE_LIST_EXTENDED
>     }
> #endif
5746,5755c5819,5826
< 	    if (*reference) {
< 		/* check for LIST A. .B, change to LIST "" A.B */
< 		if (reference[reflen-1] == imapd_namespace.hier_sep &&
< 		    pattern[0] == imapd_namespace.hier_sep) {
< 		    reference[--reflen] = '\0';
< 		}
< 		strcpy(buf, reference);
< 	    }
< 	    strcat(buf, pattern);
< 	    pattern = buf;
---
> #ifdef ENABLE_LIST_EXTENDED
>     /* Check for and parse LISTEXT return options */
>     if (c == ' ') {
> 	listopts |= LIST_OPT_EXTENDED | LIST_OPT_EXTENDED_V17;
> 	c = getlistretopts(tag, &listopts);
> 	if (c == EOF) {
> 	    eatline(imapd_in, c);
> 	    goto freeargs;
5756a5828,5829
>     }
> #endif
5758,5761c5831,5838
< 	/* Translate any separators in pattern */
< 	mboxname_hiersep_tointernal(&imapd_namespace, pattern,
< 				    config_virtdomains ?
< 				    strcspn(pattern, "@") : 0);
---
>     /* check for CRLF */
>     if (c == '\r') c = prot_getc(imapd_in);
>     if (c != '\n') {
> 	prot_printf(imapd_out,
> 		    "%s BAD Unexpected extra arguments to List\r\n", tag);
> 	eatline(imapd_in, c);
> 	goto freeargs;
>     }
5763,5775c5840,5845
< 	/* Check to see if we should only list the personal namespace */
< 	if (!strcmp(pattern, "*")
< 	    && config_getswitch(IMAPOPT_FOOLSTUPIDCLIENTS)) {
< 	    if (buf) free(buf);
< 	    buf = xstrdup("INBOX*");
< 	    pattern = buf;
< 	    findsub = mboxlist_findsub;
< 	    findall = mboxlist_findall;
< 	}
< 	else {
< 	    findsub = imapd_namespace.mboxlist_findsub;
< 	    findall = imapd_namespace.mboxlist_findall;
< 	}
---
>     if (listopts & LIST_OPT_EXTENDED_V03 && listopts & LIST_OPT_EXTENDED_V17) {
> 	/* client mixed different listext versions */
> 	prot_printf(imapd_out,
> 		    "%s BAD Invalid syntax in extended List command\r\n", tag);
> 	goto freeargs;
>     }
5777,5778c5847
< 	if (listopts & (LIST_LSUB | LIST_SUBSCRIBED)) {
< 	    int force = config_getswitch(IMAPOPT_ALLOWALLSUBSCRIBE);
---
>     do_list(tag, listopts, reference, patterns);
5780,5788c5849,5853
< 	    (*findsub)(&imapd_namespace, pattern,
< 		       imapd_userisadmin, imapd_userid, imapd_authstate,
< 		       listdata, &listopts, force);
< 	}
< 	else {
< 	    (*findall)(&imapd_namespace, pattern,
< 		       imapd_userisadmin, imapd_userid, imapd_authstate,
< 		       listdata, &listopts);
< 	}
---
>   freeargs:
>     freestrlist(patterns);
>     free(reference);
>     return;
> }
5790c5855,5875
< 	listdata((char *)0, 0, 0, &listopts);
---
> /* A wrapper for do_list. */
> void cmd_list(char *tag, int listopts, char *reference, char *pattern)
> {
>     char *new_pattern = xstrdup(pattern);
>     struct strlist strlist = { new_pattern, NULL, NULL, NULL };
>     do_list(tag, listopts, reference, &strlist);
>     free(strlist.s);
> }
> 
> /*
>  * Perform a LIST, LSUB, RLIST or RLSUB command
>  */
> void do_list(char *tag, int listopts, char *reference,
> 	     struct strlist *patterns)
> {
>     clock_t start = clock();
>     char mytime[100];
> 
>     if (listopts & LIST_SEL_REMOTE) supports_referrals = !disable_referrals;
> 
>     list_callback_calls = 0;
5792c5877,5889
< 	if (buf) free(buf);
---
>     if (!(listopts & LIST_OPT_LSUB)
> 	    && !(listopts & LIST_OPT_EXTENDED)
> 	    && !*patterns->s) {
> 	/* special case: query top-level hierarchy separator */
> 	prot_printf(imapd_out, "* %sLIST (\\Noselect) \"%c\" \"\"\r\n",
> 		    (listopts & LIST_OPT_RLIST) ? "R" : "",
> 		    imapd_namespace.hier_sep);
>     } else if (listopts & (LIST_SEL_SUBSCRIBED | LIST_RET_SUBSCRIBED)
> 	    && (backend_inbox || (backend_inbox = proxy_findinboxserver()))) {
> 	/* remote inbox */
> 	list_data_remote(tag, listopts, reference, patterns);
>     } else {
> 	list_data(reference, listopts, patterns);
5795,5796c5892,5893
<     imapd_check(!(listopts & (LIST_LSUB | LIST_SUBSCRIBED)) ?
< 		backend_inbox : NULL, 0, 0);
---
>     imapd_check((listopts & LIST_SEL_SUBSCRIBED) ?  NULL : backend_inbox,
> 		0, 0);
5800,5801c5897,5901
<     prot_printf(imapd_out, "%s OK %s (%s secs %d calls)\r\n", tag,
< 		error_message(IMAP_OK_COMPLETED), mytime, mstringdatacalls);
---
>     prot_printf(imapd_out, "%s OK %s (%s secs", tag,
> 		error_message(IMAP_OK_COMPLETED), mytime);
>     if (list_callback_calls)
> 	prot_printf(imapd_out, " %u calls", list_callback_calls);
>     prot_printf(imapd_out, ")\r\n");
5803c5903
<   
---
> 
8709c8809
< #ifdef ENABLE_LISTEXT
---
> #ifdef ENABLE_LIST_EXTENDED
8711c8811
<  * Parse LIST options.
---
>  * Parse LIST selection options.
8714c8814
< int getlistopts(char *tag, int *listopts)
---
> int getlistselopts(char *tag, int *opts)
8717c8817
<     static struct buf arg;
---
>     static struct buf buf;
8719c8819,8822
<     *listopts = LIST_EXT;
---
>     if ( (c = prot_getc(imapd_in)) == ')')
> 	return prot_getc(imapd_in);
>     else
> 	prot_ungetc(c, imapd_in);
8722,8723c8825
< 	c = getword(imapd_in, &arg);
< 	if (!arg.s[0]) break;
---
> 	c = getword(imapd_in, &buf);
8725,8727c8827,8831
< 	lcase(arg.s);
< 	if (!strcmp(arg.s, "subscribed")) {
< 	    *listopts |= LIST_SUBSCRIBED;
---
> 	if (!*buf.s) {
> 	    prot_printf(imapd_out,
> 			"%s BAD Invalid syntax in List command\r\n",
> 			tag);
> 	    return EOF;
8729,8730c8833,8848
< 	else if (!strcmp(arg.s, "children")) {
< 	    *listopts |= LIST_CHILDREN;
---
> 
> 	lcase(buf.s);
> 
> 	if (!strcmp(buf.s, "subscribed")) {
> 	    *opts |= LIST_SEL_SUBSCRIBED | LIST_RET_SUBSCRIBED;
> 	} else if (!strcmp(buf.s, "remote")) {
> 	    *opts |= LIST_SEL_REMOTE;
> 	} else if (!strcmp(buf.s, "recursivematch")) {
> 	    *opts |= LIST_SEL_RECURSIVEMATCH | LIST_OPT_EXTENDED_V17;
> 	} else if (!strcmp(buf.s, "children")) {
> 	    *opts |= LIST_RET_CHILDREN | LIST_OPT_EXTENDED_V03;
> 	} else {
> 	    prot_printf(imapd_out,
> 			"%s BAD Invalid List selection option \"%s\"\r\n",
> 			tag, buf.s);
> 	    return EOF;
8732,8733c8850,8910
< 	else if (!strcmp(arg.s, "remote")) {
< 	    *listopts |= LIST_REMOTE;
---
> 
> 	if (c != ' ') break;
>     }
> 
>     if (c != ')') {
> 	prot_printf(imapd_out,
> 		    "%s BAD Missing close parenthesis for List selection options\r\n", tag);
> 	return EOF;
>     }
> 
>     if (*opts & list_select_mod_opts
> 	    && ! (*opts & list_select_base_opts)) {
> 	prot_printf(imapd_out,
> 		    "%s BAD Invalid combination of selection options\r\n",
> 		    tag);
> 	return EOF;
>     }
> 
>     return prot_getc(imapd_in);
> }
> 
> /*
>  * Parse LIST return options.
>  * The command has been parsed up to and including the ' ' before RETURN.
>  */
> int getlistretopts(char *tag, int *opts) {
>     static struct buf buf;
>     int c;
> 
>     c = getword(imapd_in, &buf);
>     if (!*buf.s) {
> 	prot_printf(imapd_out,
> 		    "%s BAD Invalid syntax in List command\r\n", tag);
> 	return EOF;
>     }
>     lcase(buf.s);
>     if (strcasecmp(buf.s, "return")) {
> 	prot_printf(imapd_out,
> 		    "%s BAD Unexpected extra argument to List: \"%s\"\r\n",
> 		    tag, buf.s);
> 	return EOF;
>     }
> 
>     if (c != ' ' || (c = prot_getc(imapd_in)) != '(') {
> 	prot_printf(imapd_out,
> 		    "%s BAD Missing return argument list\r\n", tag);
> 	return EOF;
>     }
> 
>     if ( (c = prot_getc(imapd_in)) == ')')
> 	return prot_getc(imapd_in);
>     else
> 	prot_ungetc(c, imapd_in);
> 
>     for (;;) {
> 	c = getword(imapd_in, &buf);
> 
> 	if (!*buf.s) {
> 	    prot_printf(imapd_out,
> 			"%s BAD Invalid syntax in List command\r\n", tag);
> 	    return EOF;
8734a8912,8918
> 
> 	lcase(buf.s);
> 
> 	if (!strcmp(buf.s, "subscribed"))
> 	    *opts |= LIST_RET_SUBSCRIBED;
> 	else if (!strcmp(buf.s, "children"))
> 	    *opts |= LIST_RET_CHILDREN;
8736,8737c8920,8922
< 	    prot_printf(imapd_out, "%s BAD Invalid List option %s\r\n",
< 			tag, arg.s);
---
> 	    prot_printf(imapd_out,
> 			"%s BAD Invalid List return option \"%s\"\r\n",
> 			tag, buf.s);
8746c8931
< 		    "%s BAD Missing close parenthesis in List\r\n", tag);
---
> 		    "%s BAD Missing close parenthesis for List return options\r\n", tag);
8750,8752c8935
<     c = prot_getc(imapd_in);
< 
<     return c;
---
>     return prot_getc(imapd_in);
8754c8937
< #endif /* ENABLE_LISTEXT */
---
> #endif /* ENABLE_LIST_EXTENDED */
9138,9142c9321,9333
< /*
<  * Issue a LIST or LSUB untagged response
<  */
< static void mstringdata(char *cmd, char *name, int matchlen, int maycreate,
< 			int listopts)
---
> static int set_haschildren(char *name, int matchlen, int maycreate,
> 			   int *attributes)
> {
>     list_callback_calls++;
>     if (name[matchlen]) {
> 	*attributes |= MBOX_ATTRIBUTE_HASCHILDREN;
> 	return 1;
>     }
>     return 0;
> }
> 
> /* Print LIST or LSUB untagged response */
> static void list_response(char *name, int attributes, int opts)
9144,9150c9335,9337
<     static char lastname[MAX_MAILBOX_PATH+1];
<     static int lastnamedelayed = 0;
<     static int lastnamenoinferiors = 0;
<     static int nonexistent = 0;
<     static int sawuser = 0;
<     int lastnamehassub = 0;
<     int c, mbtype;
---
>     struct mbox_name_attribute *attr;
>     char internal_name[MAX_MAILBOX_PATH+1];
>     int r, mbtype, first = 1;
9153,9195c9340,9348
<     /* We have to reset the sawuser flag before each list command.
<      * Handle it as a dirty hack.
<      */
<     if (cmd == NULL) {
< 	sawuser = 0;
< 	mstringdatacalls = 0;
< 	return;
<     }
<     mstringdatacalls++;
< 
<     if (lastnamedelayed) {
< 	/* Check if lastname has children */
< 	if (name && strncmp(lastname, name, strlen(lastname)) == 0 &&
< 	    name[strlen(lastname)] == '.') {
< 	    lastnamehassub = 1;
< 	}
< 	prot_printf(imapd_out, "* %s (", cmd);
< 	if (nonexistent == IMAP_MAILBOX_RESERVED) {
< 	    /* LISTEXT wants \\PlaceHolder instead of \\Noselect */
< 	    if (listopts & LIST_EXT)
< 		prot_printf(imapd_out, "\\PlaceHolder");
< 	    else
< 		prot_printf(imapd_out, "\\Noselect");
< 	} else if (nonexistent) {
< 	    prot_printf(imapd_out, "\\NonExistent");
< 	}
< 	if (lastnamenoinferiors) {
< 	    prot_printf(imapd_out, "%s\\Noinferiors", nonexistent ? " " : "");
< 	}
< 	else if ((listopts & LIST_CHILDREN) &&
< 		 /* we can't determine \HasNoChildren for subscriptions */
< 		 (lastnamehassub ||
< 		  !(listopts & (LIST_LSUB | LIST_SUBSCRIBED)))) {
< 	    prot_printf(imapd_out, "%s%s", nonexistent ? " " : "",
< 			lastnamehassub ? "\\HasChildren" : "\\HasNoChildren");
< 	}
< 	prot_printf(imapd_out, ") \"%c\" ", imapd_namespace.hier_sep);
< 		    
< 	(*imapd_namespace.mboxname_toexternal)(&imapd_namespace, lastname,
< 					       imapd_userid, mboxname);
< 	printstring(mboxname);
< 	prot_printf(imapd_out, "\r\n");
< 	lastnamedelayed = lastnamenoinferiors = nonexistent = 0;
---
>     if (!name)
> 	return;
> 
>     /* first convert "INBOX" to "user.<userid>" */
>     if (!strncasecmp(name, "inbox", 5)
>             && (!name[5] || name[5] == '.') ) {
> 	(*imapd_namespace.mboxname_tointernal)(&imapd_namespace, "INBOX",
> 					       imapd_userid, internal_name);
> 	strlcat(internal_name, name+5, sizeof(internal_name));
9196a9350,9351
>     else
> 	strlcpy(internal_name, name, sizeof(internal_name));
9198,9201c9353,9409
<     /* Special-case to flush any final state */
<     if (!name) {
< 	lastname[0] = '\0';
< 	return;
---
>     /* get info and set flags */
>     r = mboxlist_detail(internal_name, &mbtype, NULL, NULL, NULL, NULL, NULL);
> 
>     if (r == IMAP_MAILBOX_NONEXISTENT)
> 	attributes |= MBOX_ATTRIBUTE_NONEXISTENT | MBOX_ATTRIBUTE_NOSELECT;
>     if (!r && (mbtype & MBTYPE_RESERVE))
> 	attributes |= MBOX_ATTRIBUTE_NOSELECT;
> 
>     /* figure out \Has(No)Children if necessary */
>     if ( opts & LIST_RET_CHILDREN
> 	    && ! (attributes & MBOX_ATTRIBUTE_HASCHILDREN)
> 	    && ! (attributes & MBOX_ATTRIBUTE_HASNOCHILDREN) ) {
> 	mboxlist_findall(&imapd_namespace, name,
> 			 imapd_userisadmin, imapd_userid, imapd_authstate,
> 			 set_haschildren, &attributes);
> 	if ( ! (attributes & MBOX_ATTRIBUTE_HASCHILDREN) )
> 	    attributes |= MBOX_ATTRIBUTE_HASNOCHILDREN;
>     }
> 
>     if (opts & LIST_OPT_LSUB) {
> 	/* \Noselect has a special second meaning with (R)LSUB */
> 	if ( !(attributes & MBOX_ATTRIBUTE_SUBSCRIBED)
> 		&& attributes & MBOX_ATTRIBUTE_CHILDINFO_SUBSCRIBED)
> 	    attributes |= MBOX_ATTRIBUTE_NOSELECT;
> 	attributes &= ~MBOX_ATTRIBUTE_SUBSCRIBED;
>     }
> 
>     /* remove redundant flags */
>     if (opts & LIST_OPT_EXTENDED) {
> 	if (opts & MBOX_ATTRIBUTE_NOINFERIORS)
> 	    opts &= ~MBOX_ATTRIBUTE_HASCHILDREN;
> 	if (opts & MBOX_ATTRIBUTE_NONEXISTENT)
> 	    opts &= ~MBOX_ATTRIBUTE_NOSELECT;
>     }
> 
>     prot_printf(imapd_out, "* %s (",
> 		(opts & LIST_OPT_LSUB) ? "LSUB" : "LIST");
>     for (attr = mbox_name_attributes; attr->id; attr++)
> 	if (attributes & attr->flag) {
> 	    if (first) first = 0;
> 	    else prot_putc(' ', imapd_out);
> 	    prot_printf(imapd_out, attr->id);
> 	}
>     prot_printf(imapd_out, ") ");
> 
>     prot_printf(imapd_out, "\"%c\" ", imapd_namespace.hier_sep);
>  
>     (*imapd_namespace.mboxname_toexternal)(&imapd_namespace, name,
>             imapd_userid, mboxname);
> 
>     printastring(mboxname);
> 
>     if (opts & LIST_OPT_EXTENDED && attributes & list_childinfo) {
> 	prot_printf(imapd_out, " (CHILDINFO (");
> 	if (attributes & MBOX_ATTRIBUTE_CHILDINFO_SUBSCRIBED)
> 	    prot_printf(imapd_out, "SUBSCRIBED");
> 	prot_printf(imapd_out, "))");
9204,9208c9412,9469
<     /* Suppress any output of a partial match */
<     if ((name[matchlen]
< 	 && strncmp(lastname, name, matchlen) == 0
< 	 && (lastname[matchlen] == '\0' || lastname[matchlen] == '.'))) {
< 	return;
---
>     prot_printf(imapd_out, "\r\n");
> }
> 
> static int set_subscribed(char *name, int matchlen, int maycreate,
> 			  int *attributes)
> {
>     list_callback_calls++;
>     if (!name[matchlen]) 
> 	*attributes |= MBOX_ATTRIBUTE_SUBSCRIBED;
>     return 1;
> }
> 
> /* callback for mboxlist_findall
>  * used when the SUBSCRIBED selection option is NOT given */
> static int list_cb(char *name, int matchlen, int maycreate,
> 		  struct list_rock *rock)
> {
>     int last_len;
>     int last_name_is_ancestor =
> 	rock->last_name
> 	&& matchlen >= (last_len = strlen(rock->last_name))
> 	&& name[last_len] == '.'
> 	&& !memcmp(rock->last_name, name, last_len);
> 
>     list_callback_calls++;
> 
>     if (last_name_is_ancestor)
> 	rock->last_attributes |= MBOX_ATTRIBUTE_HASCHILDREN;
> 
>     if (!name[matchlen]) {
> 	if ( ! (rock->last_attributes & MBOX_ATTRIBUTE_HASCHILDREN) )
> 	    rock->last_attributes |= MBOX_ATTRIBUTE_HASNOCHILDREN;
> 	list_response(rock->last_name, rock->last_attributes, rock->opts);
> 	free(rock->last_name);
> 	rock->last_name = xstrdup(name);
> 	rock->last_attributes = 0;
> 	if (!maycreate)
> 	    rock->last_attributes |= MBOX_ATTRIBUTE_NOINFERIORS;
> 	/* xxx: is there a cheaper way to figure out \Subscribed? */
> 	if (rock->opts & LIST_RET_SUBSCRIBED)
> 	    mboxlist_findsub(&imapd_namespace, name, imapd_userisadmin,
> 			     imapd_userid, imapd_authstate, set_subscribed,
> 			     &rock->last_attributes, 0);
>     } else if (name[matchlen] == '.'
> 	    && ! (rock->opts & LIST_OPT_EXTENDED)
> 	    && rock->trailing_percent) {
> 	/* special case: if the mailbox name argument of a non-extended List
> 	 * command ends with %, we must include matching levels of hierarchy */
> 	if ( ! (rock->last_name
> 		    && !strncmp(rock->last_name, name, matchlen)
> 		    && (rock->last_name[matchlen] == '\0'
> 			|| rock->last_name[matchlen] == '.')) ) {
> 	    list_response(rock->last_name, rock->last_attributes, rock->opts);
> 	    free(rock->last_name);
> 	    rock->last_name = xstrndup(name, matchlen);
> 	    rock->last_attributes = MBOX_ATTRIBUTE_NONEXISTENT
> 		| MBOX_ATTRIBUTE_NOSELECT | MBOX_ATTRIBUTE_HASCHILDREN;
> 	}
9210,9217c9471,9503
< 	
<     /*
<      * We can get a partial match for "user" multiple times with
<      * other matches inbetween.  Handle it as a special case
<      */
<     if (matchlen == 4 && strncasecmp(name, "user", 4) == 0) {
< 	if (sawuser) return;
< 	sawuser = 1;
---
> 
>     return 0;
> }
> 
> /* callback for mboxlist_findsub
>  * used when SUBSCRIBED but not RECURSIVEMATCH is given */
> static int subscribed_cb(char *name, int matchlen, int maycreate,
> 			 struct list_rock *rock)
> {
>     list_callback_calls++;
> 
>     if (!name[matchlen]) {
> 	list_response(rock->last_name, rock->last_attributes, rock->opts);
> 	free(rock->last_name);
> 	rock->last_name = xstrdup(name);
> 	rock->last_attributes = MBOX_ATTRIBUTE_SUBSCRIBED;
> 	if (!maycreate)
> 	    rock->last_attributes |= MBOX_ATTRIBUTE_NOINFERIORS;
>     } else if (name[matchlen] == '.'
> 	    && rock->opts & LIST_OPT_LSUB
> 	    && rock->trailing_percent) {
> 	/* special case: if the mailbox name argument of an Lsub command ends
> 	 * with %, mailbox names that match the pattern but aren't subscribed
> 	 * must also be returned if they have a child mailbox that is
> 	 * subscribed */
> 	name[matchlen] = '\0';
> 	if ( ! (rock->last_name && !strcmp(rock->last_name, name)) ) {
> 	    list_response(rock->last_name, rock->last_attributes, rock->opts);
> 	    free(rock->last_name);
> 	    rock->last_name = xstrdup(name);
> 	    rock->last_attributes = MBOX_ATTRIBUTE_CHILDINFO_SUBSCRIBED;
> 	}
> 	name[matchlen] = '.';
9220,9222c9506,9507
<     strlcpy(lastname, name, sizeof(lastname));
<     lastname[matchlen] = '\0';
<     nonexistent = 0;
---
>     return 0;
> }
9224,9229c9509,9527
<     /* Now we need to see if this mailbox exists */
<     /* first convert "INBOX" to "user.<userid>" */
<     if (!strncasecmp(lastname, "inbox", 5)) {
< 	(*imapd_namespace.mboxname_tointernal)(&imapd_namespace, "INBOX",
< 					       imapd_userid, mboxname);
< 	strlcat(mboxname, lastname+5, sizeof(mboxname));
---
> /*
>  * Takes the "reference name" and "mailbox name" arguments of the LIST command
>  * and returns a "canonical LIST pattern". The caller is responsible for
>  * free()ing the returned string.
>  */
> char *canonical_list_pattern(const char *reference, const char *pattern)
> {
>     int patlen = strlen(pattern);
>     int reflen = strlen(reference);
> 
>     char *buf = xmalloc(patlen + reflen + 1);
>     buf[0] = '\0';
> 
>     if (*reference) {
> 	if (reference[reflen-1] == imapd_namespace.hier_sep &&
> 		pattern[0] == imapd_namespace.hier_sep)
> 	    --reflen;
> 	memcpy(buf, reference, reflen);
> 	buf[reflen] = '\0';
9231,9232c9529
<     else
< 	strlcpy(mboxname, lastname, sizeof(mboxname));
---
>     strcat(buf, pattern);
9234,9238c9531,9532
<     /* Look it up */
<     nonexistent = mboxlist_detail(mboxname, &mbtype,
< 				  NULL, NULL, NULL, NULL, NULL);
<     if(!nonexistent && (mbtype & MBTYPE_RESERVE))
< 	nonexistent = IMAP_MAILBOX_RESERVED;
---
>     return buf;
> }
9240,9243c9534,9557
<     if (!name[matchlen]) {
< 	lastnamedelayed = 1;
< 	if (!maycreate) lastnamenoinferiors = 1;
< 	return;
---
> /*
>  * Turns the strings in patterns into "canonical LIST pattern"s. Also
>  * translates any hierarchy separators.
>  */
> void canonical_list_patterns(char *reference, struct strlist *patterns)
> {
>     static int ignorereference = 0;
>     char *old;
> 
>     /* Ignore the reference argument?
>        (the behavior in 1.5.10 & older) */
>     if (ignorereference == 0)
> 	ignorereference = config_getswitch(IMAPOPT_IGNOREREFERENCE);
> 
>     for (; patterns; patterns = patterns->next) {
> 	if (!ignorereference || patterns->s[0] == imapd_namespace.hier_sep) {
> 	    old = patterns->s;
> 	    patterns->s = canonical_list_pattern(reference, old);
> 	    free(old);
> 	}
> 	/* Translate any separators in pattern */
> 	mboxname_hiersep_tointernal(&imapd_namespace, patterns->s,
> 				    config_virtdomains ?
> 				    strcspn(patterns->s, "@") : 0);
9244a9559
> }
9246,9255c9561,9580
<     c = name[matchlen];
<     if (c) name[matchlen] = '\0';
<     prot_printf(imapd_out, "* %s (", cmd);
<     if (c) {
< 	/* Handle namespace prefix as a special case */ 
< 	if (!strcmp(name, "user") ||
< 	    !strcmp(name, imapd_namespace.prefix[NAMESPACE_SHARED])) {
< 	    prot_printf(imapd_out, "\\Noselect");
< 	    if (listopts & LIST_EXT)
< 		prot_printf(imapd_out, " \\PlaceHolder");
---
> /* callback for mboxlist_findsub
>  * used by list_data_recursivematch */
> static int recursivematch_cb(char *name, int matchlen, int maycreate,
> 			     struct list_rock_recursivematch *rock) {
>     list_callback_calls++;
> 
>     if (name[matchlen]) {
> 	if (name[matchlen] == '.') {
> 	    int *parent_info;
> 	    name[matchlen] = '\0';
> 	    parent_info = hash_lookup(name, &rock->table);
> 	    if (!parent_info) {
> 		parent_info = xzmalloc(sizeof(int));
> 		hash_insert(name, parent_info, &rock->table);
> 		rock->count++;
> 		if (!maycreate)
> 		    *parent_info |= MBOX_ATTRIBUTE_NOINFERIORS;
> 	    }
> 	    *parent_info |= MBOX_ATTRIBUTE_CHILDINFO_SUBSCRIBED;
> 	    name[matchlen] = '.';
9257,9264c9582,9590
< 	else {
< 	    if (nonexistent)
< 		prot_printf(imapd_out, "\\NonExistent");
< 	    /* LISTEXT uses \PlaceHolder instead of \Noselect */
< 	    if (listopts & LIST_EXT)
< 		prot_printf(imapd_out, "%s\\PlaceHolder", nonexistent ? " " : "");
< 	    else
< 		prot_printf(imapd_out, "%s\\Noselect", nonexistent ? " " : "");
---
>     } else {
> 	int *list_info = hash_lookup(name, &rock->table);
> 	if (!list_info) {
> 	    list_info = xzmalloc(sizeof(int));
> 	    hash_insert(name, list_info, &rock->table);
> 	    rock->count++;
> 	    *list_info |= MBOX_ATTRIBUTE_SUBSCRIBED;
> 	    if (!maycreate)
> 		*list_info |= MBOX_ATTRIBUTE_NOINFERIORS;
9266,9267d9591
< 	if (listopts & LIST_CHILDREN)
< 	    prot_printf(imapd_out, " \\HasChildren");
9269d9592
<     prot_printf(imapd_out, ") \"%c\" ", imapd_namespace.hier_sep);
9271,9276c9594,9707
<     (*imapd_namespace.mboxname_toexternal)(&imapd_namespace, name,
< 					   imapd_userid, mboxname);
<     printstring(mboxname);
<     prot_printf(imapd_out, "\r\n");
<     if (c) name[matchlen] = c;
<     return;
---
>     return 0;
> }
> 
> /* callback for hash_enumerate */
> void copy_to_array(char *key, void *data, void *void_rock) {
>     int *attributes = (int *)data;
>     struct list_rock_recursivematch *rock =
> 	(struct list_rock_recursivematch *)void_rock;
>     assert(rock->count > 0);
>     rock->array[--rock->count].name = key;
>     rock->array[rock->count].attributes = *attributes;
> }
> 
> /* Comparator for reverse-sorting an array of struct list_entry by name. */
> int list_entry_comparator(const void *p1, const void *p2) {
>     const struct list_entry *e1 = (struct list_entry *)p1;
>     const struct list_entry *e2 = (struct list_entry *)p2;
>     return - strcmp(e1->name, e2->name);
> }
> 
> static void list_data_recursivematch(struct strlist *patterns, int opts,
> 				     int (*findsub)(struct namespace *,
> 					 const char *, int, char *,
> 					 struct auth_state *, int (*)(),
> 					 void *, int)) {
>     struct strlist *pattern;
>     struct list_rock_recursivematch rock;
> 
>     rock.count = 0;
>     rock.opts = opts;
>     construct_hash_table(&rock.table, 100, 1);
> 
>     /* find */
>     for (pattern = patterns; pattern; pattern = pattern->next)
> 	findsub(&imapd_namespace, pattern->s, imapd_userisadmin, imapd_userid,
> 		imapd_authstate, recursivematch_cb, &rock, 1);
> 
>     if (rock.count) {
> 	/* sort */
> 	int entries = rock.count;
> 	rock.array = xmalloc(entries * (sizeof(struct list_entry)));
> 	hash_enumerate(&rock.table, copy_to_array, &rock);
> 	qsort(rock.array, entries, sizeof(struct list_entry),
> 	      list_entry_comparator);
> 	assert(rock.count == 0);
> 
> 	/* print */
> 	for (entries--; entries >= 0; entries--)
> 	    list_response(rock.array[entries].name,
> 		    rock.array[entries].attributes,
> 		    rock.opts);
> 
> 	free(rock.array);
>     }
> 
>     free_hash_table(&rock.table, free);
> }
> 
> /* Retrieves the data and prints the untagged responses for a LIST command. */
> static void list_data(char *reference, int listopts, struct strlist *patterns)
> {
>     int (*findall)(struct namespace *namespace,
> 		   const char *pattern, int isadmin, char *userid,
> 		   struct auth_state *auth_state, int (*proc)(),
> 		   void *rock);
>     int (*findsub)(struct namespace *namespace,
> 		   const char *pattern, int isadmin, char *userid,
> 		   struct auth_state *auth_state, int (*proc)(),
> 		   void *rock, int force);
>     canonical_list_patterns(reference, patterns);
> 
>     /* Check to see if we should only list the personal namespace */
>     if (!(listopts & LIST_OPT_EXTENDED)
> 	    && !strcmp(patterns->s, "*")
> 	    && config_getswitch(IMAPOPT_FOOLSTUPIDCLIENTS)) {
> 	free(patterns->s);
> 	patterns->s = xstrdup("INBOX*");
> 	findsub = mboxlist_findsub;
> 	findall = mboxlist_findall;
>     } else {
> 	findsub = imapd_namespace.mboxlist_findsub;
> 	findall = imapd_namespace.mboxlist_findall;
>     }
> 
>     if (listopts & LIST_SEL_RECURSIVEMATCH) {
> 	list_data_recursivematch(patterns, listopts, findsub);
>     } else {
> 	struct strlist *pattern;
> 	struct list_rock rock;
> 	rock.opts = listopts;
> 	rock.last_name = NULL;
> 	if (listopts & LIST_SEL_SUBSCRIBED) {
> 	    for (pattern = patterns; pattern; pattern = pattern->next) {
> 		rock.trailing_percent =
> 		    pattern->s[strlen(pattern->s) - 1] == '%';
> 		findsub(&imapd_namespace, pattern->s, imapd_userisadmin,
> 			imapd_userid, imapd_authstate, subscribed_cb, &rock, 1);
> 		list_response(rock.last_name, rock.last_attributes, rock.opts);
> 		free(rock.last_name);
> 		rock.last_name = NULL;
> 	    }
> 	} else {
> 	    rock.opts |= LIST_RET_CHILDREN;
> 	    for (pattern = patterns; pattern; pattern = pattern->next) {
> 		rock.trailing_percent =
> 		    pattern->s[strlen(pattern->s) - 1] == '%';
> 		findall(&imapd_namespace, pattern->s, imapd_userisadmin,
> 			imapd_userid, imapd_authstate, list_cb, &rock);
> 		list_response(rock.last_name, rock.last_attributes, rock.opts);
> 		free(rock.last_name);
> 		rock.last_name = NULL;
> 	    }
> 	}
>     }
9280c9711,9712
<  * Issue a LIST untagged response
---
>  * Retrieves the data and prints the untagged responses for a LIST command in
>  * the case of a remote inbox.
9282c9714,9715
< static int listdata(char *name, int matchlen, int maycreate, void *rock)
---
> static void list_data_remote(char *tag, int listopts, char *reference,
> 			     struct strlist *pattern)
9284,9287c9717,9725
<     int listopts = *((int *)rock);
<     
<     mstringdata(((listopts & LIST_LSUB) ? "LSUB" : "LIST"),
< 	name, matchlen, maycreate, listopts);
---
>     if (listopts & LIST_OPT_EXTENDED
> 	    && !CAPA(backend_inbox, CAPA_LISTEXTENDED)) {
> 	/* client wants to use extended list command but backend doesn't
> 	 * support it */
> 	prot_printf(backend_inbox->out,
> 		    "%s NO Backend server does not support extended list command\r\n",
> 		    tag);
> 	return;
>     }
9289c9727,9782
<     return 0;
---
>     /* print tag, command and list selection options */
>     if (listopts & LIST_OPT_EXTENDED) {
> 	int first = 1;
> 	prot_printf(backend_inbox->out, "%s List (", tag);
> 	if (listopts & LIST_SEL_SUBSCRIBED) {
> 	    prot_printf(backend_inbox->out, "subscribed");
> 	    first = 0;
> 	}
> 	if (listopts & LIST_SEL_REMOTE) {
> 	    prot_printf(backend_inbox->out, " remote"+first);
> 	    first = 0;
> 	}
> 	if (listopts & LIST_SEL_RECURSIVEMATCH)
> 	    prot_printf(backend_inbox->out, " recursivematch"+first);
> 	prot_printf(backend_inbox->out, ") ");
>     } else {
> 	prot_printf(backend_inbox->out, "%s Lsub ", tag);
>     }
> 
>     /* print reference argument */
>     prot_printf(backend_inbox->out,
> 		"{%d+}\r\n%s ", strlen(reference), reference);
> 
>     /* print mailbox pattern(s) */
>     if (pattern->next) {
> 	int first = 1;
> 	prot_putc('(', backend_inbox->out);
> 	for (; pattern; pattern = pattern->next) {
> 	    prot_printf(backend_inbox->out, 
> 			" {%d+}\r\n%s"+first, strlen(pattern->s), pattern->s);
> 	    first = 0;
> 	}
> 	prot_putc(')', backend_inbox->out);
>     } else {
> 	prot_printf(backend_inbox->out, 
> 		    "{%d+}\r\n%s", strlen(pattern->s), pattern->s);
> 	pattern = pattern->next;
>     }
> 
>     /* print list return options */
>     if (listopts & list_ret_opts) {
> 	prot_printf(backend_inbox->out, " return (");
> 	int first = 1;
> 	if (listopts & LIST_RET_SUBSCRIBED) {
> 	    prot_printf(backend_inbox->out, "subscribed");
> 	    first = 0;
> 	}
> 	if (listopts & LIST_RET_CHILDREN) {
> 	    prot_printf(backend_inbox->out, " children"+first);
> 	}
> 	prot_putc(')', backend_inbox->out);
>     }
> 
>     prot_printf(backend_inbox->out, "\r\n");
>     pipe_lsub(backend_inbox, tag, 0,
> 	      (listopts & LIST_OPT_LSUB) ? "LSUB" : "LIST");
diff -r --exclude=.svn ../cyrushead/imap/imapd.h ./imap/imapd.h
228d227
< /* Bitmask for list options */
230,234c229,245
<     LIST_LSUB =			(1<<0),
<     LIST_EXT =			(1<<1),
<     LIST_SUBSCRIBED =		(1<<2),
<     LIST_CHILDREN =		(1<<3),
<     LIST_REMOTE =		(1<<4)
---
>     /* LIST selection options */
>     LIST_SEL_SUBSCRIBED =	(1<<0),
>     LIST_SEL_REMOTE =		(1<<1),
>     LIST_SEL_RECURSIVEMATCH =	(1<<2),
> 
>     /* LIST return options */
>     LIST_RET_SUBSCRIBED =	(1<<8),
>     LIST_RET_CHILDREN =		(1<<9),
> 
>     /* other options */
>     LIST_OPT_RLIST =            (1<<16),
>     LIST_OPT_LSUB =             (1<<17),
>     LIST_OPT_EXTENDED =         (1<<18), /* extended List command */
>     /* ... as specified in draft-ietf-imapext-list-extensions-03.txt */
>     LIST_OPT_EXTENDED_V03 =     (1<<19),
>     /* ... as specified in draft-ietf-imapext-list-extensions-17.txt */
>     LIST_OPT_EXTENDED_V17 =     (1<<20)
235a247,266
> #define list_sel_opts (LIST_RET_SUBSCRIBED - 1)
> #define list_ret_opts ((LIST_OPT_RLIST - 1) & ~list_sel_opts)
> 
> /* Name attributes that may be retuned by LIST */
> enum {
>     /* from RFC 3501 */
>     MBOX_ATTRIBUTE_NOINFERIORS   = (1<<0),
>     MBOX_ATTRIBUTE_NOSELECT      = (1<<1),
>     MBOX_ATTRIBUTE_MARKED        = (1<<2),
>     MBOX_ATTRIBUTE_UNMARKED      = (1<<3),
> 
>     /* from draft-ietf-imapext-list-extensions-17.txt */
>     MBOX_ATTRIBUTE_NONEXISTENT   = (1<<4),
>     MBOX_ATTRIBUTE_SUBSCRIBED    = (1<<5),
>     MBOX_ATTRIBUTE_REMOTE        = (1<<6),
>     MBOX_ATTRIBUTE_HASCHILDREN   = (1<<7),
>     MBOX_ATTRIBUTE_HASNOCHILDREN = (1<<8),
>     MBOX_ATTRIBUTE_CHILDINFO_SUBSCRIBED = (1<<9)
> };
> #define list_childinfo (MBOX_ATTRIBUTE_CHILDINFO_SUBSCRIBED)
diff -r --exclude=.svn ../cyrushead/imap/protocol.c ./imap/protocol.c
117a118
> 	  { " LIST-EXTENDED", CAPA_LISTEXTENDED },
diff -r --exclude=.svn ../cyrushead/imap/protocol.h ./imap/protocol.h
59a60
>     CAPA_LISTEXTENDED   = (1 << 7),
66c67
< #define MAX_CAPA 7
---
> #define MAX_CAPA 8
