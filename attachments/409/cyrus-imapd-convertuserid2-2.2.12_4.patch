diff -urN cyrus-imapd-2.2.12.old/config.h.in cyrus-imapd-2.2.12/config.h.in
--- cyrus-imapd-2.2.12.old/config.h.in	2005-02-14 20:59:41 +0300
+++ cyrus-imapd-2.2.12/config.h.in	2005-12-30 15:13:57 +0300
@@ -64,6 +64,9 @@
 /* Do we have a decent regex library? */
 #undef ENABLE_REGEX
 
+/* Enable converting userids via LDAP support? */
+#undef ENABLE_CONVERT_USERID
+
 /* Enable Netscape Menu Option Hack? */
 #undef ENABLE_X_NETSCAPE_HACK
 
diff -urN cyrus-imapd-2.2.12.old/configure cyrus-imapd-2.2.12/configure
--- cyrus-imapd-2.2.12.old/configure	2005-02-14 20:59:46 +0300
+++ cyrus-imapd-2.2.12/configure	2005-12-30 15:13:57 +0300
@@ -852,6 +852,7 @@
   --enable-cmulocal       enable CMU-specific local support
   --enable-oldsievename   enable the use of 'imap' as the sieve service name
   --enable-listext        enable IMAP List extensions
+  --enable-convertuserid  enable converting userids via LDAP support
   --enable-netscapehack   enable Netscape hack for the menu option
                           in Communicator to Administrate Mail
   --enable-gssapi=<DIR>   enable GSSAPI authentication yes
@@ -11180,6 +11181,18 @@
 	fi
 fi;
 
+# Check whether --enable-convertuserid or --disable-convertuserid was given.
+if test "${enable_convertuserid+set}" = set; then
+  enableval="$enable_convertuserid"
+  if test "$enableval" = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_CONVERT_USERID
+_ACEOF
+	IMAP_PROGS="$IMAP_PROGS ldapd"
+	fi
+fi;
+
 # Check whether --enable-netscapehack or --disable-netscapehack was given.
 if test "${enable_netscapehack+set}" = set; then
   enableval="$enable_netscapehack"
diff -urN cyrus-imapd-2.2.12.old/configure.in cyrus-imapd-2.2.12/configure.in
--- cyrus-imapd-2.2.12.old/configure.in	2005-01-19 02:46:00 +0300
+++ cyrus-imapd-2.2.12/configure.in	2005-12-30 15:13:58 +0300
@@ -917,6 +917,13 @@
 		AC_DEFINE(ENABLE_LISTEXT,[],[Enable the LISTEXT extension?])
 	fi)
 
+AC_ARG_ENABLE(convertuserid,
+	[  --enable-convertuserid  enable converting userids via LDAP support],
+	if test "$enableval" = yes; then
+		AC_DEFINE(ENABLE_CONVERT_USERID,[],[Enable converting userids via LDAP support?])
+		IMAP_PROGS="$IMAP_PROGS ldapd"
+	fi)
+
 AC_ARG_ENABLE(netscapehack,
 	[  --enable-netscapehack   enable Netscape hack for the menu option
                           in Communicator to Administrate Mail],
diff -urN cyrus-imapd-2.2.12.old/imap/charset_convert.c cyrus-imapd-2.2.12/imap/charset_convert.c
--- cyrus-imapd-2.2.12.old/imap/charset_convert.c	1970-01-01 03:00:00 +0300
+++ cyrus-imapd-2.2.12/imap/charset_convert.c	2005-12-30 15:14:31 +0300
@@ -0,0 +1,545 @@
+/* This file was taken from PHP 5 and was modified by
+   Alexander Drozdov <dzal_mail@mtu-net.ru> */
+#include <stdlib.h>
+
+#include "charset_convert.h"
+
+#define UCS4MAX 0x70000000U
+
+#define UCS2MAX 0x00010000U
+#define SUPMIN  0x00010000U
+#define SUPMAX  0x00200000U
+
+#define MASK    0xffffffU
+#define THROUGH 0x78000000U              /* 000000h - FFFFFFh */
+
+typedef unsigned int uint;
+
+typedef struct _convert_state {
+    int cache;
+    int status;
+} convert_state;
+
+typedef int (*converted_out_cb_t)(uint c, void *);
+typedef int (*convert_cb_t)(uint c, convert_state *, converted_out_cb_t, void *);
+typedef int (*flush_cb_t)(convert_state *, converted_out_cb_t, void *);
+
+#define CK(statement)	do { if ((statement)) return (-1); } while (0)
+
+static int utf8_encode(uint c, convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+{
+    /* skip wrong symbols */
+    if (c > UCS4MAX)
+	return 0;
+    
+    if (c < 0x80) {
+	CK(out_cb(c, out_cb_param));
+    } else if (c < 0x800) {
+	CK(out_cb(((c >> 6) & 0x1f) | 0xc0, out_cb_param));
+	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+    } else if (c < 0x10000) {
+	CK(out_cb(((c >> 12) & 0x0f) | 0xe0, out_cb_param));
+	CK(out_cb(((c >> 6) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+    } else if (c < 0x200000) {
+	CK(out_cb(((c >> 18) & 0x07) | 0xf0, out_cb_param));
+	CK(out_cb(((c >> 12) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb(((c >> 6) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+    } else if (c < 0x4000000) {
+	CK(out_cb(((c >> 24) & 0x03) | 0xf8, out_cb_param));
+	CK(out_cb(((c >> 18) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb(((c >> 12) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb(((c >> 6) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+    } else {
+	CK(out_cb(((c >> 30) & 0x01) | 0xfc, out_cb_param));
+	CK(out_cb(((c >> 24) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb(((c >> 18) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb(((c >> 12) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb(((c >> 6) & 0x3f) | 0x80, out_cb_param));
+	CK(out_cb((c & 0x3f) | 0x80, out_cb_param));
+    }
+
+    return 0;
+}
+
+static int utf8_decode(uint c, convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+{
+    if (c < 0x80) {
+	CK(out_cb(c, out_cb_param));
+	filter->status = 0;
+    } else if (c < 0xc0) {
+	uint s;
+
+	switch (filter->status & 0xff) {
+	case 0x10: /* 2byte code 2nd char */
+	case 0x21: /* 3byte code 3rd char */
+	case 0x32: /* 4byte code 4th char */
+	case 0x43: /* 5byte code 5th char */
+	case 0x54: /* 6byte code 6th char */
+	    filter->status = 0;
+	    s = filter->cache | (c & 0x3f);
+	    if (s >= 0x80)
+		CK(out_cb(s, out_cb_param));
+	    break;
+	case 0x20: /* 3byte code 2nd char */
+	case 0x31: /* 4byte code 3rd char */
+	case 0x42: /* 5byte code 4th char */
+	case 0x53: /* 6byte code 5th char */
+	    filter->cache |= ((c & 0x3f) << 6);
+	    filter->status++;
+	    break;
+	case 0x30: /* 4byte code 2nd char */
+	case 0x41: /* 5byte code 3rd char */
+	case 0x52: /* 6byte code 4th char */
+	    filter->cache |= ((c & 0x3f) << 12);
+	    filter->status++;
+	    break;
+	case 0x40: /* 5byte code 2nd char */
+	case 0x51: /* 6byte code 3rd char */
+	    filter->cache |= ((c & 0x3f) << 18);
+	    filter->status++;
+	    break;
+	case 0x50: /* 6byte code 2nd char */
+	    filter->cache |= ((c & 0x3f) << 24);
+	    filter->status++;
+	    break;
+	default:
+	    filter->status = 0;
+	    break;
+	}
+    } else if (c < 0xe0) { /* 2byte code first char */
+	filter->status = 0x10;
+	filter->cache = (c & 0x1f) << 6;
+    } else if (c < 0xf0) { /* 3byte code first char */
+	filter->status = 0x20;
+	filter->cache = (c & 0xf) << 12;
+    } else if (c < 0xf8) { /* 4byte code first char */
+	filter->status = 0x30;
+	filter->cache = (c & 0x7) << 18;
+    } else if (c < 0xfc) { /* 5byte code first char */
+	filter->status = 0x40;
+	filter->cache = (c & 0x3) << 24;
+    } else if (c < 0xfe)  { /* 6 byte code first char */
+	filter->status = 0x50;
+	filter->cache = (c & 0x1) << 30;
+    } else {
+	filter->status = 0;
+	filter->cache = 0;
+    }
+
+    return 0;
+}
+
+static const unsigned char utf7imap_base64_table[] =
+{
+ /* 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', */
+   0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,
+ /* 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', */
+   0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,
+ /* 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', */
+   0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,
+ /* 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', */
+   0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
+ /* '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', ',', '\0' */
+   0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x2b,0x2c,0x00
+};
+
+static int mutf7_encode(uint c, convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+{
+    int n, s;
+
+    n = 0;
+    if (c == 0x26) {
+	n = 1;
+    } else if ((c >= 0x20 && c <= 0x7e) || c == 0) {
+	n = 2;
+    } else if (c >= 0 && c < UCS2MAX) {
+	;
+    } else if (c >= SUPMIN && c < SUPMAX) {
+	s = ((c >> 10) - 0x40) | 0xd800;
+	CK(out_cb(s, out_cb_param));
+	s = (c & 0x3ff) | 0xdc00;
+	CK(out_cb(s, out_cb_param));
+	return 0;
+    } else {
+	return -1;
+    }
+
+    switch (filter->status) {
+    case 0:
+	if (n != 0) {	/* directly encode characters */
+	    CK(out_cb(c, out_cb_param));
+	    if (n == 1) {
+		CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	    }
+	} else {	/* Modified Base64 */
+	    CK(out_cb(0x26, out_cb_param));		/* '&' */
+	    filter->status = 1;
+	    filter->cache = c;
+	}
+	break;
+
+	/* encode Modified Base64 */
+    case 1:
+	s = filter->cache;
+	CK(out_cb(utf7imap_base64_table[(s >> 10) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(s >> 4) & 0x3f], out_cb_param));
+	if (n != 0) {
+	    CK(out_cb(utf7imap_base64_table[(s << 2) & 0x3c], out_cb_param));
+	    CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	    CK(out_cb(c, out_cb_param));
+	    if (n == 1) {
+		CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	    }
+	    filter->status = 0;
+	} else {
+	    filter->status = 2;
+	    filter->cache = ((s & 0xf) << 16) | c;
+	}
+	break;
+
+    case 2:
+	s = filter->cache;
+	CK(out_cb(utf7imap_base64_table[(s >> 14) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(s >> 8) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(s >> 2) & 0x3f], out_cb_param));
+	if (n != 0) {
+	    CK(out_cb(utf7imap_base64_table[(s << 4) & 0x30], out_cb_param));
+	    CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	    CK(out_cb(c, out_cb_param));
+	    if (n == 1) {
+		CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	    }
+	    filter->status = 0;
+	} else {
+	    filter->status = 3;
+	    filter->cache = ((s & 0x3) << 16) | c;
+	}
+	break;
+
+    case 3:
+	s = filter->cache;
+	CK(out_cb(utf7imap_base64_table[(s >> 12) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(s >> 6) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[s & 0x3f], out_cb_param));
+	if (n != 0) {
+	    CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	    CK(out_cb(c, out_cb_param));
+	    if (n == 1) {
+		CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	    }
+	    filter->status = 0;
+	} else {
+	    filter->status = 1;
+	    filter->cache = c;
+	}
+	break;
+
+    default:
+	filter->status = 0;
+	break;
+    }
+
+    return 0;
+}
+
+static int mutf7_decode(uint c, convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+{
+    int s, n;
+
+    n = -1;
+    if (filter->status != 0) {		/* Modified Base64 */
+	if (c >= 0x41 && c <= 0x5a) {		/* A - Z */
+	    n = c - 65;
+	} else if (c >= 0x61 && c <= 0x7a) {	/* a - z */
+	    n = c - 71;
+	} else if (c >= 0x30 && c <= 0x39) {	/* 0 - 9 */
+	    n = c + 4;
+	} else if (c == 0x2b) {			/* '+' */
+	    n = 62;
+	} else if (c == 0x2c) {			/* ',' */
+	    n = 63;
+	}
+	if (n < 0 || n > 63) {
+	    if (c == 0x2d) {
+		if (filter->status == 1) {		/* "&-" -> "&" */
+		    CK(out_cb(0x26, out_cb_param));
+		}
+	    } else if (c >= 0 && c < 0x80) {	/* ASCII exclude '-' */
+		CK(out_cb(c, out_cb_param));
+	    } else {		/* illegal character */
+		s = c & MASK;
+		s |= THROUGH;
+		CK(out_cb(s, out_cb_param));
+	    }
+	    filter->cache = 0;
+	    filter->status = 0;
+	    return 0;
+	}
+    }
+
+    switch (filter->status) {
+	/* directly encoded characters */
+    case 0:
+	if (c == 0x26) {	/* '&'  shift character */
+	    filter->status++;
+	} else if (c >= 0 && c < 0x80) {	/* ASCII */
+	    CK(out_cb(c, out_cb_param));
+	} else {		/* illegal character */
+	    s = c & MASK;
+	    s |= THROUGH;
+	    CK(out_cb(s, out_cb_param));
+	}
+	break;
+
+	/* decode Modified Base64 */
+    case 1:
+    case 2:
+	filter->cache |= n << 10;
+	filter->status = 3;
+	break;
+    case 3:
+	filter->cache |= n << 4;
+	filter->status = 4;
+	break;
+    case 4:
+	s = ((n >> 2) & 0xf) | (filter->cache & 0xffff);
+	n = (n & 0x3) << 14;
+	filter->status = 5;
+	if (s >= 0xd800 && s < 0xdc00) {
+	    s = (((s & 0x3ff) << 16) + 0x400000) | n;
+	    filter->cache = s;
+	} else if (s >= 0xdc00 && s < 0xe000) {
+	    s &= 0x3ff;
+	    s |= (filter->cache & 0xfff0000) >> 6;
+	    filter->cache = n;
+	    if (s >= SUPMIN && s < SUPMAX) {
+		CK(out_cb(s, out_cb_param));
+	    } else {		/* illegal character */
+		s &= MASK;
+		s |= THROUGH;
+		CK(out_cb(s, out_cb_param));
+	    }
+	} else {
+	    filter->cache = n;
+	    CK(out_cb(s, out_cb_param));
+	}
+	break;
+
+    case 5:
+	filter->cache |= n << 8;
+	filter->status = 6;
+	break;
+    case 6:
+	filter->cache |= n << 2;
+	filter->status = 7;
+	break;
+    case 7:
+	s = ((n >> 4) & 0x3) | (filter->cache & 0xffff);
+	n = (n & 0xf) << 12;
+	filter->status = 8;
+	if (s >= 0xd800 && s < 0xdc00) {
+	    s = (((s & 0x3ff) << 16) + 0x400000) | n;
+	    filter->cache = s;
+	} else if (s >= 0xdc00 && s < 0xe000) {
+	    s &= 0x3ff;
+	    s |= (filter->cache & 0xfff0000) >> 6;
+	    filter->cache = n;
+	    if (s >= SUPMIN && s < SUPMAX) {
+		CK(out_cb(s, out_cb_param));
+	    } else {		/* illegal character */
+		s &= MASK;
+		s |= THROUGH;
+		CK(out_cb(s, out_cb_param));
+	    }
+	} else {
+	    filter->cache = n;
+	    CK(out_cb(s, out_cb_param));
+	}
+	break;
+
+    case 8:
+	filter->cache |= n << 6;
+	filter->status = 9;
+	break;
+    case 9:
+	s = n | (filter->cache & 0xffff);
+	filter->status = 2;
+	if (s >= 0xd800 && s < 0xdc00) {
+	    s = (((s & 0x3ff) << 16) + 0x400000);
+	    filter->cache = s;
+	} else if (s >= 0xdc00 && s < 0xe000) {
+	    s &= 0x3ff;
+	    s |= (filter->cache & 0xfff0000) >> 6;
+	    filter->cache = 0;
+	    if (s >= SUPMIN && s < SUPMAX) {
+		CK(out_cb(s, out_cb_param));
+	    } else {		/* illegal character */
+		s &= MASK;
+		s |= THROUGH;
+		CK(out_cb(s, out_cb_param));
+	    }
+	} else {
+	    filter->cache = 0;
+	    CK(out_cb(s, out_cb_param));
+	}
+	break;
+
+    default:
+	filter->status = 0;
+	break;
+    }
+
+    return 0;
+}
+static int mutf7_encode_flush(convert_state *filter, converted_out_cb_t out_cb, void *out_cb_param)
+{
+    int status, cache;
+
+    status = filter->status;
+    cache = filter->cache;
+    filter->status = 0;
+    filter->cache = 0;
+    /* flush fragments */
+    switch (status) {
+    case 1:
+	CK(out_cb(utf7imap_base64_table[(cache >> 10) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(cache >> 4) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(cache << 2) & 0x3c], out_cb_param));
+	CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	break;
+
+    case 2:
+	CK(out_cb(utf7imap_base64_table[(cache >> 14) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(cache >> 8) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(cache >> 2) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(cache << 4) & 0x30], out_cb_param));
+	CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	break;
+
+    case 3:
+	CK(out_cb(utf7imap_base64_table[(cache >> 12) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[(cache >> 6) & 0x3f], out_cb_param));
+	CK(out_cb(utf7imap_base64_table[cache & 0x3f], out_cb_param));
+	CK(out_cb(0x2d, out_cb_param));		/* '-' */
+	break;
+    }
+    return 0;
+}
+
+typedef struct _convert_opts {
+    convert_cb_t encode_cb;
+    convert_cb_t decode_cb;
+    flush_cb_t flush_encode;
+    flush_cb_t flush_decode;
+} convert_opts;
+
+typedef struct _param_convert {
+    int len;
+    char *out;
+    convert_opts *opts;
+    convert_state filter;
+} param_convert;
+
+/* just a counter */
+static int count_len_cb(uint c, void *param)
+{
+    (*(int *)param)++;
+    return 0;
+}
+
+static int write_out_cb(uint c, void *param)
+{
+    param_convert *r_param=(param_convert *)param;
+
+    r_param->out[r_param->len]=(char)c;
+    r_param->len++;
+    return 0;
+}
+
+/* 'c' is wchar. we need to call encode_cb function to calculate the
+   output buffer size */
+static int get_len_cb(uint c, void *param)
+{
+    return ((param_convert *)param)->opts->encode_cb(c, &((param_convert *)param)->filter, count_len_cb, (void *)&((param_convert *)param)->len);
+}
+
+static int real_out_cb(uint c, void *param)
+{
+    return ((param_convert *)param)->opts->encode_cb(c, &((param_convert *)param)->filter, write_out_cb, param);
+}
+
+static char *do_conversion(convert_opts *opts, char *in, int inlen, int *outlen)
+{
+    param_convert param;
+    convert_state filter;
+    int i;
+
+    param.len = 0;
+    param.opts = opts;
+    bzero(&param.filter, sizeof(param.filter));
+    bzero(&filter, sizeof(filter));
+
+    for(i=0; i<inlen; i++)
+	if(opts->decode_cb((uint)(unsigned char)in[i], &filter, get_len_cb, (void *)&param))
+	    return NULL;
+
+    if(opts->flush_decode)
+	if(opts->flush_decode(&filter, get_len_cb, (void *)&param))
+	    return NULL;
+    if(opts->flush_encode)
+	if(opts->flush_encode(&param.filter, count_len_cb, (void *)&param.len))
+	    return NULL;
+
+    if(!(param.out=(char *)malloc(param.len)))
+	return NULL;
+    param.len=0;
+    bzero(&param.filter, sizeof(param.filter));
+    bzero(&filter, sizeof(filter));
+    
+    for(i=0; i<inlen; i++)
+	if(opts->decode_cb((uint)(unsigned char)in[i], &filter, real_out_cb, (void *)&param)) {
+	    free(param.out);
+	    return NULL;
+	}
+
+    if(opts->flush_decode)
+	if(opts->flush_decode(&filter, real_out_cb, (void *)&param)) {
+	    free(param.out);
+	    return NULL;
+	}
+    if(opts->flush_encode)
+	if(opts->flush_encode(&param.filter, write_out_cb, (void *)&param.len)) {
+	    free(param.out);
+	    return NULL;
+	}
+
+    *outlen = param.len;
+    return param.out;
+}
+
+extern char *utf8_to_mutf7(char *in, int inlen, int *outlen)
+{
+    convert_opts opts;
+
+    opts.encode_cb = mutf7_encode;
+    opts.decode_cb = utf8_decode;
+    opts.flush_encode = mutf7_encode_flush;
+    opts.flush_decode = NULL;
+
+    return do_conversion(&opts, in, inlen, outlen);
+}
+
+extern char *mutf7_to_utf8(char *in, int inlen, int *outlen)
+{
+    convert_opts opts;
+
+    opts.encode_cb = utf8_encode;
+    opts.decode_cb = mutf7_decode;
+    opts.flush_encode = NULL;
+    opts.flush_decode = NULL;
+
+    return do_conversion(&opts, in, inlen, outlen);
+}
diff -urN cyrus-imapd-2.2.12.old/imap/charset_convert.h cyrus-imapd-2.2.12/imap/charset_convert.h
--- cyrus-imapd-2.2.12.old/imap/charset_convert.h	1970-01-01 03:00:00 +0300
+++ cyrus-imapd-2.2.12/imap/charset_convert.h	2005-12-30 15:14:31 +0300
@@ -0,0 +1,7 @@
+#ifndef _CHARSET_CONVERT_H
+#define _CHARSET_CONVERT_H
+
+extern char *utf8_to_mutf7(char *in, int inlen, int *outlen);
+extern char *mutf7_to_utf8(char *in, int inlen, int *outlen);
+
+#endif /* _CHARSET_CONVERT_H */
diff -urN cyrus-imapd-2.2.12.old/imap/global.c cyrus-imapd-2.2.12/imap/global.c
--- cyrus-imapd-2.2.12.old/imap/global.c	2004-11-23 20:40:15 +0300
+++ cyrus-imapd-2.2.12/imap/global.c	2005-12-30 15:13:58 +0300
@@ -92,6 +92,9 @@
 #ifdef WITH_PTS
 struct cyrusdb_backend *config_ptscache_db;
 #endif
+#ifdef ENABLE_CONVERT_USERID
+struct cyrusdb_backend *config_convertuserid_cache_db;
+#endif
 
 /* Called before a cyrus application starts (but after command line parameters
  * are read) */
@@ -183,6 +186,11 @@
 	config_ptscache_db =
 	    cyrusdb_fromname(config_getstring(IMAPOPT_PTSCACHE_DB));
 #endif
+#ifdef ENABLE_CONVERT_USERID
+	config_convertuserid_cache_db =
+	    (p = (char *)config_getstring(IMAPOPT_CONVERTUSERID_CACHE_DB))?
+	    cyrusdb_fromname(p) : NULL;
+#endif
 
 	/* configure libcyrus as needed */
 	libcyrus_config_setstring(CYRUSOPT_CONFIG_DIR, config_dir);
diff -urN cyrus-imapd-2.2.12.old/imap/imapd.c cyrus-imapd-2.2.12/imap/imapd.c
--- cyrus-imapd-2.2.12.old/imap/imapd.c	2005-12-30 12:56:24 +0300
+++ cyrus-imapd-2.2.12/imap/imapd.c	2005-12-30 15:13:58 +0300
@@ -80,6 +80,9 @@
 #include "mailbox.h"
 #include "message.h"
 #include "mboxname.h"
+#ifdef ENABLE_CONVERT_USERID
+#include "ldapd.h"
+#endif
 #include "mboxlist.h"
 #include "mbdump.h"
 #include "mkgmtime.h"
@@ -477,6 +480,11 @@
     }
 #endif
 
+#ifdef ENABLE_CONVERT_USERID
+    if(imapd_convertuserid)
+	mboxname_cleanup();
+#endif /* ENABLE_CONVERT_USERID */
+
     cyrus_reset_stdio(); 
 
     strcpy(imapd_clienthost, "[local]");
@@ -553,6 +561,11 @@
 				   1, '.', -1))
 	fatal("cannot initialize the internal namespace", EC_TEMPFAIL);
 
+#ifdef ENABLE_CONVERT_USERID
+    if(convertuserid_init())
+       fatal("convertuserid_init() failed", EC_CONFIG);
+#endif /* ENABLE_CONVERT_USERID */
+
     /* open the mboxlist, we'll need it for real work */
     mboxlist_init(0);
     mboxlist_open(NULL);
@@ -624,6 +637,11 @@
     imapd_in = prot_new(0, 0);
     imapd_out = prot_new(1, 1);
 
+#ifdef ENABLE_CONVERT_USERID
+    if(convertuserid_config_reread())
+	fatal("Can't reread configuration files", EC_CONFIG);
+#endif
+
     /* Find out name of client host */
     salen = sizeof(imapd_remoteaddr);
     if (getpeername(0, (struct sockaddr *)&imapd_remoteaddr, &salen) == 0 &&
@@ -708,6 +726,9 @@
 /* Called by service API to shut down the service */
 void service_abort(int error)
 {
+#ifdef ENABLE_CONVERT_USERID
+    convertuserid_cleanup();
+#endif /* ENABLE_CONVERT_USERID */
     shut_down(error);
 }
 
@@ -1699,6 +1720,52 @@
     }
 }
 
+static void imapd_loggeduser_init()
+{
+#ifdef ENABLE_CONVERT_USERID
+    char *exempts;
+
+    if(!imapd_namespace.isalt)
+	return;
+    
+    imapd_convertuserid = config_getswitch(IMAPOPT_CONVERTUSERID);
+    exempts = (char *)config_getstring(IMAPOPT_CONVERTUSERID_EXEMPTS);
+
+    if(exempts) {
+	/* look for userid inside 'exempts' string */
+	char *p=exempts;
+	char *n;
+	int userid_len=strlen(imapd_userid);
+
+	do {
+	    for(; *p==' '; p++);
+	    if(*p) {
+		int res;
+		int c_len;
+
+		n=strchr(p, ' ');
+		
+		c_len = n ? (n-p): strlen(p);
+
+		if(c_len==userid_len && !memcmp(imapd_userid, p, userid_len)) {
+		    /* userid has been found! switch convertuserid
+		       option */
+		    imapd_convertuserid = !imapd_convertuserid;
+		    break;
+		}
+
+		p=n;
+	    }
+	} while(p);
+    }
+    if(imapd_convertuserid) {
+	imapd_nonconverteduserid_allowed = config_getswitch(IMAPOPT_CONVERTUSERID_ALLOW_NONCONVERTED);
+	imapd_dontignore_convertuserid_errors = config_getswitch(IMAPOPT_CONVERTUSERID_DONTIGNORE_ERRORS);
+	imapd_convertuserid_actual_timeout = config_getint(IMAPOPT_CONVERTUSERID_ACTUAL_TIMEOUT);
+    }
+#endif
+}
+
 static void userid_tointernal(struct namespace *namespace, char *userid)
 {
     char hiersep_orig = namespace->hier_sep;
@@ -1898,6 +1965,7 @@
 
     /* Translate any separators in userid */
     userid_tointernal(&imapd_namespace, imapd_userid);
+    imapd_loggeduser_init();
 
     freebuf(&passwdbuf);
 
@@ -2045,6 +2113,7 @@
 
     /* Translate any separators in userid */
     userid_tointernal(&imapd_namespace, imapd_userid);
+    imapd_loggeduser_init();
 
     autocreate_inbox();
 
diff -urN cyrus-imapd-2.2.12.old/imap/ldapd.c cyrus-imapd-2.2.12/imap/ldapd.c
--- cyrus-imapd-2.2.12.old/imap/ldapd.c	1970-01-01 03:00:00 +0300
+++ cyrus-imapd-2.2.12/imap/ldapd.c	2005-12-30 15:19:05 +0300
@@ -0,0 +1,468 @@
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/un.h>
+#include <syslog.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#define _GNU_SOURCE
+#include <getopt.h>
+#include <assert.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <lber.h>
+#include <ldap.h>
+
+#include "ldapd.h"
+#include "global.h"
+#include "charset_convert.h"
+#include "exitcodes.h"
+
+/* global state */
+const int config_need_data = 0;
+
+static LDAP *ldap_session=NULL;
+
+#define LDAP_FILTER_TEMPLATE "(%s=%%.*s)"
+#define LDAP_FILTER_TEMPLATESIZE (sizeof(LDAP_FILTER_TEMPLATE)/sizeof(char))
+
+#define LDAP_DOMAINFILTER_TEMPLATE "(%s=%%.*s,%s=%%.*s)"
+#define LDAP_DOMAINFILTER_TEMPLATESIZE (sizeof(LDAP_DOMAINFILTER_TEMPLATE)/sizeof(char))
+
+/* options which was read from configuration files */
+static const char *ldap_host;
+static const char *ldapd_localhost;
+static int ldap_port;
+static const char *ldap_user;
+static const char *ldap_password;
+static const char *ldap_base;
+static const char *ldap_attr_int;
+static const char *ldap_attr_ext;
+static const char *ldap_attr_domain;
+static char *ldap_filter_int;
+static char *ldap_filter_ext;
+static int ldap_filter_int_len;
+static int ldap_filter_ext_len;
+static int ldap_query_domains;
+
+static int n_listeners=0;
+
+void fatal(const char *msg, int err)
+{
+    syslog(LOG_CRIT, "%s", msg);
+    syslog(LOG_NOTICE, "exiting");
+
+    cyrus_done();
+    
+    exit(err);
+}
+
+static void ldap_cleanup()
+{
+    if(ldap_session) {
+	ldap_unbind_s(ldap_session);
+	ldap_session=NULL;
+    }
+}
+
+static int ldap_init_if_needed()
+{
+    if(!ldap_session) {
+	if(!(ldap_session = ldap_init(ldap_host, ldap_port)) ||
+	   ldap_set_option(ldap_session, LDAP_OPT_RESTART, LDAP_OPT_ON)==-1 ||
+	   ldap_simple_bind_s(ldap_session, ldap_user, ldap_password)!=LDAP_SUCCESS) {
+	    ldap_cleanup();
+	    return CONVERTUSERID_LDAPFAILED;
+	}
+    }
+    return 0;
+}
+
+#define FREE_LDAP_RESULT(vals, ldap_res) \
+do { \
+if(vals) \
+    ldap_value_free(vals); \
+ldap_msgfree(ldap_res); \
+} while(0);
+
+static int get_id_from_ldap(const char *in, int in_len, const char *domain, int domainlen, char *out, int *out_len, int int2ext)
+{
+    LDAPMessage *ldap_res;
+    char *in_ldap;
+    int in_ldap_len;
+    const char *ldap_filter_template;
+    int ldap_filter_template_len;
+    char *ldap_filter;
+    char *ldap_attrs[2];
+
+    /* Input buffer 'in' is MUTF-7 string in case if
+       external=>internal. We need to convert it to UTF-8 encoding
+       before querying to LDAP. */
+    if(!int2ext) {
+	char *in_test;
+	int in_test_len;
+
+	if(!(in_ldap = mutf7_to_utf8((char *)in, in_len, &in_ldap_len))) {
+	    syslog(LOG_DEBUG, "mutf7_to_utf8() failed.\n");
+	    return CONVERTUSERID_SYSFAILED;
+	}
+
+	/* Check if 'in' is a valid imap-utf-7 string. Note that we
+	   also disallow here to have multiple mutf-7 representations
+	   of a Unicode string. */
+	if(!(in_test = utf8_to_mutf7(in_ldap, in_ldap_len, &in_test_len))) {
+	    syslog(LOG_DEBUG, "utf8_to_mutf7() failed while checking user unput.\n");
+	    free(in_ldap);
+	    return CONVERTUSERID_SYSFAILED;
+	}
+
+	if(in_test_len!=in_len || memcmp(in, in_test, in_len)) {
+	    syslog(LOG_DEBUG, "Incorrect MUTF-7 string received.\n");
+	    free(in_ldap);
+	    free(in_test);
+	    return CONVERTUSERID_SYSFAILED;
+	}
+	free(in_test);
+
+	ldap_filter_template = ldap_filter_ext;
+	ldap_filter_template_len = ldap_filter_ext_len;
+	ldap_attrs[0] = (char *)ldap_attr_int;
+    }
+    else {
+	in_ldap = (char *)in;
+	in_ldap_len = in_len;
+	ldap_filter_template = ldap_filter_int;
+	ldap_filter_template_len = ldap_filter_int_len;
+	ldap_attrs[0] = (char *)ldap_attr_ext;
+    }
+
+    ldap_attrs[1]=NULL;
+
+    /* if the connection to LDAP server is not established then try to
+       establish it */
+    if(ldap_init_if_needed()) {
+	syslog(LOG_DEBUG, "Cannot initialize LDAP client library!\n");
+	return CONVERTUSERID_LDAPFAILED;
+    }
+
+    /* the allocated buffer is bigger than needed: template have
+       "%.*s" strings within it which are replaced to in_ldap and
+       domain strings */
+    ldap_filter = (char *)malloc(ldap_filter_template_len+in_ldap_len);
+    if(!ldap_filter) {
+	if(in_ldap != in)
+	    free(in_ldap);
+	return CONVERTUSERID_SYSFAILED;
+    }
+
+    /* if we aren't using domains in LDAP queries then the last two
+       arguments won't be used by the sprintf function */
+    sprintf(ldap_filter, ldap_filter_template, in_ldap_len, in_ldap, domainlen, domain);
+
+    if(ldap_search_s(ldap_session, ldap_base, LDAP_SCOPE_SUBTREE, ldap_filter, ldap_attrs, 0, &ldap_res)!=LDAP_SUCCESS) {
+	syslog(LOG_DEBUG, "ldap_search_s() failed! Will try to reconnect.\n");
+	ldap_cleanup();
+
+	if(ldap_init_if_needed())
+	    syslog(LOG_DEBUG, "Reconnect failed!\n");
+	else if(ldap_search_s(ldap_session, ldap_base, LDAP_SCOPE_SUBTREE, ldap_filter, ldap_attrs, 0, &ldap_res)!=LDAP_SUCCESS) {
+	    syslog(LOG_DEBUG, "ldap_search_s() failed again!\n");
+	    ldap_cleanup();
+	}
+    }
+
+    if(in_ldap != in)
+	free(in_ldap);
+    free(ldap_filter);
+
+    /* if query failed then return error */
+    if(!ldap_session)
+	return CONVERTUSERID_LDAPFAILED;
+    else {
+	char **vals=NULL;
+	char *nonencoded_out;
+	int nonencoded_len;
+	int count_entries;
+
+	if(!ldap_res) {
+	    syslog(LOG_DEBUG, "ldap_res is NULL!");
+	    return CONVERTUSERID_SYSFAILED;
+	}
+
+	/* the external name hasn't been found or there are more than
+	   one result records */
+	if((count_entries=ldap_count_entries(ldap_session, ldap_res))!=1) {
+	    if(count_entries)
+		syslog(LOG_DEBUG, "ldap_count_entries() returned %i.\n", count_entries);
+
+	    FREE_LDAP_RESULT(vals, ldap_res);
+	    return CONVERTUSERID_NONEXISTENT_ID;
+	}
+	else {
+	    LDAPMessage *entry;
+	    char *attr;
+
+	    entry = ldap_first_entry(ldap_session, ldap_res);
+	    if(!entry) {
+		syslog(LOG_DEBUG, "entry is NULL!");
+
+		FREE_LDAP_RESULT(vals, ldap_res);
+		return CONVERTUSERID_SYSFAILED;
+	    }
+
+	    vals = ldap_get_values(ldap_session, entry, ldap_attrs[0]);
+	    if(!vals || !ldap_count_values(vals)) {
+		if(!vals)
+		    syslog(LOG_DEBUG, "vals is NULL!");
+		else
+		    syslog(LOG_DEBUG, "vals is EMPTY!");
+
+		FREE_LDAP_RESULT(vals, ldap_res);
+		return CONVERTUSERID_SYSFAILED;
+	    }
+
+	    /* save 'vals[0]' as an external name and 'in' as an internal
+	       one */
+	    nonencoded_out = vals[0];
+	    nonencoded_len = strlen(nonencoded_out);
+	}
+
+	/* 'nonencoded_out' buffer is an UTF-8 buffer. We need to
+	   convert it to MUTF-7 encoding in case if it is an external
+	   userid. */
+	if(int2ext) {
+	    char *temp_out = utf8_to_mutf7(nonencoded_out, nonencoded_len, out_len);
+	    if(!temp_out) {
+		syslog(LOG_DEBUG, "utf8_to_mutf7() failed.\n");
+
+		FREE_LDAP_RESULT(vals, ldap_res);
+		return CONVERTUSERID_SYSFAILED;
+	    }
+	    if(*out_len > MAX_MAILBOX_NAME) {
+		syslog(LOG_DEBUG, "too long utf8_to_mutf7() output string.\n");
+		*out_len = 0;
+		free(temp_out);
+
+		FREE_LDAP_RESULT(vals, ldap_res);
+		return CONVERTUSERID_SYSFAILED;
+	    }
+	    memcpy(out, temp_out, *out_len);
+	    free(temp_out);
+	}
+	else {
+	    memcpy(out, nonencoded_out, nonencoded_len);
+	    *out_len = nonencoded_len;
+	}
+
+	FREE_LDAP_RESULT(vals, ldap_res);
+    }
+
+    return 0;
+}
+
+/* read convertuserid LDAP configuration options from configuration
+   files */
+static int read_ldap_options()
+{
+    int ldap_attr_int_len;
+    int ldap_attr_ext_len;
+    int ldap_attr_domain_len;
+
+    if(config_virtdomains)
+	ldap_query_domains = 1;
+    else
+	ldap_query_domains = config_getswitch(IMAPOPT_CONVERTUSERID_LDAP_QUERY_DOMAINS);
+    
+    ldap_host = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_HOST);
+    ldapd_localhost = config_getstring(IMAPOPT_CONVERTUSERID_LOCALHOST);
+
+    ldap_port = config_getint(IMAPOPT_CONVERTUSERID_LDAP_PORT);
+    if(!ldap_port)
+	ldap_port=LDAP_PORT;
+
+    ldap_user = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_USER);
+    ldap_password = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_PASSWORD);
+
+    ldap_base = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_BASE);
+
+    ldap_attr_int = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_ATTR_INT);
+    if(!ldap_attr_int) {
+	syslog(LOG_ERR, "convertuserid_ldap_attr_int option is not set\n");
+	return 1;
+    }
+    ldap_attr_ext = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_ATTR_EXT);
+    if(!ldap_attr_ext) {
+	syslog(LOG_ERR, "convertuserid_ldap_attr_ext option is not set\n");
+	return 1;
+    }
+
+    ldap_attr_int_len = strlen(ldap_attr_int);
+    ldap_attr_ext_len = strlen(ldap_attr_ext);
+
+    if(ldap_query_domains) {
+	ldap_attr_domain = config_getstring(IMAPOPT_CONVERTUSERID_LDAP_ATTR_DOMAIN);
+	ldap_attr_domain_len = strlen(ldap_attr_domain);
+	ldap_filter_int_len = ldap_attr_int_len + ldap_attr_domain_len + LDAP_DOMAINFILTER_TEMPLATESIZE;
+	ldap_filter_ext_len = ldap_attr_ext_len + ldap_attr_domain_len + LDAP_DOMAINFILTER_TEMPLATESIZE;
+    }
+    else {
+	ldap_attr_domain = NULL;
+	ldap_attr_domain_len = 0;
+	ldap_filter_int_len = ldap_attr_int_len + LDAP_FILTER_TEMPLATESIZE;
+	ldap_filter_ext_len = ldap_attr_ext_len + LDAP_FILTER_TEMPLATESIZE;
+    }
+
+    ldap_filter_int = (char *)malloc(ldap_filter_int_len);
+    if(!ldap_filter_int) {
+	syslog(LOG_ERR, "memory allocation was failed\n");
+	return 1;
+    }
+    ldap_filter_ext = (char *)malloc(ldap_filter_ext_len);
+    if(!ldap_filter_ext) {
+	syslog(LOG_ERR, "memory allocation was failed\n");
+	free(ldap_filter_int);
+	return 1;
+    }
+    sprintf(ldap_filter_int, ldap_query_domains?LDAP_DOMAINFILTER_TEMPLATE:LDAP_FILTER_TEMPLATE, ldap_attr_int, ldap_attr_domain);
+    sprintf(ldap_filter_ext, ldap_query_domains?LDAP_DOMAINFILTER_TEMPLATE:LDAP_FILTER_TEMPLATE, ldap_attr_ext, ldap_attr_domain);
+
+    return 0;
+}
+
+int main(int argc, char **argv)
+{
+    int opt;
+    int s, len;
+    struct sockaddr_in local;
+    ldap_data_t ldapdata;
+    ldap_data_result_t ldapdata_result;
+    struct sockaddr_in from;
+    socklen_t fromlen;
+    pid_t pid;
+    int fd;
+    char *alt_config = NULL;
+    int curchild;
+    int port_num;
+    struct option longopts[]={
+	{"prefork", 1, NULL, 'n'},
+	{NULL, 0, NULL, 0},
+    };
+
+    while ((opt = getopt_long(argc, argv, "C:n:", longopts, NULL)) != EOF) {
+	switch (opt) {
+        case 'C': /* alt config file */
+            alt_config = optarg;
+            break;
+	case 'n':
+	    n_listeners = atoi(optarg);
+	    if(n_listeners<=0) {
+		fprintf(stderr, "invalid number of listener processes\n");
+		exit(EC_USAGE);
+	    }
+	    break;
+	default:
+	    fprintf(stderr, "invalid argument\n");
+	    exit(EC_USAGE);
+	    break;
+	}
+    }
+
+    /* set default number of listeners if needed */
+    if(!n_listeners)
+	n_listeners=1;
+
+    cyrus_init(alt_config, "ldapd", 0);
+
+    port_num = config_getint(IMAPOPT_CONVERTUSERID_UDPPORT);
+
+    if(read_ldap_options())
+	exit(1);
+
+    /* create socket we are going to use for listening */
+    if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
+	perror("socket");
+	cyrus_done();
+	exit(1);
+    }
+
+    local.sin_family = AF_INET;
+    inet_pton(AF_INET, ldapd_localhost, &local.sin_addr);
+    local.sin_port = htons(port_num);
+    len=sizeof(local);
+
+    if (bind(s, (struct sockaddr *)&local, len) == -1) {
+	perror("bind");
+	cyrus_done();
+	exit(1);
+    }
+
+    for(curchild=0; curchild<n_listeners; curchild++) {
+	pid = fork();
+	if (pid == -1) {
+	    perror("fork");
+	    cyrus_done();
+	    exit(1);
+	}
+	
+	if (pid != 0) { /* parent */
+	    continue;
+	}
+	/* child */
+	break;
+    }
+
+    if (pid != 0) { /* parent */
+	cyrus_done();
+	exit(0);
+    }
+	
+    /* child */
+
+    for (;;) {
+	int n;
+
+	fromlen = sizeof(from);
+	n = recvfrom(s, (void*) &ldapdata, sizeof(ldap_data_t), 0,
+		     (struct sockaddr *) &from, &fromlen);
+
+	if (n > 0) {
+	    if (n <= LDAPDATA_BASE_SIZE ||
+		!ldapdata.userlen ||
+		ldapdata.userlen > MAX_MAILBOX_NAME ||
+		ldapdata.userlen < n-LDAPDATA_BASE_SIZE)
+		syslog(LOG_ERR, "Invalid message received, size=%d, userlen=%lu\n", n, (n < LDAPDATA_BASE_SIZE)?(unsigned long)0:ldapdata.userlen);
+	    else {
+		int resultlen=0;
+
+		ldapdata_result.code=get_id_from_ldap(
+		    ldapdata.buf, ldapdata.userlen,
+		    ldapdata.buf+ldapdata.userlen, n-LDAPDATA_BASE_SIZE-ldapdata.userlen,
+		    ldapdata_result.buf, &resultlen,
+		    ldapdata.int2ext);
+		if(sendto(s, (void *)&ldapdata_result, resultlen+LDAPDATA_RESULT_BASE_SIZE,0,(struct sockaddr *)&from,fromlen)==-1)
+		    syslog(LOG_ERR, "Cannot send an answer: %s\n", strerror(errno));
+	    }
+	}
+    }
+
+    cyrus_done();
+
+    /* never gets here */      
+    exit(1);
+}
+
+void printstring(const char *s __attribute__((unused)))
+{ 
+    /* needed to link against annotate.o */
+    fatal("printstring() executed!!!",
+          EC_SOFTWARE);
+}
diff -urN cyrus-imapd-2.2.12.old/imap/ldapd.h cyrus-imapd-2.2.12/imap/ldapd.h
--- cyrus-imapd-2.2.12.old/imap/ldapd.h	1970-01-01 03:00:00 +0300
+++ cyrus-imapd-2.2.12/imap/ldapd.h	2005-12-30 15:14:31 +0300
@@ -0,0 +1,31 @@
+#ifndef _LDAPD_H
+#define _LDAPD_H
+
+#include "mailbox.h"
+
+#define CONVERTUSERID_OK             0
+#define CONVERTUSERID_LDAPFAILED     1
+#define CONVERTUSERID_SYSFAILED      2
+#define CONVERTUSERID_NONEXISTENT_ID 3
+
+#define CONVERTUSERID_MASK         0x3
+
+typedef struct ldap_data_s {
+    unsigned long int2ext;
+    unsigned long userlen; /* length of the username buffer */
+
+    /* non-null-terminated buffer for username and domain */
+    char buf[MAX_MAILBOX_NAME*2];
+} ldap_data_t;
+
+typedef struct ldap_data_result_s {
+    unsigned long code;
+
+    /* non-null-terminated buffer for converted username */
+    char buf[MAX_MAILBOX_NAME];
+} ldap_data_result_t;
+
+#define LDAPDATA_BASE_SIZE	(2 * sizeof(unsigned long))
+#define LDAPDATA_RESULT_BASE_SIZE	(sizeof(unsigned long))
+
+#endif /* _LDAPD_H */
diff -urN cyrus-imapd-2.2.12.old/imap/Makefile.in cyrus-imapd-2.2.12/imap/Makefile.in
--- cyrus-imapd-2.2.12.old/imap/Makefile.in	2005-12-30 12:55:53 +0300
+++ cyrus-imapd-2.2.12/imap/Makefile.in	2005-12-30 15:13:58 +0300
@@ -69,7 +69,7 @@
 SIEVE_LIBS = @SIEVE_LIBS@
 IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
 LIB_WRAP = @LIB_WRAP@
-LIBS = $(IMAP_LIBS) $(IMAP_COM_ERR_LIBS)
+LIBS = $(IMAP_LIBS) $(IMAP_COM_ERR_LIBS) -lredblack -lldap
 DEPLIBS = ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
 
 CFLAGS = @CFLAGS@
@@ -104,7 +104,7 @@
 	convert_code.o duplicate.o saslclient.o saslserver.o signals.o \
 	annotate.o search_engines.o squat.o squat_internal.o mbdump.o \
 	imapparse.o telemetry.o user.o notify.o protocol.o quota_db.o \
-	autosieve.o $(SEEN) $(IDLE)
+	autosieve.o charset_convert.o $(SEEN) $(IDLE)
 
 IMAPDOBJS=pushstats.o backend.o imapd.o index.o tls.o version.o
 
@@ -190,6 +190,10 @@
 	$(CC) $(LDFLAGS) -o idled \
 	 idled.o mutex_fake.o libimap.a $(SIEVE_LIBS) $(DEPLIBS) $(LIBS)
 
+ldapd: ldapd.o mutex_fake.o libimap.a $(DEPLIBS)
+	$(CC) $(LDFLAGS) -o ldapd \
+	 ldapd.o mutex_fake.o libimap.a $(SIEVE_LIBS) $(DEPLIBS) $(LIBS)
+
 lmtpd: lmtpd.o $(LMTPOBJS) $(SIEVE_OBJS) mutex_fake.o libimap.a $(SIEVE_LIBS) \
 	$(DEPLIBS) $(SERVICE)
 	$(CC) $(LDFLAGS) -o lmtpd \
diff -urN cyrus-imapd-2.2.12.old/imap/mboxlist.c cyrus-imapd-2.2.12/imap/mboxlist.c
--- cyrus-imapd-2.2.12.old/imap/mboxlist.c	2005-12-30 12:56:24 +0300
+++ cyrus-imapd-2.2.12/imap/mboxlist.c	2005-12-30 15:13:58 +0300
@@ -1759,36 +1759,6 @@
     /* don't list mailboxes outside of the default domain */
     if (!rock->domainlen && !rock->isadmin && strchr(key, '!')) return 0; 
 
-    minmatch = 0;
-
-    memcpy(namebuf, key, keylen);
-    namebuf[keylen] = '\0';
-
-    /* right work with an alternate (not the build-in)
-       namespace -- sorcerer */
-    if(keylen >= sizeof(namebuf)) {
-	syslog(LOG_ERR, "oversize keylen in mboxlist.c:find_p()");
-	return 0;
-    }
-    if(rock->inboxoffset) {
-	namebuf[rock->inboxoffset] = rock->inboxcase[0];
-	namebuf[rock->inboxoffset+1] = rock->inboxcase[1];
-	namebuf[rock->inboxoffset+2] = rock->inboxcase[2];
-	namebuf[rock->inboxoffset+3] = rock->inboxcase[3];
-	namebuf[rock->inboxoffset+4] = rock->inboxcase[4];
-    }
-
-    /* if cant get the external name then skip the current
-       key -- sorcerer */
-    if((rock->namespace->mboxname_toexternal)(rock->namespace, namebuf+rock->inboxoffset, auth_canonuser(rock->auth_state), namebuf_out))
-	return 0;
-
-    matchlen = glob_test(g, namebuf_out,
-			 strlen(namebuf_out), &minmatch);
-
-    /* If its not a match, skip it -- partial matches are ok. */
-    if(matchlen == -1) return 0;
-
     if (rock->find_namespace != NAMESPACE_INBOX &&
 	rock->usermboxname &&
 	keylen >= rock->usermboxnamelen &&
@@ -1842,6 +1812,35 @@
 	}
     }
     
+    minmatch = 0;
+
+    memcpy(namebuf, key, keylen);
+    namebuf[keylen] = '\0';
+
+    /* right work with an alternate namespace -- sorcerer */
+    if(keylen >= sizeof(namebuf)) {
+	syslog(LOG_ERR, "oversize keylen in mboxlist.c:find_p()");
+	return 0;
+    }
+    if(rock->inboxoffset) {
+	namebuf[rock->inboxoffset] = rock->inboxcase[0];
+	namebuf[rock->inboxoffset+1] = rock->inboxcase[1];
+	namebuf[rock->inboxoffset+2] = rock->inboxcase[2];
+	namebuf[rock->inboxoffset+3] = rock->inboxcase[3];
+	namebuf[rock->inboxoffset+4] = rock->inboxcase[4];
+    }
+
+    /* if cant get the external name then skip the current
+       key -- sorcerer */
+    if((rock->namespace->mboxname_toexternal)(rock->namespace, namebuf+rock->inboxoffset, auth_canonuser(rock->auth_state), namebuf_out))
+	return 0;
+
+    matchlen = glob_test(g, namebuf_out,
+			 strlen(namebuf_out), &minmatch);
+
+    /* If its not a match, skip it -- partial matches are ok. */
+    if(matchlen == -1) return 0;
+
     /* if we get here, close enough for us to spend the time
        acting interested */
     return 1;
diff -urN cyrus-imapd-2.2.12.old/imap/mboxname.c cyrus-imapd-2.2.12/imap/mboxname.c
--- cyrus-imapd-2.2.12.old/imap/mboxname.c	2005-12-30 12:56:25 +0300
+++ cyrus-imapd-2.2.12/imap/mboxname.c	2005-12-30 15:13:59 +0300
@@ -57,6 +57,17 @@
 
 #include "mboxname.h"
 #include "mboxlist.h"
+#include "imapd.h"
+
+#ifdef ENABLE_CONVERT_USERID
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <redblack.h>
+#include <syslog.h>
+#include "ldapd.h"
+#include "cyrusdb.h"
+#endif /* ENABLE_CONVERT_USERID */
 
 /* Mailbox patterns which the design of the server prohibits */
 static char *badmboxpatterns[] = {
@@ -95,6 +106,775 @@
 };
 #define CHARMOD64(c)  (index_mod64[(unsigned char)(c)])
 
+#ifdef ENABLE_CONVERT_USERID
+
+int imapd_convertuserid=0;
+int imapd_nonconverteduserid_allowed=0;
+int imapd_dontignore_convertuserid_errors=0;
+int imapd_convertuserid_actual_timeout=0;
+
+extern struct cyrusdb_backend *config_convertuserid_cache_db;
+static struct db *convertuserid_db=NULL;
+
+typedef struct _rbt_data_t {
+    char *domain;
+    char *uid;
+    int uid_len;
+    char *sn;
+    int sn_len;
+} rbt_data_t;
+
+static struct rbtree *rbt_int_to_ext=NULL;
+static struct rbtree *rbt_ext_to_int=NULL;
+
+static int convertuserid_socket=-1;
+
+int rbt_data_compare(const void *p1, const void *p2, const void *config)
+{
+    rbt_data_t *d1=(rbt_data_t *)p1;
+    rbt_data_t *d2=(rbt_data_t *)p2;
+    int res;
+
+    if(!(res=strcmp(d1->domain, d2->domain))) {
+	char *str1, *str2;
+	int str1_len, str2_len;
+	int min_len;
+
+	if(config) {
+	    str1=d1->uid;
+	    str1_len=d1->uid_len;
+	    str2=d2->uid;
+	    str2_len=d2->uid_len;
+	}
+	else {
+	    str1=d1->sn;
+	    str1_len=d1->sn_len;
+	    str2=d2->sn;
+	    str2_len=d2->sn_len;
+	}
+	min_len = (str1_len < str2_len)? str1_len : str2_len;
+	if(!(res=memcmp(str1, str2, min_len))) {
+	    if(min_len==str1_len)
+		res = (min_len==str2_len)?0:-1;
+	    else
+		res = -1;
+	}
+    }
+    return res;
+}
+
+#define DONT_ALLOCIN  0x1
+#define DONT_ALLOCOUT 0x2
+
+static rbt_data_t *rbt_init_userid_data(const char *uid, int uid_len, const char *domain, const char *sn, int sn_len, int flags)
+{
+    rbt_data_t *res=(rbt_data_t *)malloc(sizeof(rbt_data_t));
+
+    if(!res)
+	return NULL;
+
+    res->domain = strdup(domain);
+    if(!res->domain) {
+	free(res);
+	return NULL;
+    }
+
+    if(uid == sn && (flags & (DONT_ALLOCIN|DONT_ALLOCOUT)))
+	flags |= (DONT_ALLOCIN|DONT_ALLOCOUT);
+
+    if(flags & DONT_ALLOCIN)
+	res->uid = (char *)uid;
+    else if(!(res->uid = (char *)malloc(uid_len))) {
+	free(res->domain);
+	free(res);
+	return NULL;
+    }
+    else
+	memcpy(res->uid, uid, uid_len);
+
+    if(uid == sn && !(flags & DONT_ALLOCOUT)) {
+	sn = res->uid;
+	flags |= DONT_ALLOCOUT;
+    }
+
+    if(flags & DONT_ALLOCOUT)
+	res->sn = (char *)sn;
+    else if(!(res->sn = (char *)malloc(sn_len))) {
+	free(res->domain);
+	if(!(flags & DONT_ALLOCIN))
+	    free(res->uid);
+	free(res);
+	return NULL;
+    }
+    else
+	memcpy(res->sn, sn, sn_len);
+
+    res->uid_len = uid_len;
+    res->sn_len = sn_len;
+
+    return res;
+}
+
+void rbt_free_userid_data(rbt_data_t *data)
+{
+    free(data->domain);
+    free(data->uid);
+    if(data->uid!=data->sn)
+	free(data->sn);
+    free(data);
+}
+
+#define INTERNAL              0x1
+
+extern int convertuserid_init()
+{
+    const char *convertuserid_sock;
+    int locallen;
+    int pathlen;
+    mode_t oldumask;
+    int port_num;
+    struct sockaddr_in convertuserid_remote;
+    int convertuserid_remote_len;
+
+    /* if the socket is already open, return */
+    if (convertuserid_socket != -1) {
+	syslog(LOG_ERR, "convertuserid_init: must not be called twice");
+	return -1;
+    }
+
+    port_num = config_getint(IMAPOPT_CONVERTUSERID_UDPPORT);
+    if(!port_num) {
+	syslog(LOG_ERR, "Invalid value of convertuserid_udpport config option\n");
+	return -1;
+    }
+
+    if ((convertuserid_socket = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
+	syslog(LOG_ERR, "convertuserid_init: can't create a socket");
+	return -1;
+    }
+
+    convertuserid_remote.sin_family = AF_INET;
+    convertuserid_remote.sin_port = htons(port_num);
+    inet_pton(AF_INET, config_getstring(IMAPOPT_CONVERTUSERID_LOCALHOST), &convertuserid_remote.sin_addr);
+    convertuserid_remote_len = sizeof(convertuserid_remote);
+
+    if(connect(convertuserid_socket, (struct sockaddr *)&convertuserid_remote, convertuserid_remote_len)==-1) {
+	syslog(LOG_ERR, "convertuserid_init: can't connect (datagram)");
+	return -1;
+    }
+
+    if(config_convertuserid_cache_db) {
+	size_t fname_len = strlen(config_dir)+strlen(FNAME_CONVERTUSERID)+1;
+	char *fname;
+	
+	if(!(fname = (char *)malloc(fname_len)))
+	    syslog(LOG_ERR, "convertuserid_init: can't allocate a temporary buffer. Convertuserid cache is disabled!");
+	else {
+	    int ret;
+	    
+	    strcpy(fname, config_dir);
+	    strcat(fname, FNAME_CONVERTUSERID);
+	    if((ret = config_convertuserid_cache_db->open(fname, CYRUSDB_CREATE, &convertuserid_db)))
+		syslog(LOG_ERR, "convertuserid_init: can't open %s: %s. Convertuserid cache is disabled!", fname, cyrusdb_strerror(ret));
+	}
+	if(fname)
+	    free(fname);
+    }
+
+    return 0;
+}
+
+extern int convertuserid_config_reread()
+{
+    template_option opts[]={
+	{(void *)IMAPOPT_CONVERTUSERID, TEMPLATEOPT_TYPE_KNOWNOPT},
+	{(void *)IMAPOPT_CONVERTUSERID_EXEMPTS, TEMPLATEOPT_TYPE_KNOWNOPT},
+	{(void *)IMAPOPT_CONVERTUSERID_ALLOW_NONCONVERTED, TEMPLATEOPT_TYPE_KNOWNOPT},
+	{(void *)IMAPOPT_CONVERTUSERID_DONTIGNORE_ERRORS, TEMPLATEOPT_TYPE_KNOWNOPT},
+	{(void *)IMAPOPT_CONVERTUSERID_ACTUAL_TIMEOUT, TEMPLATEOPT_TYPE_KNOWNOPT},
+    };
+
+    return config_reread(opts, sizeof(opts)/sizeof(opts[0]));
+}
+
+static char *get_id_from_ldap(const char *in, int in_len, const char *domain, int *out_len, unsigned long *errcode, int flags)
+{
+    ldap_data_t senddata;
+    int domainlen=strlen(domain);
+    ssize_t size;
+
+    senddata.int2ext = flags&INTERNAL;
+    senddata.userlen = in_len;
+    memcpy(senddata.buf, in, in_len);
+    memcpy(senddata.buf+in_len, domain, domainlen);
+
+    size=send(convertuserid_socket, (void *)&senddata, LDAPDATA_BASE_SIZE+in_len+domainlen, 0);
+    if(size == (ssize_t)-1) {
+	syslog(LOG_ERR, "Cannot send convertuserid query: %s.\n", strerror(errno));
+	*errcode = CONVERTUSERID_SYSFAILED;
+	return NULL;
+    }
+    if(size != LDAPDATA_BASE_SIZE+in_len+domainlen)
+	syslog(LOG_ERR, "Cannot send full convertuserid query.\n");
+
+    if(size) {
+	ldap_data_result_t recvdata;
+	char *out;
+
+	size = recv(convertuserid_socket, (void *)&recvdata, sizeof(recvdata), 0);
+	if(size==(ssize_t)-1) {
+	    syslog(LOG_ERR, "Cannot receive convertuserid answer: %s.\n", strerror(errno));
+	    *errcode = CONVERTUSERID_SYSFAILED;
+	    return NULL;
+	}
+	if(size<LDAPDATA_RESULT_BASE_SIZE ||
+	   (recvdata.code ?
+	    size>LDAPDATA_RESULT_BASE_SIZE : size==LDAPDATA_RESULT_BASE_SIZE)) {
+	    syslog(LOG_ERR, "Wrong size of convertuserid answer.\n");
+	    *errcode = CONVERTUSERID_SYSFAILED;
+	    return NULL;
+	}
+	*errcode = recvdata.code;
+
+	/* answer is "can't convert userid" */
+	if(recvdata.code)
+	    return NULL;
+
+	size-=LDAPDATA_RESULT_BASE_SIZE;
+	out=(char *)malloc(size);
+	if(!out) {
+	    *errcode = CONVERTUSERID_SYSFAILED;
+	    syslog(LOG_DEBUG, "mboxname_get_id_from_ldap(): memory allocation failed.\n");
+	    return NULL;
+	}
+	memcpy(out, recvdata.buf, size);
+	*out_len = size;
+	return out;
+    }
+
+    *errcode = CONVERTUSERID_SYSFAILED;
+    return NULL;
+}
+
+static char *memcache_fetch(const char *in, int in_len, const char *domain, int *out_len, int flags)
+{
+    rbt_data_t data;
+    rbt_data_t *saved_data;
+
+    *out_len = 0;
+
+    if(!rbt_int_to_ext)
+	if(!(rbt_int_to_ext = rbinit(rbt_data_compare, (void *)1)))
+	    return NULL;
+    if(!rbt_ext_to_int)
+	if(!(rbt_ext_to_int = rbinit(rbt_data_compare, (void *)0)))
+	    return NULL;
+
+    data.domain = (char *)domain;
+    if(flags&INTERNAL) {
+	data.uid = (char *)in;
+	data.uid_len = in_len;
+	data.sn = NULL;
+	data.sn_len = 0;
+    }
+    else {
+	data.sn = (char *)in;
+	data.sn_len = in_len;
+	data.uid = NULL;
+	data.uid_len = 0;
+    }
+
+    if((saved_data=(rbt_data_t *)rbfind((void *)&data, (flags&INTERNAL)?rbt_int_to_ext:rbt_ext_to_int))) {
+	if(flags&INTERNAL) {
+	    *out_len = saved_data->sn_len;
+	    return saved_data->sn;
+	}
+	else {
+	    *out_len = saved_data->uid_len;
+	    return saved_data->uid;
+	} 
+    }
+    return NULL;
+}
+
+static int memcache_store(const char *uid, int uid_len, const char *domain, const char *sn, int sn_len, int flags)
+{
+    rbt_data_t *saved_data;
+
+    saved_data=rbt_init_userid_data(uid, uid_len, domain, sn, sn_len, flags);
+
+    if(!rbsearch(saved_data,rbt_int_to_ext)) {
+	rbt_free_userid_data(saved_data);
+	saved_data=NULL;
+    }
+    else if(!rbsearch(saved_data,rbt_ext_to_int)) {
+	rbdelete(saved_data, rbt_int_to_ext);
+	rbt_free_userid_data(saved_data);
+	saved_data=NULL;
+    }
+    return !saved_data;
+}
+
+#define ACTUAL 0x70000000
+
+static char *diskcache_fetch(const char *in, int in_len, const char *domain, int *out_len, int in_flags, int *out_flags)
+{
+    char key[MAX_MAILBOX_NAME*2+5+1];
+    int keylen;
+    /* format: <code - 1 character> <sp> <timestamp - decimal string>
+       <sp> <mbname> */
+    char *data;
+    unsigned long timestamp;
+    int r_out_flags=0;
+    char *p,*end;
+    int datalen;
+    char *ret;
+    int ret_len;
+
+    *out_len = 0;
+    *out_flags = 0;
+
+    if(!convertuserid_db)
+	return NULL;
+
+    if(in_len > MAX_MAILBOX_NAME)
+	return NULL;
+
+    snprintf(key, sizeof(key), "%s!%s!%.*s",
+	     domain,
+	     (in_flags&INTERNAL)?"uid":"sn",
+	     in_len, in);
+    keylen = strlen(key);
+
+    if(config_convertuserid_cache_db->fetch(convertuserid_db, key, keylen, (const char **)&data, &datalen, NULL))
+	return NULL;
+
+    p=data;
+
+    if(datalen<5)
+	return NULL;
+
+    r_out_flags = ((unsigned char)data[0]) - (unsigned char)'0';
+    p = data+1;
+    if(*p != ' ')
+	return NULL;
+    p++;
+    for(end=p; end<data+datalen-2; end++) {
+	if(*end < '0' || *end > '9')
+	    break;
+    }
+    if(end==data+datalen-2 || !(end-p) || (end-p)>20 || *end != ' ')
+	return NULL;
+    
+    timestamp = atol(p);
+    if(time(NULL)-timestamp < imapd_convertuserid_actual_timeout)
+	r_out_flags |= ACTUAL;
+    p = end+1;
+
+    ret_len = datalen-(p-data);
+    if(ret_len > MAX_MAILBOX_NAME)
+	return NULL;
+
+    ret = (char *)malloc(ret_len);
+    if(!ret)
+	return NULL;
+    memcpy(ret, p, ret_len);
+    *out_len = ret_len;
+    *out_flags = r_out_flags;
+
+    return ret;
+}
+
+static int diskcache_store_int(const char *id_name, const char *key_value, int key_value_len, const char *domain, const char *data_value, int data_value_len, int code, time_t timestamp, struct txn **tid)
+{
+    char key[MAX_MAILBOX_NAME*2+5+1];
+    char data[MAX_MAILBOX_NAME+1+1+20+1];
+
+    code &= CONVERTUSERID_MASK;
+    snprintf(key, sizeof(key), "%s!%s!%.*s",
+	     domain, id_name, key_value_len, key_value);
+    snprintf(data, sizeof(data), "%c %lu %.*s",
+	     (char)('0'+code), (unsigned long)timestamp,
+	     data_value_len, data_value);
+
+    return config_convertuserid_cache_db->store(convertuserid_db, key, strlen(key),
+					 data, strlen(data), tid);
+}
+
+static int diskcache_store(const char *uid, int uid_len, const char *domain, const char *sn, int sn_len, int code)
+{
+    struct txn *tid=NULL;
+    time_t timestamp;
+
+    if(!convertuserid_db)
+	return 0;
+
+    timestamp = time(NULL);
+    if(!diskcache_store_int("uid", uid, uid_len, domain, sn, sn_len, code, timestamp, &tid) && !diskcache_store_int("sn", sn, sn_len, domain, uid, uid_len, code, timestamp, &tid))
+	return config_convertuserid_cache_db->commit(convertuserid_db, tid);
+
+    config_convertuserid_cache_db->abort(convertuserid_db, tid);
+    return 1;
+}
+
+static int diskcache_remove_int(const char *id_name, const char *key_value, int key_value_len, const char *domain, struct txn **tid)
+{
+    char key[MAX_MAILBOX_NAME*2+5+1];
+
+    snprintf(key, sizeof(key), "%s!%s!%.*s",
+	     domain, id_name, key_value_len, key_value);
+
+    return config_convertuserid_cache_db->delete(convertuserid_db, key, strlen(key), tid, 1);
+}
+
+static int diskcache_remove(const char *uid, int uid_len, const char *domain, const char *sn, int sn_len)
+{
+    struct txn *tid=NULL;
+
+    if(!convertuserid_db)
+	return 0;
+
+    if(!diskcache_remove_int("uid", uid, uid_len, domain, &tid) && !diskcache_remove_int("sn", sn, sn_len, domain, &tid))
+	return config_convertuserid_cache_db->commit(convertuserid_db, tid);
+
+    config_convertuserid_cache_db->abort(convertuserid_db, tid);
+    return 1;
+}
+
+#define SN_TO_UID_CLEANUP(cached_uid, cached_sn, out_len_value) do {\
+if(cached_uid) { \
+free(cached_uid); \
+cached_uid=NULL; \
+} \
+if(cached_sn) { \
+free(cached_sn); \
+cached_sn=NULL; \
+} \
+*out_len = (out_len_value); \
+} while(0);
+
+#define UID_TO_SN_CLEANUP(cached_sn, out_len_value) do {\
+if(cached_sn) { \
+free(cached_sn); \
+cached_sn=NULL; \
+} \
+*out_len = (out_len_value); \
+} while(0);
+
+/* Check if diskcache record flags are compatible with current imapd
+   options. If not, we cannot use the record. */
+static int diskflags_valid(int flags)
+{
+    int code = flags & CONVERTUSERID_MASK;
+
+    return code ? (imapd_nonconverteduserid_allowed && (code==CONVERTUSERID_NONEXISTENT_ID || !imapd_dontignore_convertuserid_errors)) : 1;
+}
+
+static char *sn_to_uid(const char *in, int in_len, const char *domain, int *out_len, int *code)
+{
+#ifndef ENABLE_CONVERT_USERID
+    *out_len = in_len;
+    *code = 0;
+    return (char *)in;
+#else
+    int flags;
+    char *cached_uid;
+    char *ldap_uid;
+    int ldap_uid_len;
+    unsigned long errcode;
+    char *cached_sn=NULL;
+    int cached_sn_len;
+    int sn_flags=0;
+
+    *code = 0;
+    if((cached_uid = memcache_fetch(in, in_len, domain, out_len, 0)))
+	return cached_uid;
+
+    cached_uid = diskcache_fetch(in, in_len, domain, out_len, 0, &flags);
+    if(cached_uid && (flags & ACTUAL)) {
+	if(!diskflags_valid(flags) || memcache_store(cached_uid, *out_len, domain, in, in_len, DONT_ALLOCIN)) {
+	    SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+	    return NULL;
+	}
+	return cached_uid;
+    }
+    else {
+	/* If we'll found invert record then user's input is wrong */
+	
+	if((cached_sn = memcache_fetch(in, in_len, domain, &cached_sn_len, INTERNAL))) {
+	    cached_sn=NULL;
+	    SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+	    return NULL;
+	}
+
+	cached_sn = diskcache_fetch(in, in_len, domain, &cached_sn_len, INTERNAL, &sn_flags);
+	if(cached_sn) {
+	    if(sn_flags & ACTUAL) {
+		/* if invert record is actual then it must be valid
+		   because if it is not valid then sn == uid and thus
+		   cached_uid must be valid too (but at this point,
+		   cached_uid is not valid) */
+		assert(diskflags_valid(sn_flags));
+		if(memcache_store(in, in_len, domain, cached_sn, cached_sn_len, DONT_ALLOCOUT))
+		    free(cached_sn);
+		cached_sn=NULL;
+		SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+		return NULL;
+	    }
+	}
+    }
+
+    /* Now, we may have nonactual sn->uid but may have not (even
+       nonactual sn->uid). We may determine it by (cached_uid,
+       *out_len) variables. In both cases we'll try to use LDAP. */
+
+    ldap_uid=get_id_from_ldap(in, in_len, domain, &ldap_uid_len, &errcode, 0);
+    if(ldap_uid) {
+	if(!diskcache_store(ldap_uid, ldap_uid_len, domain, in, in_len, CONVERTUSERID_OK) &&
+	   !memcache_store(ldap_uid, ldap_uid_len, domain, in, in_len, DONT_ALLOCIN)) {
+	    SN_TO_UID_CLEANUP(cached_uid, cached_sn, ldap_uid_len);
+	    return ldap_uid;
+	}
+	free(ldap_uid);
+	SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+	return NULL;
+    }
+
+    if(errcode==CONVERTUSERID_NONEXISTENT_ID) {
+	char *ldap_sn;
+	int ldap_sn_len;
+	int tempcode;
+
+	if(!imapd_nonconverteduserid_allowed) {
+	    if(cached_uid)
+		diskcache_remove(cached_uid, *out_len, domain, in, in_len);
+	    SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+	    return NULL;
+	}
+
+	/* making invert LDAP query */
+
+	/* if there is cached_sn then it is nonactual so we need to do
+	   LDAP query */
+
+	ldap_sn=get_id_from_ldap(in, in_len, domain, &ldap_sn_len, &errcode, INTERNAL);
+	if(ldap_sn) {
+	    if(cached_uid)
+		diskcache_remove(cached_uid, *out_len, domain, in, in_len);
+
+	    if(diskcache_store(in, in_len, domain, ldap_sn, ldap_sn_len, CONVERTUSERID_OK) || memcache_store(in, in_len, domain, ldap_sn, ldap_sn_len, DONT_ALLOCOUT))
+		free(ldap_sn);
+	    SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+	    return NULL;
+	}
+
+	if(errcode==CONVERTUSERID_NONEXISTENT_ID) {
+	    if(cached_uid)
+		diskcache_remove(cached_uid, *out_len, domain, in, in_len);
+
+	    /* We need to delete cached_sn only if it was successfully
+	       requested from LDAP. Otherwise, cached_uid==cached_sn
+	       so it has been already deleted. */
+	    if(cached_sn && (sn_flags&CONVERTUSERID_MASK)==CONVERTUSERID_OK)
+		diskcache_remove(in, in_len, domain, cached_sn, cached_sn_len);
+	    *code = CONVERTUSERID_NONEXISTENT_ID;
+	    SN_TO_UID_CLEANUP(cached_uid, cached_sn, in_len);
+	    return (char *)in;
+	}
+
+	/* If invert ldap query failed then we need to see on
+	   cached_sn. If cached_sn exists then there are cases:
+	   1. cached_sn was succeffully requested from LDAP. We don't
+	   want to display this record;
+	   2. cached_sn was not found in LDAP
+	   (CONVERTUSERID_NONEXISTENT_ID). In this case we can say
+	   that DB checking is needed;
+	   3. There was an error while requesting
+	   sn. cached_uid==cached_sn in this case. So, an error was
+	   and an error is. There are two cases:
+	   3.1. We have to ignore errors. DB checking is needed;
+	   3.2. We mustn't ignore errors. We don't want to display
+	   this record;
+	   If cached_sn doesn't exist then we only don't want to display
+	   this record if we mustn't ignore errors.
+	*/
+	tempcode = sn_flags & CONVERTUSERID_MASK;
+	if(cached_sn ?
+	   (tempcode==CONVERTUSERID_OK || (tempcode!=CONVERTUSERID_NONEXISTENT_ID && imapd_dontignore_convertuserid_errors)) :
+	   imapd_dontignore_convertuserid_errors) {
+
+	    if(tempcode!=CONVERTUSERID_OK)
+		diskcache_remove(cached_uid, *out_len, domain, in, in_len);
+	    else if(cached_sn) {
+		if(memcache_store(in, in_len, domain, cached_sn, cached_sn_len, DONT_ALLOCOUT))
+		    free(cached_sn);
+		cached_sn=NULL;
+		SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+		return NULL;
+	    }
+
+	    SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+	    return NULL;
+	}
+
+	/* Remove cached records from the cache. They may be added
+	   again if sn_to_uid_save() will be called. */
+	if(cached_uid)
+	    diskcache_remove(cached_uid, *out_len, domain, in, in_len);
+
+	if(cached_sn)
+	    *code = (tempcode==CONVERTUSERID_NONEXISTENT_ID) ? CONVERTUSERID_NONEXISTENT_ID : errcode;
+	else
+	    *code = errcode;
+
+	SN_TO_UID_CLEANUP(cached_uid, cached_sn, in_len);
+	return (char *)in;
+    }
+
+    if(cached_uid && diskflags_valid(flags)) {
+	if(memcache_store(cached_uid, *out_len, domain, in, in_len, DONT_ALLOCIN)) {
+	    SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+	    return NULL;
+	}
+	if(cached_sn)
+	    free(cached_sn);
+	return cached_uid;
+    }
+    if(!imapd_nonconverteduserid_allowed || imapd_dontignore_convertuserid_errors) {
+	SN_TO_UID_CLEANUP(cached_uid, cached_sn, 0);
+	return NULL;
+    }
+    *code = errcode;
+    SN_TO_UID_CLEANUP(cached_uid, cached_sn, in_len);
+    return (char *)in;
+#endif /* ENABLE_CONVERT_USERID */
+}
+
+static char *sn_to_uid_save(const char *in, int in_len, const char *domain, int *out_len, int code)
+{
+    if(diskcache_store(in, in_len, domain, in, in_len, code) ||
+       memcache_store(in, in_len, domain, in, in_len, 0)) {
+	*out_len=0;
+	return NULL;
+    }
+    *out_len = in_len;
+    return (char *)in;
+}
+
+static char *uid_to_sn(const char *in, int in_len, const char *domain, int *out_len)
+{
+#ifndef ENABLE_CONVERT_USERID
+    *out_len = in_len;
+    return (char *)in;
+#else
+    char *cached_sn;
+    char *ldap_sn;
+    int ldap_sn_len;
+    unsigned long errcode;
+    int flags;
+
+    if((cached_sn = memcache_fetch(in, in_len, domain, out_len, INTERNAL)))
+	return cached_sn;
+
+    cached_sn = diskcache_fetch(in, in_len, domain, out_len, INTERNAL, &flags);
+    if(cached_sn && (flags & ACTUAL)) {
+	if(!diskflags_valid(flags) || memcache_store(in, in_len, domain, cached_sn, *out_len, DONT_ALLOCOUT)) {
+	    UID_TO_SN_CLEANUP(cached_sn, 0);
+	    return NULL;
+	}
+	return cached_sn;
+    }
+
+    ldap_sn=get_id_from_ldap(in, in_len, domain, &ldap_sn_len, &errcode, INTERNAL);
+    if(ldap_sn) {
+	if(!diskcache_store(in, in_len, domain, ldap_sn, ldap_sn_len, CONVERTUSERID_OK) &&
+	   !memcache_store(in, in_len, domain, ldap_sn, ldap_sn_len, DONT_ALLOCOUT)) {
+	    UID_TO_SN_CLEANUP(cached_sn, ldap_sn_len);
+	    return ldap_sn;
+	}
+	free(ldap_sn);
+	UID_TO_SN_CLEANUP(cached_sn, 0);
+	return NULL;
+    }
+
+    if(errcode==CONVERTUSERID_NONEXISTENT_ID) {
+	if(cached_sn)
+	    diskcache_remove(in, in_len, domain, cached_sn, *out_len);
+	    
+	if(!imapd_nonconverteduserid_allowed) {
+	    UID_TO_SN_CLEANUP(cached_sn, 0);
+	    return NULL;
+	}
+
+	if(diskcache_store(in, in_len, domain, in, in_len, CONVERTUSERID_NONEXISTENT_ID) || memcache_store(in, in_len, domain, in, in_len, 0)) {
+	    UID_TO_SN_CLEANUP(cached_sn, 0);
+	    return NULL;
+	}
+	UID_TO_SN_CLEANUP(cached_sn, in_len);
+	return (char *)in;
+    }
+
+    if(cached_sn && diskflags_valid(flags)) {
+	if(memcache_store(in, in_len, domain, cached_sn, *out_len, DONT_ALLOCOUT)) {
+	    UID_TO_SN_CLEANUP(cached_sn, 0);
+	    return NULL;
+	}
+	return cached_sn;
+    }
+
+    diskcache_store(in, in_len, domain, in, in_len, errcode);
+
+    if(!imapd_nonconverteduserid_allowed || imapd_dontignore_convertuserid_errors) {
+	UID_TO_SN_CLEANUP(cached_sn, 0);
+	return NULL;
+    }
+
+    if(memcache_store(in, in_len, domain, in, in_len, 0)) {
+	UID_TO_SN_CLEANUP(cached_sn, 0);
+	return NULL;
+    }
+
+    UID_TO_SN_CLEANUP(cached_sn, in_len);
+    return (char *)in;
+#endif /* ENABLE_CONVERT_USERID */
+}
+
+static void rbt_walk_cb(const void *nodep, const VISIT which, const int depth, void *arg)
+{
+    if(which == endorder || which == leaf)
+	rbt_free_userid_data((rbt_data_t *)nodep);
+}
+
+/* destroying all the data needed for names transformation (this
+   function is called when client terminates his connection) */
+extern void mboxname_cleanup()
+{
+    rbt_data_t *data;
+
+    if(rbt_int_to_ext) {
+	rbwalk(rbt_int_to_ext, rbt_walk_cb, NULL);
+	    
+	rbdestroy(rbt_int_to_ext);
+	rbt_int_to_ext=NULL;
+    }
+    if(rbt_ext_to_int) {
+	rbdestroy(rbt_ext_to_int);
+	rbt_ext_to_int=NULL;
+    }
+}
+
+extern int convertuserid_cleanup()
+{
+    close(convertuserid_socket);
+
+    if(convertuserid_db) {
+	config_convertuserid_cache_db->close(convertuserid_db);
+	convertuserid_db=NULL;
+    }
+}
+
+#endif /* ENABLE_CONVERT_USERID */
+
 /* Check mailbox name for correct hierseps symbols depending on
    namespace */
 static int mboxname_check_hierseps(struct namespace *namespace, const char *name, int namelen)
@@ -206,7 +986,7 @@
 				   const char *name,
 				   const char *userid, char *result)
 {
-    char *cp;
+    char *cp, *domain="";
     int userlen, domainlen = 0, namelen;
     int prefixlen;
     size_t resultlen;
@@ -223,7 +1003,8 @@
     if (config_virtdomains) {
 	if (userid && (cp = strchr(userid, '@'))) {
 	    /* user logged in as user@domain */
-	    userlen = cp++ - userid;
+	    userlen = cp - userid;
+	    domain = ++cp;
 	    if (!(config_defdomain && !strcasecmp(config_defdomain, cp))) {
 		/* don't prepend default domain */
 		domainlen = strlen(cp)+1;
@@ -234,6 +1015,7 @@
 	}
 	if ((cp = strrchr(name, '@'))) {
 	    /* mailbox specified as mbox@domain */
+	    domain = cp+1;
 	    namelen = cp - name;
 
 	    if (config_defdomain && !strcasecmp(config_defdomain, cp+1)) {
@@ -291,18 +1073,74 @@
 
     if (!strncmp(name, namespace->prefix[NAMESPACE_USER], prefixlen-1) &&
 	(namelen == prefixlen-1 || name[prefixlen-1] == namespace->hier_sep)) {
+	char modified_username[MAX_MAILBOX_NAME+1];
+	char *int_id="";
+	size_t int_id_len=0;
+	size_t ext_id_len=0;
 
 	if (namelen == prefixlen-1) {
 	    /* can't create folders using undelimited prefix */
 	    return IMAP_MAILBOX_BADNAME;
 	}
 
-	if (domainlen+namelen-prefixlen+5 > MAX_MAILBOX_NAME) {
-	    return IMAP_MAILBOX_BADNAME;
+	if(!imapd_convertuserid) {
+	    if (domainlen+namelen-prefixlen+5 > MAX_MAILBOX_NAME)
+		return IMAP_MAILBOX_BADNAME;
+	    name+=prefixlen;
 	}
+	else {
+	    char *sep;
+	    int code;
+
+	    name+=prefixlen;
+	    sep=strchr(name,namespace->hier_sep);
+	    if(!sep || sep-name >= namelen-prefixlen)
+		ext_id_len = namelen-prefixlen;
+	    else
+		ext_id_len = sep-name;
+
+	    if(!ext_id_len)
+		return IMAP_MAILBOX_BADNAME;
+
+	    /* we must transform hierarchy separators in the _user_id_
+	       into internal representations before querying the
+	       internal user id because the revert transformation
+	       works with usernames only and knows nothing about
+	       separators -- sorcerer */
+	    memcpy(modified_username, name, ext_id_len);
+	    mboxname_hiersep_tointernal(namespace, modified_username,ext_id_len);
+
+	    int_id = sn_to_uid(modified_username, ext_id_len, domain, &int_id_len, &code);
+	    if(int_id && code) {
+		char temp_mbname[MAX_MAILBOX_NAME+1];
+
+		/* build internal mailbox name with given userid to
+		   check if this mailbox exists */
+		if(domainlen+namelen-prefixlen+5 > MAX_MAILBOX_NAME)
+		    return IMAP_MAILBOX_BADNAME;
+
+		memcpy(temp_mbname, "user.", 5);
+		memcpy(temp_mbname+5, modified_username, ext_id_len);
+		memcpy(temp_mbname+5+ext_id_len, name+ext_id_len, namelen-prefixlen-ext_id_len);
+		temp_mbname[5+namelen-prefixlen]=0;
+
+		mboxname_hiersep_tointernal(namespace, temp_mbname+5, 0);
+		if(mboxlist_lookup(temp_mbname, NULL, NULL, NULL))
+		    return IMAP_MAILBOX_NONEXISTENT;
 
-	sprintf(result, "user.%.*s", namelen-prefixlen, name+prefixlen);
+		int_id = sn_to_uid_save(modified_username, ext_id_len, domain, &int_id_len, code);
+	    }
+
+	    if(!int_id)
+		return IMAP_MAILBOX_NONEXISTENT;
 
+	    if(domainlen+namelen-prefixlen+5-ext_id_len+int_id_len > MAX_MAILBOX_NAME)
+		return IMAP_MAILBOX_BADNAME;
+	    name+=ext_id_len;
+	}
+
+	sprintf(result, "user.%.*s%.*s", int_id_len, int_id, namelen-prefixlen-ext_id_len, name);
+	
 	/* Translate any separators in userid+mailbox */
 	mboxname_hiersep_tointernal(namespace, result+5, 0);
 	return 0;
@@ -400,7 +1238,7 @@
 static int mboxname_toexternal_alt(struct namespace *namespace, const char *name,
 				  const char *userid, char *result)
 {
-    char *domain;
+    char *domain=NULL;
     size_t userlen, resultlen;
 
     /* Blank the result, just in case */
@@ -416,13 +1254,19 @@
 	size_t domainlen = strlen(domain);
 
 	userlen = domain - userid;
+	domain++;
+	domainlen--;
 
-	if (!strncmp(name, domain+1, domainlen-1) &&
-	    name[domainlen-1] == '!') {
-	    name += domainlen;
+	if (!strncmp(name, domain, domainlen) &&
+	    name[domainlen] == '!') {
+	    name += domainlen+1;
 	}
     }
 
+    /* set the empty domain if it doesn't exists */
+    if(!domain)
+	domain="";
+
     /* Personal (INBOX) namespace */
     if (!strncasecmp(name, "inbox", 5) &&
 	(name[5] == '\0' || name[5] == '.')) {
@@ -446,18 +1290,52 @@
     else if (!strncmp(name, "user", 4) &&
 	     (name[4] == '\0' || name[4] == '.')) {
 	size_t prefixlen = strlen(namespace->prefix[NAMESPACE_USER]);
+	char *ext_id="";
+	size_t ext_id_len=0;
 
-	if ((prefixlen > MAX_MAILBOX_NAME) || 
-	    ((name[4] == '.') && 
-	     ((prefixlen+1+strlen(name+5)) > MAX_MAILBOX_NAME)))
+	if (prefixlen > MAX_MAILBOX_NAME)
 	    return IMAP_MAILBOX_BADNAME;
+	
+	if(name[4] == '.') {
+	    if(!imapd_convertuserid) {
+		if((prefixlen+1+strlen(name+5)) > MAX_MAILBOX_NAME)
+		    return IMAP_MAILBOX_BADNAME;
+		name+=5;
+	    }
+	    /* fetching the user's identifier // sorcerer */
+	    else {
+		char *sep;
+		size_t int_id_len;
+
+		name+=5;
+		sep=strchr(name,'.');
+		if(sep)
+		    int_id_len=sep-name;
+		else
+		    int_id_len=strlen(name);
+
+		if(!int_id_len)
+		    return IMAP_MAILBOX_BADNAME;
+
+		/* we assume that the user domain is same as the name's
+		   domain (interdomain lookup are denied) */
+		ext_id = uid_to_sn(name, int_id_len, domain, &ext_id_len);
+		if(!ext_id)
+		    return IMAP_MAILBOX_NONEXISTENT;
+		if(prefixlen + ext_id_len + strlen(name+int_id_len) > MAX_MAILBOX_NAME)
+		    return IMAP_MAILBOX_BADNAME;
+		name+=int_id_len;
+	    }
+	}
 
 	sprintf(result, "%.*s",
 		prefixlen-1, namespace->prefix[NAMESPACE_USER]);
 	resultlen = strlen(result);
-	if (name[4] == '.') {
-	    sprintf(result+resultlen, "%c%s", namespace->hier_sep, name+5);
-	}
+
+	/* in the case if fetching id isn't enabled, ext_id variable
+	   will be empty and name variable will consist of the full
+	   mailbox name without namespace->prefix[NAMESPACE_USER] */
+	sprintf(result+resultlen, "%c%.*s%s", namespace->hier_sep, ext_id_len, ext_id, name);
     }
 
     /* Shared namespace */
diff -urN cyrus-imapd-2.2.12.old/imap/mboxname.h cyrus-imapd-2.2.12/imap/mboxname.h
--- cyrus-imapd-2.2.12.old/imap/mboxname.h	2005-12-30 12:56:25 +0300
+++ cyrus-imapd-2.2.12/imap/mboxname.h	2005-12-30 15:13:59 +0300
@@ -78,6 +78,23 @@
 			    void *rock, int force);
 };
 
+#ifdef ENABLE_CONVERT_USERID
+#define FNAME_CONVERTUSERID "/convertuserid.db"
+
+/* convert other users ids between namespaces (switch) */
+extern int imapd_convertuserid;
+extern int imapd_nonconverteduserid_allowed;
+extern int imapd_dontignore_convertuserid_errors;
+extern int imapd_convertuserid_actual_timeout;
+
+/* convert userid initialization and cleanup */
+int convertuserid_init();
+int convertuserid_config_reread();
+int convertuserid_cleanup();
+/* destroy additional information which is needed to transform userids */
+void mboxname_cleanup();
+#endif /* ENABLE_CONVERT_USERID */
+
 /* create namespace based on given options */
 int mboxname_init_namespace_ext(struct namespace *namespace, int isadmin, char hier_sep, int isalt);
 /* Create namespace based on config options. */
diff -urN cyrus-imapd-2.2.12.old/lib/hash.c cyrus-imapd-2.2.12/lib/hash.c
--- cyrus-imapd-2.2.12.old/lib/hash.c	2004-05-24 18:32:34 +0400
+++ cyrus-imapd-2.2.12/lib/hash.c	2005-12-30 15:13:59 +0300
@@ -317,6 +317,39 @@
       }
 }
 
+/* Same as hash_enumerate() but has ability to delete keys while going
+   through a hash table. Return non-zero value from the callback
+   function if you want to delete a key. Delete any external data
+   yourself. */
+void hash_walk(hash_table *table, int (*func)(char *, void *, void *),
+		    void *rock)
+{
+    unsigned i;
+    bucket *temp, *temp_old, *temp_next;
+
+    for (i=0;i<table->size; i++) {
+	if ((table->table)[i] != NULL) {
+	    for (temp = (table->table)[i], temp_old=NULL;
+		 NULL != temp;
+		 temp = temp_next) {
+
+		temp_next = temp->next;
+		if(func(temp -> key, temp->data, rock)) {
+		    if(temp_old)
+			temp_old->next = temp_next;
+		    else
+			(table->table)[i] = temp_next;
+		    if(!table->pool) {
+			free(temp->key);
+			free(temp);
+		    }
+		}
+		else
+		    temp_old=temp;
+	    }
+	}
+    }
+}
 
 #ifdef TEST
 
diff -urN cyrus-imapd-2.2.12.old/lib/hash.h cyrus-imapd-2.2.12/lib/hash.h
--- cyrus-imapd-2.2.12.old/lib/hash.h	2003-10-22 22:50:12 +0400
+++ cyrus-imapd-2.2.12/lib/hash.h	2005-12-30 15:13:59 +0300
@@ -78,6 +78,13 @@
 void hash_enumerate(hash_table *table,void (*func)(char *,void *,void *),
 		    void *rock);
 
+/* Same as hash_enumerate() but has ability to delete keys while going
+   through a hash table. Return non-zero value from the callback
+   function if you want to delete a key. Delete any external data
+   yourself. */
+void hash_walk(hash_table *table, int (*func)(char *, void *, void *),
+	       void *rock);
+
 /*
 ** Frees a hash table.  For each node that was inserted in the table,
 ** it calls the function whose address it was passed, with a pointer
diff -urN cyrus-imapd-2.2.12.old/lib/imapoptions cyrus-imapd-2.2.12/lib/imapoptions
--- cyrus-imapd-2.2.12.old/lib/imapoptions	2005-12-30 12:56:04 +0300
+++ cyrus-imapd-2.2.12/lib/imapoptions	2005-12-30 15:13:59 +0300
@@ -910,6 +910,76 @@
    interface, otherwise the user is assumed to be in the default
    domain (if set). */
 
+{ "convertuserid", 0, SWITCH }
+/* Enable user identifiers conversion via LDAP. This is a default
+   rule: it is possible to set exemptions on some set of users via
+   convertuserid_exempts config variable. If user's rule is 'convert'
+   then he doesn't see user identifiers via IMAP commands. Instead,
+   names got from LDAP are showed. This option is rereaded on each
+   new connected IMAP client, so you don't need to restart the server
+   to apply changes. */
+
+{ "convertuserid_exempts", NULL, STRING }
+/* Exemtions (list of user identifiers) from convertuserid option.
+   This option is rereaded on each new connected IMAP client. */
+
+{ "convertuserid_allow_nonconverted", 0, SWITCH }
+/* Allow to use original userids if there are no information on
+   them in LDAP. This option is rereaded on each new connected IMAP
+   client. */
+
+{ "convertuserid_dontignore_errors", 0, SWITCH }
+/* If enabled and there is an error while fetching userid, original
+   userids won't been returned even if 'convertuserid_allow_nonconverted'
+   option is enabled. This option is rereaded on each new connected IMAP
+   client. */
+
+{ "convertuserid_cache_db", NULL, STRING }
+/* Local cache backend for storing converted identifiers. If this option
+   is not set then cache will not be used. */
+
+{ "convertuserid_actual_timeout", 60, INT }
+/* A number of seconds local cache's records are in the 'actual' state
+   before timing out. If a record is in 'actual' state then queries
+   to LDAP for this record is not performed. This option is rereaded on
+   each new connected IMAP client.*/
+
+{ "convertuserid_localhost", "127.0.0.1", STRING }
+/* IP-address which ldapd processes are binding to. You will never
+   need to change the default value. */
+
+{ "convertuserid_udpport", 10001, INT }
+/* UDP port number where ldapd processes are listening on. ldapd is a
+   process which perfoms queries to LDAP. */
+
+{ "convertuserid_ldap_host", NULL, STRING }
+/* LDAP server host used by ldapd. */
+
+{ "convertuserid_ldap_port", 389, INT }
+/* LDAP server port used by ldapd. */
+
+{ "convertuserid_ldap_user", NULL, STRING }
+/* LDAP user used by ldapd. */
+
+{ "convertuserid_ldap_password", NULL, STRING }
+/* LDAP user's password used by ldapd. */
+
+{ "convertuserid_ldap_base", NULL, STRING }
+/* LDAP base used by ldapd. */
+
+{ "convertuserid_ldap_attr_int", "uid", STRING }
+/* Name of LDAP attribute storing internal names of users. */
+
+{ "convertuserid_ldap_attr_ext", "cn", STRING }
+/* Name of LDAP attribute storing external names of users. */
+
+{ "convertuserid_ldap_attr_domain", "maildomain", STRING }
+/* Name of LDAP attribute storing domain names of IMAP users. */
+
+{ "convertuserid_ldap_query_domains", 0, SWITCH }
+/* Query or not domain names via LDAP. Note: if virtdomains option is
+   enabled then this option doesn't play any role (it is enabled too). */
+
 /*
 .SH SEE ALSO
 .PP
diff -urN cyrus-imapd-2.2.12.old/lib/libconfig.c cyrus-imapd-2.2.12/lib/libconfig.c
--- cyrus-imapd-2.2.12.old/lib/libconfig.c	2004-05-22 07:45:54 +0400
+++ cyrus-imapd-2.2.12/lib/libconfig.c	2005-12-30 15:13:59 +0300
@@ -161,7 +161,10 @@
     if(alt_config) config_filename = xstrdup(alt_config);
     else config_filename = xstrdup(CONFIG_FILENAME);
 
-    if(!construct_hash_table(&confighash, CONFIGHASHSIZE, 1)) {
+    /* we don't use memory pool for this hash because we may delete
+       keys from it many times (deletions from pooled hash leak the
+       memory) */
+    if(!construct_hash_table(&confighash, CONFIGHASHSIZE, 0)) {
 	fatal("could not construct configuration hash table", EC_CONFIG);
     }
 
@@ -508,3 +511,409 @@
     }
     fclose(infile);
 }
+
+int config_template_compare(const char *optname, int optid, template_option *opts, int opts_len)
+{
+    int i;
+
+    for(i=0; i<opts_len; i++) {
+	switch(opts[i].type) {
+	case TEMPLATEOPT_TYPE_KNOWNOPT:
+	    if(optid==(int)opts[i].val)
+		return 0;
+	    break;
+	case TEMPLATEOPT_TYPE_EXACTMATCH:
+	    if(!strcmp((char *)opts[i].val, optname))
+		return 0;
+	    break;
+	case TEMPLATEOPT_TYPE_PREFIX:
+	    if(!strncmp((char *)opts[i].val, optname, strlen((char *)opts[i].val)))
+		return 0;
+	    break;
+	}
+    }
+    return 1;
+}
+
+static int config_reread_file(const char *filename, template_option *opts, int opts_len)
+{
+    enum opttype opt = IMAPOPT_ZERO;
+    int lineno = 0;
+    char buf[4096], errbuf[1024];
+    char *p, *q, *key, *fullkey, *srvkey, *val, *newval;
+    int service_specific;
+    int idlen = (config_ident ? strlen(config_ident) : 0);
+    FILE *infile;
+
+    if(!opts_len)
+	return 0;
+
+    /* read in config file */
+    infile = fopen(filename, "r");
+    if (!infile) {
+	strlcpy(buf, CYRUS_PATH, sizeof(buf));
+	strlcat(buf, filename, sizeof(buf));
+	infile = fopen(buf, "r");
+    }
+    if (!infile) {
+	syslog(LOG_ERR, "can't open configuration file %s: %s",filename, error_message(errno));
+	return -1;
+    }
+
+    /* check to see if we've already read this file */
+    if (hash_lookup(filename, &includehash)) {
+	syslog(LOG_ERR, "configuration file %s included twice", filename);
+	fclose(infile);
+	return -1;
+    }
+    else {
+	hash_insert(filename, (void*) 0xDEADBEEF, &includehash);
+    }
+    
+    while (fgets(buf, sizeof(buf), infile)) {
+	lineno++;
+
+	service_specific = 0;
+	
+	if (buf[0] && buf[strlen(buf)-1] == '\n') buf[strlen(buf)-1] = '\0';
+	for (p = buf; *p && isspace((int) *p); p++);
+	if (!*p || *p == '#') continue;
+
+	fullkey = key = p;
+	if (*p == '@') p++;  /* allow @ as the first char (for directives) */
+	while (*p && (isalnum((int) *p) || *p == '-' || *p == '_')) {
+	    if (isupper((unsigned char) *p)) *p = tolower((unsigned char) *p);
+	    p++;
+	}
+	if (*p != ':') {
+	    syslog(LOG_ERR,
+		   "invalid option name on line %d of configuration file %s",
+		    lineno, filename);
+	    fclose(infile);
+	    return -1;
+	}
+	*p++ = '\0';
+	
+	while (*p && isspace((int) *p)) p++;
+	
+	/* remove trailing whitespace */
+	for (q = p + strlen(p) - 1; q > p && isspace((int) *q); q--) {
+	    *q = '\0';
+	}
+	
+	if (!*p) {
+	    syslog(LOG_ERR,
+		   "empty option value on line %d of configuration file",
+		   lineno);
+	    fclose(infile);
+	    return -1;
+	}
+	
+	srvkey = NULL;
+
+	/* Look for directives */
+	if (key[0] == '@') {
+	    if (!strcasecmp(key, "@include")) {
+		if(config_reread_file(p,opts,opts_len)) {
+		    fclose(infile);
+		    return -1;
+		}
+		continue;
+	    }
+	    else {
+		syslog(LOG_ERR,
+		       "invalid directive on line %d of configuration file %s",
+		       lineno, filename);
+		fclose(infile);
+		return -1;
+	    }
+	}
+
+	/* Find if there is a <service>_ prefix */
+	if(config_ident && !strncasecmp(key, config_ident, idlen) 
+	   && key[idlen] == '_') {
+	    /* skip service_ prefix */
+	    srvkey = key + idlen + 1;
+	}
+	
+	/* look for a service_ prefix match in imapopts */
+	if(srvkey) {
+	    for (opt = IMAPOPT_ZERO; opt < IMAPOPT_LAST; opt++) {
+		if (!strcasecmp(imapopts[opt].optname, srvkey)) {
+		    key = srvkey;
+		    service_specific = 1;
+		    break;
+		}
+	    }
+	}
+	
+	/* Did not find a service_ specific match, try looking for an
+	 * exact match */
+	if(!service_specific) {
+	    for (opt = IMAPOPT_ZERO; opt < IMAPOPT_LAST; opt++) {
+		if (!strcasecmp(imapopts[opt].optname, key)) {
+		    break;
+		}
+	    }
+	}
+
+	/* If both of those loops failed, it goes verbatim into the
+	 * overflow hash table. */
+	
+	if (opt < IMAPOPT_LAST) {
+	    /* skip all options except those mached template */
+	    if(config_template_compare(imapopts[opt].optname,opt,opts,opts_len))
+		continue;
+
+	    /* Okay, we know about this configure option.
+	     * So first check that we have either
+	     *  1. not seen it
+	     *  2. seen its generic form, but this is a service specific form
+	     *
+	     *  If we have already seen a service-specific form, and this is
+	     *  a generic form, just skip it and don't moan.
+	     */
+	    if((imapopts[opt].seen == 1 && !service_specific) 
+	     ||(imapopts[opt].seen == 2 && service_specific)) {
+		syslog(LOG_ERR,
+		       "option '%s' was specified twice in config file (second occurance on line %d)",
+		       fullkey, lineno);
+		fclose(infile);
+		return -1;
+	    } else if(imapopts[opt].seen == 2 && !service_specific) {
+		continue;
+	    }
+
+	    /* If we've seen it already, we're replacing it, so we need
+	     * to free the current string if there is one */
+	    if(imapopts[opt].seen && imapopts[opt].t == OPT_STRING)
+		free((char *)imapopts[opt].val.s);
+
+            if(service_specific)
+		imapopts[opt].seen = 2;
+	    else
+		imapopts[opt].seen = 1;
+	    
+	    /* this is a known option */
+	    switch (imapopts[opt].t) {
+	    case OPT_STRING: 
+	    {		    
+		imapopts[opt].val.s = xstrdup(p);
+
+		if(opt == IMAPOPT_CONFIGDIRECTORY)
+		    config_dir = imapopts[opt].val.s;
+
+		break;
+	    }
+	    case OPT_INT:
+	    {
+		long val;
+		char *ptr;
+		
+		val = strtol(p, &ptr, 0);
+		if (!ptr || *ptr != '\0') {
+		    /* error during conversion */
+		    syslog(LOG_ERR,
+			   "non-integer value for %s in line %d",
+			   imapopts[opt].optname, lineno);
+		    fclose(infile);
+		    return -1;
+		}
+
+		imapopts[opt].val.i = val;
+		break;
+	    }
+	    case OPT_SWITCH:
+	    {
+		if (*p == '0' || *p == 'n' ||
+		    (*p == 'o' && p[1] == 'f') || *p == 'f') {
+		    imapopts[opt].val.b = 0;
+		}
+		else if (*p == '1' || *p == 'y' ||
+			 (*p == 'o' && p[1] == 'n') || *p == 't') {
+		    imapopts[opt].val.b = 1;
+		}
+		else {
+		    /* error during conversion */
+		    syslog(LOG_ERR,
+			   "non-switch value for %s in line %d",
+			   imapopts[opt].optname, lineno);
+		    fclose(infile);
+		    return -1;
+		}
+		break;
+	    }
+	    case OPT_ENUM:
+	    case OPT_STRINGLIST:
+	    {
+		const struct enum_option_s *e = imapopts[opt].enum_options;
+
+		if (imapopts[opt].t == OPT_ENUM) {
+		    /* normalize on/off values */
+		    if (!strcmp(p, "1") || !strcmp(p, "yes") ||
+			!strcmp(p, "t") || !strcmp(p, "true")) {
+			p = "on";
+		    } else if (!strcmp(p, "0") || !strcmp(p, "no") ||
+			       !strcmp(p, "f") || !strcmp(p, "false")) {
+			p = "off";
+		    }
+		}
+
+		while (e->name) {
+		    if (!strcmp(e->name, p)) break;
+		    e++;
+		}
+		if (e->name) {
+		    if (imapopts[opt].t == OPT_ENUM)
+			imapopts[opt].val.e = e->val;
+		    else
+			imapopts[opt].val.s = e->name;
+		} else {
+		    /* error during conversion */
+		    syslog(LOG_ERR,
+			   "invalid value for %s in line %d",
+			   imapopts[opt].optname, lineno);
+		    fclose(infile);
+		    return -1;
+		}
+		break;
+	    }
+	    case OPT_NOTOPT:
+	    default:
+		abort();
+	    }
+	} else {
+	    /* check to make sure it's valid for overflow */
+	    /* that is, partition names and anything that might be
+	     * used by SASL */
+/*
+  xxx this would be nice if it wasn't for other services who might be
+      sharing this config file and whose names we cannot predict
+
+	    if(strncasecmp(key,"sasl_",5)
+	    && strncasecmp(key,"partition-",10)) {
+		sprintf(errbuf,
+			"option '%s' is unknown on line %d of config file",
+			fullkey, lineno);
+		fatal(errbuf, EC_CONFIG);
+	    }
+*/
+
+	    /* skip all options except those mached template */
+	    if(config_template_compare(key,0,opts,opts_len))
+		continue;
+
+	    /* Put it in the overflow hash table */
+	    newval = xstrdup(p);
+	    val = hash_insert(key, newval, &confighash);
+	    if(val != newval) {
+		syslog(LOG_ERR,
+		       "option '%s' was specified twice in config file (second occurance on line %d)",
+		       fullkey, lineno);
+		fclose(infile);
+		return -1;
+	    }
+	}
+    }
+    fclose(infile);
+    return 0;
+}
+
+typedef struct _config_delete_cb_param {
+    template_option *opts;
+    int opts_len;
+} config_delete_cb_param;
+
+int config_delete_cb(char *key, void *data, void *param)
+{
+    if(!config_template_compare(
+	   (char *)key, 0,
+	   ((config_delete_cb_param *)param)->opts,
+	   ((config_delete_cb_param *)param)->opts_len)) {
+	free(data);
+	return -1;
+    }
+    return 0;
+}
+
+extern int config_reread(template_option *opts, int opts_len)
+{
+    enum opttype opt = IMAPOPT_ZERO;
+    config_delete_cb_param param;
+    int cur_templ;
+    int res;
+
+    if(!opts_len)
+	return 0;
+
+    /* remove options that mached template */
+    for (opt = IMAPOPT_ZERO; opt < IMAPOPT_LAST; opt++) {
+	if(imapopts[opt].seen) {
+	    /* just set default values for known options */
+	    if(!config_template_compare(imapopts[opt].optname,opt,opts,opts_len)) {
+		if(imapopts[opt].t == OPT_STRING)
+		    free((char *)imapopts[opt].val.s);
+		imapopts[opt].val = imapopts[opt].def;
+		imapopts[opt].seen = 0;
+	    }
+	}
+    }
+
+    /* check if we need to walk through all hashed options or we just
+       need to delete N hashed options */
+    for(cur_templ=0; cur_templ<opts_len; cur_templ++) {
+	if(opts[cur_templ].type==TEMPLATEOPT_TYPE_PREFIX)
+	    break;
+	else if(opts[cur_templ].type==TEMPLATEOPT_TYPE_EXACTMATCH) {
+	    void *data;
+	    
+	    /* try to delete exact match option (if it exists, it will
+	       be deleted) */
+	    if((data=hash_del((char *)opts[cur_templ].val, &confighash)))
+		free(data);
+	}
+    }
+
+    /* if we've found a prefix (non-exact) template than walk through
+       all hashed options */
+    if(cur_templ<opts_len) {
+	param.opts=opts;
+	param.opts_len=opts_len;
+
+	hash_walk(&confighash, config_delete_cb, &param);
+    }
+
+    /* now call config_reread_file() as in config_read() */
+    if(!construct_hash_table(&includehash, INCLUDEHASHSIZE, 1)) {
+	fatal("could not construct include file  hash table", EC_CONFIG);
+    }
+
+    res=config_reread_file(config_filename, opts, opts_len);
+
+    free_hash_table(&includehash, NULL);
+
+    if(res)
+	return res;
+
+    /* Note if we don't change variables below then thay can point to
+       freed memory. TODO: right work with IMAPOPT_DEFAULTPARTITION
+       option and with other partitions pathes is needed. */
+
+    /* look up mailbox hashing */
+    config_hashimapspool = config_getswitch(IMAPOPT_HASHIMAPSPOOL);
+
+    /* are we supporting virtual domains?  */
+    config_virtdomains = config_getenum(IMAPOPT_VIRTDOMAINS);
+    config_defdomain = config_getstring(IMAPOPT_DEFAULTDOMAIN);
+
+    /* look up the hostname we should present to the user */
+    config_servername = config_getstring(IMAPOPT_SERVERNAME);
+    if (!config_servername) {
+	config_servername = xmalloc(sizeof(char) * 256);
+	gethostname((char *) config_servername, 256);
+    }
+
+    config_mupdate_server = config_getstring(IMAPOPT_MUPDATE_SERVER);
+
+    return 0;
+}
diff -urN cyrus-imapd-2.2.12.old/lib/libconfig.h cyrus-imapd-2.2.12/lib/libconfig.h
--- cyrus-imapd-2.2.12.old/lib/libconfig.h	2003-12-29 23:22:55 +0300
+++ cyrus-imapd-2.2.12/lib/libconfig.h	2005-12-30 15:13:59 +0300
@@ -46,9 +46,20 @@
 #include "exitcodes.h"
 #include "imapopts.h"
 
+/* types for structure template_option */
+#define TEMPLATEOPT_TYPE_KNOWNOPT   0
+#define TEMPLATEOPT_TYPE_EXACTMATCH 1
+#define TEMPLATEOPT_TYPE_PREFIX     2
+
+typedef struct _template_option {
+    void *val;
+    int type;
+} template_option;
+
 /* these will assert() if they're called on the wrong type of
    option (imapopts.c) */
 extern void config_read(const char *alt_config);
+extern int config_reread(template_option *opts, int opts_len);
 extern const char *config_getstring(enum imapopt opt);
 extern int config_getint(enum imapopt opt);
 extern int config_getswitch(enum imapopt opt);
diff -urN cyrus-imapd-2.2.12.old/man/ldapd.8 cyrus-imapd-2.2.12/man/ldapd.8
--- cyrus-imapd-2.2.12.old/man/ldapd.8	1970-01-01 03:00:00 +0300
+++ cyrus-imapd-2.2.12/man/ldapd.8	2005-12-30 15:14:41 +0300
@@ -0,0 +1,46 @@
+.\" -*- nroff -*-
+.TH LDAPD 8 "Project Cyrus" CMU
+.SH NAME
+ldapd \- connector from IMAP server to LDAP
+.SH SYNOPSIS
+.B ldapd
+[
+.B \-C
+.I config-file
+]
+[
+.B \-n
+.I nproc
+|
+.B \-\-prefork
+.I nproc
+]
+.br
+.SH DESCRIPTION
+.I Ldapd
+is a process that performs queries from IMAP server to LDAP server.
+It accepts queries via UDP protocol and sends answers to callers.
+It can be invoked by
+.IR master (8)
+but it is possible to start \fIldapd\fR independently.
+If you want to start \fIldapd\fR via \fBmaster(8)\fR, you have to
+add launch rule to START section of
+.IR cyrus.conf (5)
+.PP
+.I Ldapd
+reads its configuration options out of the
+.IR imapd.conf (5)
+file unless specified otherwise by \fB-C\fR.
+.SH OPTIONS
+.TP
+.BI \-C " config-file"
+Read configuration options from \fIconfig-file\fR.
+.TP
+.BI \-n " nproc",\ \-\-prefork " nproc"
+The number of \fIldapd\fR processes to work simultaneously. The default is 1.
+.SH FILES
+.TP
+.B /etc/imapd.conf
+.SH SEE ALSO
+.PP
+\fBimapd.conf(5)\fR, \fBmaster(8)\fR
diff -urN cyrus-imapd-2.2.12.old/man/Makefile.in cyrus-imapd-2.2.12/man/Makefile.in
--- cyrus-imapd-2.2.12.old/man/Makefile.in	2004-03-30 19:18:41 +0400
+++ cyrus-imapd-2.2.12/man/Makefile.in	2005-12-30 15:14:00 +0300
@@ -62,11 +62,12 @@
 	$(srcdir)/fud.8 $(srcdir)/imapd.8 $(srcdir)/pop3d.8 $(srcdir)/quota.8 \
 	$(srcdir)/reconstruct.8 $(srcdir)/rmnews.8 $(srcdir)/syncnews.8 \
 	$(srcdir)/mbpath.8 $(srcdir)/timsieved.8 $(srcdir)/master.8 \
-	$(srcdir)/lmtpd.8 $(srcdir)/idled.8 $(srcdir)/ctl_mboxlist.8 \
-	$(srcdir)/ctl_deliver.8 $(srcdir)/ctl_cyrusdb.8 $(srcdir)/ipurge.8 \
-	$(srcdir)/tls_prune.8 $(srcdir)/squatter.8 $(srcdir)/cvt_cyrusdb.8 \
-	$(srcdir)/notifyd.8 $(srcdir)/chk_cyrus.8 $(srcdir)/mbexamine.8 \
-	$(srcdir)/nntpd.8 $(srcdir)/fetchnews.8 $(srcdir)/smmapd.8
+	$(srcdir)/ldapd.8 $(srcdir)/lmtpd.8 $(srcdir)/idled.8 \
+	$(srcdir)/ctl_mboxlist.8 $(srcdir)/ctl_deliver.8 \
+	$(srcdir)/ctl_cyrusdb.8 $(srcdir)/ipurge.8 $(srcdir)/tls_prune.8 \
+	$(srcdir)/squatter.8 $(srcdir)/cvt_cyrusdb.8 $(srcdir)/notifyd.8 \
+	$(srcdir)/chk_cyrus.8 $(srcdir)/mbexamine.8 $(srcdir)/nntpd.8 \
+	$(srcdir)/fetchnews.8 $(srcdir)/smmapd.8
 
 all: $(MAN1) $(MAN3) $(MAN5) $(MAN8)
 
diff -urN cyrus-imapd-2.2.12.old/man/master.8 cyrus-imapd-2.2.12/man/master.8
--- cyrus-imapd-2.2.12.old/man/master.8	2004-12-17 19:32:23 +0300
+++ cyrus-imapd-2.2.12/man/master.8	2005-12-30 15:14:00 +0300
@@ -152,4 +152,5 @@
 .SH SEE ALSO
 .PP
 \fBcyrus.conf(5)\fR, \fBimapd.conf(5)\fR, \fBimapd(8)\fR,
-\fBpop3d(8)\fR, \fBlmtpd(8)\fR, \fBtimsieved(8)\fR, \fBidled(8)\fR
+\fBpop3d(8)\fR, \fBldapd(8)\fR, \fBlmtpd(8)\fR,
+\fBtimsieved(8)\fR, \fBidled(8)\fR
diff -urN cyrus-imapd-2.2.12.old/master/conf/cmu-backend.conf cyrus-imapd-2.2.12/master/conf/cmu-backend.conf
--- cyrus-imapd-2.2.12.old/master/conf/cmu-backend.conf	2003-10-22 22:03:10 +0400
+++ cyrus-imapd-2.2.12/master/conf/cmu-backend.conf	2005-12-30 15:14:00 +0300
@@ -6,6 +6,8 @@
 
   recover	cmd="ctl_cyrusdb -r"
   mupdatepush   cmd="ctl_mboxlist -m"
+  # this is only necessary if using convertuserid extension
+#  ldapd		cmd="ldapd -n 5"
 }
 
 # UNIX sockets start with a slash and are put into /var/imap/sockets
diff -urN cyrus-imapd-2.2.12.old/master/conf/cmu-frontend.conf cyrus-imapd-2.2.12/master/conf/cmu-frontend.conf
--- cyrus-imapd-2.2.12.old/master/conf/cmu-frontend.conf	2003-10-22 22:03:10 +0400
+++ cyrus-imapd-2.2.12/master/conf/cmu-frontend.conf	2005-12-30 15:14:00 +0300
@@ -2,6 +2,8 @@
   auth		cmd="/usr/local/bin/ksrvtgt -l 3600 imap @SHORTHOST@ ANDREW.CMU.EDU /imap/conf/srvtab"
 
   mboxlist	cmd="ctl_cyrusdb -r"
+  # this is only necessary if using convertuserid extension
+#  ldapd		cmd="ldapd -n 5"
 }
 
 # UNIX sockets start with a slash and are put into /var/imap/sockets
diff -urN cyrus-imapd-2.2.12.old/master/conf/normal.conf cyrus-imapd-2.2.12/master/conf/normal.conf
--- cyrus-imapd-2.2.12.old/master/conf/normal.conf	2003-10-22 22:03:10 +0400
+++ cyrus-imapd-2.2.12/master/conf/normal.conf	2005-12-30 15:14:00 +0300
@@ -6,6 +6,8 @@
 
   # this is only necessary if using idled for IMAP IDLE
 #  idled		cmd="idled"
+  # this is only necessary if using convertuserid extension
+#  ldapd		cmd="ldapd -n 5"
 }
 
 # UNIX sockets start with a slash and are put into /var/imap/socket
diff -urN cyrus-imapd-2.2.12.old/master/conf/prefork.conf cyrus-imapd-2.2.12/master/conf/prefork.conf
--- cyrus-imapd-2.2.12.old/master/conf/prefork.conf	2003-10-22 22:03:10 +0400
+++ cyrus-imapd-2.2.12/master/conf/prefork.conf	2005-12-30 15:14:00 +0300
@@ -6,6 +6,8 @@
 
   # this is only necessary if using idled for IMAP IDLE
 #  idled		cmd="idled"
+  # this is only necessary if using convertuserid extension
+#  ldapd		cmd="ldapd -n 5"
 }
 
 # UNIX sockets start with a slash and are put into /var/imap/sockets
diff -urN cyrus-imapd-2.2.12.old/master/conf/small.conf cyrus-imapd-2.2.12/master/conf/small.conf
--- cyrus-imapd-2.2.12.old/master/conf/small.conf	2002-10-02 00:46:01 +0400
+++ cyrus-imapd-2.2.12/master/conf/small.conf	2005-12-30 15:14:00 +0300
@@ -6,6 +6,8 @@
 
   # this is only necessary if using idled for IMAP IDLE
 #  idled		cmd="idled"
+  # this is only necessary if using convertuserid extension
+#  ldapd		cmd="ldapd -n 5"
 }
 
 # UNIX sockets start with a slash and are put into /var/imap/sockets
diff -urN cyrus-imapd-2.2.12.old/notifyd/Makefile.in cyrus-imapd-2.2.12/notifyd/Makefile.in
--- cyrus-imapd-2.2.12.old/notifyd/Makefile.in	2005-12-30 12:55:59 +0300
+++ cyrus-imapd-2.2.12/notifyd/Makefile.in	2005-12-30 15:14:00 +0300
@@ -72,7 +72,7 @@
 SIEVE_LIBS = @SIEVE_LIBS@
 IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
 LIB_WRAP = @LIB_WRAP@
-LIBS = @ZEPHYR_LIBS@ @LIBS@ $(IMAP_COM_ERR_LIBS)
+LIBS = @ZEPHYR_LIBS@ @LIBS@ $(IMAP_COM_ERR_LIBS) -lredblack -lldap
 DEPLIBS=../imap/mutex_fake.o ../imap/libimap.a $(SIEVE_LIBS) ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
 
 PURIFY=/usr/local/bin/purify
diff -urN cyrus-imapd-2.2.12.old/ptclient/Makefile.in cyrus-imapd-2.2.12/ptclient/Makefile.in
--- cyrus-imapd-2.2.12.old/ptclient/Makefile.in	2005-12-30 12:55:56 +0300
+++ cyrus-imapd-2.2.12/ptclient/Makefile.in	2005-12-30 15:14:00 +0300
@@ -58,7 +58,7 @@
 AFS_LIBS = @AFS_LIBS@
 IMAP_LIBS = @IMAP_LIBS@ @LIB_RT@
 SIEVE_LIBS = @SIEVE_LIBS@
-LIBS = $(IMAP_LIBS) @COM_ERR_LIBS@
+LIBS = $(IMAP_LIBS) @COM_ERR_LIBS@ -lredblack -lldap
 LIB_SASL = @LIB_SASL@
 LIB_WRAP = @LIB_WRAP@
 DEPLIBS = ../imap/libimap.a $(SIEVE_LIBS) ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@ 
diff -urN cyrus-imapd-2.2.12.old/README.convertuserid cyrus-imapd-2.2.12/README.convertuserid
--- cyrus-imapd-2.2.12.old/README.convertuserid	1970-01-01 03:00:00 +0300
+++ cyrus-imapd-2.2.12/README.convertuserid	2005-12-30 15:14:51 +0300
@@ -0,0 +1,14 @@
+Cyrus IMAP convertuserid patch
+-------------------------------
+
+This patch is needed to add ability to the server to hide
+real users indentifiers and to replace them to other ones
+which are got from LDAP.
+
+Steps you need to do to get convertuserid worked:
+1. Build the server with --enable-convertuserid 'configure' option;
+2. Set converuserid* options in imapd.conf. See imapd.conf(5)
+   for details. The default action (without any converuserid*
+   option set) is "don't convert";
+3. Add "ldapd" in START section of cyrus.conf. See ldapd(8) for
+   details.
diff -urN cyrus-imapd-2.2.12.old/timsieved/Makefile.in cyrus-imapd-2.2.12/timsieved/Makefile.in
--- cyrus-imapd-2.2.12.old/timsieved/Makefile.in	2004-05-28 22:03:10 +0400
+++ cyrus-imapd-2.2.12/timsieved/Makefile.in	2005-12-30 15:14:01 +0300
@@ -71,7 +71,7 @@
 IMAP_LIBS = @IMAP_LIBS@ @LIB_RT@
 IMAP_COM_ERR_LIBS = @IMAP_COM_ERR_LIBS@
 LIB_WRAP = @LIB_WRAP@
-LIBS = $(IMAP_COM_ERR_LIBS)
+LIBS = $(IMAP_COM_ERR_LIBS) -lredblack -lldap
 DEPLIBS=../sieve/libsieve.a ../imap/mutex_fake.o ../imap/libimap.a ../lib/libcyrus.a ../lib/libcyrus_min.a @DEPLIBS@
 
 PURIFY=/usr/local/bin/purify
diff -urN cyrus-imapd-2.2.12.old/tools/config2header cyrus-imapd-2.2.12/tools/config2header
--- cyrus-imapd-2.2.12.old/tools/config2header	2005-12-30 12:56:05 +0300
+++ cyrus-imapd-2.2.12/tools/config2header	2005-12-30 15:14:01 +0300
@@ -126,7 +126,7 @@
 
 struct imapopt_s imapopts[] =
 {
-  { IMAPOPT_ZERO, "", 0, { NULL }, OPT_NOTOPT, {  { NULL, IMAP_ENUM_ZERO } } },
+  { IMAPOPT_ZERO, "", 0, { NULL }, { NULL }, OPT_NOTOPT, {  { NULL, IMAP_ENUM_ZERO } } },
 EOF
     ;
 
@@ -204,7 +204,7 @@
 			: "{(void*)$2}";
 	}
 
-	print CFILE "  { IMAPOPT_", uc($opt), ", \"$1\", 0, $def, OPT_$3, { $enums { NULL, IMAP_ENUM_ZERO } } },\n";
+	print CFILE "  { IMAPOPT_", uc($opt), ", \"$1\", 0, $def, $def, OPT_$3, { $enums { NULL, IMAP_ENUM_ZERO } } },\n";
     } else {
 	#chomp;
 	#print "rejected '$_'\n";
@@ -251,6 +251,7 @@
     const char *optname;
     int seen;
     union config_value val;
+    union config_value def;
     const enum opttype t;
 EOF
 ;
@@ -265,7 +266,7 @@
     ;
 
 print CFILE <<EOF
-  { IMAPOPT_LAST, NULL, 0, { NULL }, OPT_NOTOPT, {  { NULL, IMAP_ENUM_ZERO } } }
+  { IMAPOPT_LAST, NULL, 0, { NULL }, { NULL }, OPT_NOTOPT, {  { NULL, IMAP_ENUM_ZERO } } }
 };
 
 /* c code goes here */
