? cmulocal
? config.h.in
? stamp-h.in
? Makefile.in
? configure
? config.log
? config.h
? adiff
? libtool
? config.status
? stamp-h
? Makefile
? static.diff
? aclocal.m4
? config.cache
? lib/Makefile
? lib/Makefile.in
? lib/test.s
? lib/test.c
? lib/a.out
? lib/staticopen.c
? lib/Makefile.am2
? lib/common.lo
? lib/saslutil.lo
? lib/server.lo
? lib/client.lo
? lib/md5.lo
? lib/dlopen.lo
? lib/checkpw.lo
? lib/config.lo
? lib/db_gdbm.lo
? lib/.libs
? lib/libsasl.la
? plugins/Makefile
? plugins/cram.lo
? plugins/.libs
? plugins/plain.lo
? plugins/libcrammd5.la
? plugins/digestmd5.lo
? plugins/libdigestmd5.la
? plugins/libgssapiv2.la
? plugins/anonymous.lo
? plugins/libanonymous.la
? plugins/libplain.la
? plugins/srp.lo
? plugins/libsrp.la
? plugins/Makefile.in
? plugins/stk48671
Index: COPYING
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/COPYING,v
retrieving revision 1.4
diff -u -r1.4 COPYING
--- COPYING	2000/03/07 05:19:50	1.4
+++ COPYING	2001/04/25 00:33:27
@@ -1,43 +1,20 @@
-/* CMU libsasl
- * Tim Martin
- * Rob Earhart
- */
-/* 
- * Copyright (c) 2000 Carnegie Mellon University.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The name "Carnegie Mellon University" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For permission or any other legal
- *    details, please contact  
- *      Office of Technology Transfer
- *      Carnegie Mellon University
- *      5000 Forbes Avenue
- *      Pittsburgh, PA  15213-3890
- *      (412) 268-4387, fax: (412) 268-7395
- *      tech-transfer@andrew.cmu.edu
- *
- * 4. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by Computing Services
- *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
- *
- * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
- * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
- * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
- * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
- * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
- * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
+        Copyright 1998 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon University
+not be used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
+IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR ANY SPECIAL,
+INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR 
+PERFORMANCE OF THIS SOFTWARE.
+
Index: README.andrew
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/README.andrew,v
retrieving revision 1.12
diff -u -r1.12 README.andrew
--- README.andrew	2000/04/13 19:49:40	1.12
+++ README.andrew	2001/04/25 00:33:27
@@ -1,122 +1,71 @@
-#!/bin/sh
-smake -gnu init install
-exit 0
-
-To wash, "smake -gnu wash install".
-
-Use the vendor cc if possible on platforms which have purify (it has
-problems dealing with code produced by gcc 2.8.1).
-
-	On IRIX, setenv CC cc and setenv CFLAGS -O2 - no -sopt for now
-	On Solaris, setenv CC cc and setenv CFLAGS -fast
-
-----
-To release:
-- run testsuite successfully
-- increment version in configure.in
-- synchronize version with include/sasl.h and win32/include/config.h
-- modify library versions in lib/Makefile.am and plugins/Makefile.am
-  accordingly (see libtool info file for details)
-- add release notice to ChangeLog
-- add user visible changes to NEWS
-
-- tag the CVS repository with sasl-Major_Minor_Revision
-- to make tarball: make distcheck
-- compile on non-andrew machine
-
-- copy to /afs/andrew/system/archive/cmu/anonftp/pub/cyrus-mail
-- sign the distribution (pgp -sb foo.tar.gz)
-
-- update asg.web.cmu.edu
-- announce to:
-    info-cyrus@andrew.cmu.edu
-    cyrus-sasl@lists.andrew.cmu.edu
-
-    comp.os.linux.announce
-    comp.mail.imap
-    comp.mail.sendmail after 8.10 comes out
-    
-    www.freshmeat.net
-
-sample announcement:
-
-To: cyrus-sasl@lists.andrew.cmu.edu, info-cyrus@andrew.cmu.edu
-Subject: Beta release of Cyrus SASL 1.5.18
-BCC: tmartin+sent@cyrus.andrew.cmu.edu
---text follows this line--
-
-I'd like to announce the beta release of Cyrus SASL 1.5.18 on
-ftp.andrew.cmu.edu. This version includes bug fixes, a java SASL
-library that conforms to draft-weltman-java-sasl-02.txt, and man pages
-for all functions. This is a beta release because it has not been
-thoroughly tested against all applications that make use of it.
-
-Please send any feedback either to cyrus-sasl@lists.andrew.cmu.edu
-(public list) or to cyrus-bugs@andrew.cmu.edu.
-
-Download at:
-ftp://ftp.andrew.cmu.edu/pub/cyrus-mail/BETA/cyrus-sasl-1.5.18.tar.gz
-
-Thanks,
-Tim Martin
-
-
-To: post+comp.mail.imap@andrew.cmu.edu
-Subject: Cyrus SASL 1.5.18 released (authentication library)
-BCC: tmartin+sent@cyrus.andrew.cmu.edu
---text follows this line--
-
-I'm pleased to announce the release of the Cyrus SASL library, version
-1.5.18.  This represents primarily a bugfix release with a few new
-features, such as a java SASL library conforming to
-draft-weltman-java-sasl-02.txt, and man pages for all functions.
-  
-The Cyrus SASL library is a generic library for SASL authentication,
-as used in SMTP and IMAP protocols.  It's used for authentication by
-the Cyrus IMAP server as well as the Sendmail 8.10 release.
-  
-Make sure you read the README file.
-
-Download at:
-ftp://ftp.andrew.cmu.edu/pub/cyrus-mail/BETA/cyrus-sasl-1.5.18.tar.gz
-
-  
-Please report bugs to cyrus-bugs@andrew.cmu.edu.
-  
-Join the cyrus-sasl@lists.andrew.cmu.edu mailing list by
-cyrus-sasl-request@lists.andrew.cmu.edu
-  
-Thanks,
-Tim Martin
-
-
-X-Mailer: BatIMail version 3.2
-To: post+comp.mail.sendmail@andrew.cmu.edu
-Subject: Cyrus SASL 1.5.18 released (authentication library)
-BCC: tmartin+sent@cyrus.andrew.cmu.edu
-Mime-Version: 1.0 (generated by tm-edit 7.108)
-Content-Type: text/plain; charset=US-ASCII
---text follows this line--
-
-I'm pleased to announce the release of the Cyrus SASL library, version
-1.5.18.  This represents primarily a bugfix release with a few new
-features, such as a java SASL library conforming to
-draft-weltman-java-sasl-02.txt, and man pages for all functions.  
-  
-The Cyrus SASL library is a generic library for SASL
-authentication. It's used for authentication by the Sendmail 8.10
-release as well as the Cyrus IMAP server.
-  
-Make sure you read the README file if you are upgrading.
-
-Please report bugs to cyrus-bugs@andrew.cmu.edu.
-  
-Join the cyrus-sasl@lists.andrew.cmu.edu mailing list by
-cyrus-sasl-request@lists.andrew.cmu.edu
-
-Download at:
-ftp://ftp.andrew.cmu.edu/pub/cyrus-mail/BETA/cyrus-sasl-1.5.18.tar.gz
-  
-  
-Thanks,
-Tim Martin
\ No newline at end of file
+This is a collection of autoconf macros which've been written by
+various people at CMU.  To use it, use "aclocal -I cmulocal" (after
+the first time, automake should automatically use the -I cmulocal, if
+you've called CMU_INIT_AUTOMAKE in configure.in).
+
+CMU_INIT_AUTOMAKE
+  If you use automake, you should call this after AM_INIT_AUTOMAKE.
+  It adds "-I cmulocal" to the aclocal command line, so that when
+  automake runs aclocal, aclocal'll continue to pick up these macros.
+
+CMU_ADD_LIBPATH
+  Add -L(arg), and possibly -R(arg) (or whatever the runpath is) to 
+  LDFLAGS.
+
+CMU_ADD_LIBPATH_TO
+  Likewise to above, except adds it to the specified variable (arg 2).
+
+CMU_GUESS_RUNPATH_SWITCH
+  Attempts to guess what the runpath switch is (-R or whatever).
+
+CMU_COMERR
+  Requires that com_err exist in the collection (at CMU, do this by
+  running "cvs checkout com_err", and adding com_err to DIST_SUBDIRS
+  in your Makefile.am).
+
+  It sets the output variable COMPILE_ET to the compile_et program to
+  use, and adds the appropriate paths to LDFLAGS and CPPFLAGS.
+
+  It does *not* add -lcom_err to LIBS (this would cause later library
+  checks to fail if com_err needs to be built), so Makefiles need to
+  explicitly add -lcom_err (which, after all, should always exist as
+  long as the com_err compile doesn't blow up).  Makefiles should do
+  this by using LIB_COMERR, which will substitute to the appropriate
+  magic to use to grab the library.  (This may involve a libtool archive;
+  you should be using libtool to link your program if you distribute
+  libraries with it that the program may link against).
+
+  Note that com_err will only be compiled if the configure script
+  can't find compile_et or libcom_err; if the system already has them,
+  the configure script will use the system installation (although, due
+  to some autoconf wonkiness, com_err will still be configured; it just
+  won't show up in the @subdirs@ expansion).
+
+CMU_NANA
+  Adds --with-nana, set by default; if set, attempts to link against
+  libnana.  If not set, or if libnana is unavailable, or if we're not
+  using gcc, it defines WITHOUT_NANA.
+
+CMU_PROG_LIBTOOL
+  Just like AM_PROG_LIBTOOL, except it performs a couple little hacks
+  to make sure that things don't break on picky vendor compilers
+  which whine about empty translation units.
+
+CMU_PTHREADS
+  This attempts to link against libpthread (failing if it can't be found),
+  and attempts to do any system-specific setup required for thread
+  support (for example, most things want _REENTRANT to be defined,
+  but Solaris wants _POSIX_PTHREAD_SEMANTICS and __EXTENSIONS__, IRIX
+  wants to see _SGI_REENTRANT_FUNCTIONS, etc).
+
+CMU_SASL
+  This tries to find a SASL library, and calls AC_SUBST on LIB_SASL
+  if it finds one, or tells the user to go ftp it if it doesn't exist.
+
+  Provides --with-sasldir.
+
+CMU_KRB4
+  This attempts to find Kerberos 4 libraries and set up CFLAGS and LIBS
+  appropriately. It also updates and substitutes RPATH for shared library 
+  stuff.
+
Index: acconfig.h
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/acconfig.h,v
retrieving revision 1.25
diff -u -r1.25 acconfig.h
--- acconfig.h	2001/01/04 21:20:45	1.25
+++ acconfig.h	2001/04/25 00:33:27
@@ -61,6 +61,16 @@
 #undef SASL_NDBM
 #undef SASL_BERKELEYDB
 
+/* SASL mechanisms */
+#undef MECH_ENABLED_ANONYMOUS
+#undef MECH_ENABLED_CRAM_MD5
+#undef MECH_ENABLED_DIGEST_MD5
+#undef MECH_ENABLED_KERBEROS_V4
+#undef MECH_ENABLED_GSSAPI
+#undef MECH_ENABLED_PLAIN
+#undef MECH_ENABLED_LOGIN
+#undef MECH_ENABLED_SRP
+
 /* This is where plugins will live at runtime */
 #undef PLUGINDIR
 
Index: configure.in
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/configure.in,v
retrieving revision 1.105
diff -u -r1.105 configure.in
--- configure.in	2001/03/24 01:47:27	1.105
+++ configure.in	2001/04/25 00:33:27
@@ -220,23 +220,28 @@
 case "$dblib" in
   gdbm) 
     SASL_DB_BACKEND="db_${dblib}.lo"
+    SASL_DB_BACKEND_STATIC="db_${dblib}.o"
     AC_DEFINE(SASL_GDBM)
     ;;
   ndbm)
     SASL_DB_BACKEND="db_${dblib}.lo"
+    SASL_DB_BACKEND_STATIC="db_${dblib}.o"
     AC_DEFINE(SASL_NDBM)
     ;;
   berkeley)
     SASL_DB_BACKEND="db_${dblib}.lo"
+    SASL_DB_BACKEND_STATIC="db_${dblib}.o"
     AC_DEFINE(SASL_BERKELEYDB)
     ;;
   *)
     AC_MSG_WARN([Disabling SASL authentication database support])
     SASL_DB_BACKEND="db_none.lo"
+    SASL_DB_BACKEND_STATIC="db_none.o"
     SASL_DB_LIB=""
     ;;
 esac
 AC_SUBST(SASL_DB_BACKEND)
+AC_SUBST(SASL_DB_BACKEND_STATIC)
 AC_SUBST(SASL_DB_LIB)
 
 AC_CHECK_LIB(dl, dlopen, SASL_DL_LIB="-ldl", SASL_DL_LIB="")
@@ -331,6 +336,9 @@
 if test "$cram" != no; then
   AC_MSG_RESULT(enabled)
   SASL_MECHS="$SASL_MECHS libcrammd5.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS libcrammd5.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/cram.o"
+  AC_DEFINE(MECH_ENABLED_CRAM_MD5)
 else
   AC_MSG_RESULT(disabled)
 fi
@@ -345,6 +353,8 @@
 if test "$scram" != no; then
   AC_MSG_RESULT(enabled)
   SASL_MECHS="$SASL_MECHS libscrammd5.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS libscrammd5.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/scram.o"
 else
   AC_MSG_RESULT(disabled)
 fi
@@ -410,6 +420,9 @@
 if test "$digest" != no; then
   AC_MSG_RESULT(enabled)
   SASL_MECHS="$SASL_MECHS libdigestmd5.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS libdigestmd5.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/digestmd5.o"
+  AC_DEFINE(MECH_ENABLED_DIGEST_MD5)
 else
   AC_MSG_RESULT(disabled)
 fi
@@ -462,6 +475,9 @@
 if test "$krb4" != no; then
   AC_MSG_RESULT(enabled)
   SASL_MECHS="$SASL_MECHS libkerberos4.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS libkerberos4.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/kerberos4.o"
+  AC_DEFINE(MECH_ENABLED_KERBEROS_V4)
   AC_DEFINE(HAVE_KRB)
   SASL_KRB_LIB="-lkrb -ldes $COM_ERR"
   AC_SUBST(SASL_KRB_LIB)
@@ -531,6 +547,9 @@
   AC_CHECK_LIB(ndbm,dbm_open,GSSAPIBASE_LIBS="$GSSAPIBASE_LIBS -lndbm")
   AC_CHECK_LIB(resolv,res_search,GSSAPIBASE_LIBS="$GSSAPIBASE_LIBS -lresolv")
   SASL_MECHS="$SASL_MECHS libgssapiv2.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS libgssapiv2.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/gssapi.o"
+  AC_DEFINE(MECH_ENABLED_GSSAPI)
 
   cmu_save_LIBS="$LIBS"
   LIBS="$LIBS $GSSAPIBASE_LIBS"
@@ -551,6 +570,9 @@
 if test "$anon" != no; then
   AC_MSG_RESULT(enabled)
   SASL_MECHS="$SASL_MECHS libanonymous.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS libanonymous.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/anonymous.o"
+  AC_DEFINE(MECH_ENABLED_ANONYMOUS)
 else
   AC_MSG_RESULT(disabled)
 fi
@@ -583,6 +605,9 @@
 if test "$plain" != no; then
   AC_MSG_RESULT(enabled)
   SASL_MECHS="$SASL_MECHS libplain.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS libplain.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/plain.o"
+  AC_DEFINE(MECH_ENABLED_PLAIN)
 else
   AC_MSG_RESULT(disabled)
 fi
@@ -596,6 +621,9 @@
 if test "$login" != no; then
   AC_MSG_RESULT(enabled)
   SASL_MECHS="$SASL_MECHS liblogin.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS liblogin.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/login.o"
+  AC_DEFINE(MECH_ENABLED_LOGIN)
 else
   AC_MSG_RESULT(disabled)
 fi
@@ -603,20 +631,25 @@
 dnl SRP
 AC_ARG_ENABLE(srp, [  --enable-srp           enable SRP authentication [no] ],
   srp=$enableval,
-  srp=no)
+  srp=yes)
 
 AC_MSG_CHECKING(SRP)
 if test "$srp" != no; then
-  AC_ERROR([This is pre-alpha. You probably don't want to use this])
+#  AC_ERROR([This is pre-alpha. You probably don't want to use this])
   AC_MSG_RESULT(enabled)
   SRP_LIBS="-lgmp -lcrypto"
   AC_SUBST(SRP_LIBS)
   SASL_MECHS="$SASL_MECHS libsrp.la"
+  SASL_STATIC_MECHS="$SASL_STATIC_MECHS libsrp.a"
+  SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/srp.o"
+  AC_DEFINE(MECH_ENABLED_SRP)
 else
   AC_MSG_RESULT(disabled)
 fi
 
 AC_SUBST(SASL_MECHS)
+AC_SUBST(SASL_STATIC_MECHS)
+AC_SUBST(SASL_STATIC_OBJS)
 
 
 AC_ARG_WITH(plugindir, [  --with-plugindir=DIR    set the directory where plugins will
@@ -688,8 +721,8 @@
 
 AC_OUTPUT(Makefile
 include/Makefile
-lib/Makefile
 plugins/Makefile
+lib/Makefile
 utils/Makefile
 doc/Makefile
 sample/Makefile
Index: lib/Makefile.am
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/lib/Makefile.am,v
retrieving revision 1.41
diff -u -r1.41 Makefile.am
--- Makefile.am	2001/03/29 21:58:49	1.41
+++ Makefile.am	2001/04/25 00:33:27
@@ -47,6 +47,7 @@
 
 EXTRA_DIST = saslint.h windlopen.c
 
+#shared version
 lib_LTLIBRARIES = libsasl.la
 
 libsasl_la_SOURCES = common.c saslutil.c server.c client.c md5.c dlopen.c checkpw.c config.c
@@ -55,4 +56,13 @@
 libsasl_la_DEPENDENCIES = $(SASL_DB_BACKEND) @LTLIBOBJS@
 libsasl_la_LIBADD = @LTLIBOBJS@ $(SASL_DB_BACKEND) $(SASL_DB_LIB) $(SASL_DL_LIB) $(PLAIN_LIBS) $(LIB_SOCKET)
 # PLAIN_LIBS are linked in for sasl_checkpass
+
+#static version
+lib_LIBRARIES = libsasl.a
+
+libsasl_a_SOURCES = common.c saslutil.c server.c client.c md5.c staticopen.c checkpw.c config.c
+EXTRA_libsasl_a_SOURCES = db_none.c db_ndbm.c db_gdbm.c db_berkeley.c db_testw32.c
+libsasl_a_DEPENDENCIES = $(SASL_DB_BACKEND_STATIC)
+
+libsasl_a_LIBADD = @SASL_STATIC_OBJS@ $(SASL_DB_BACKEND_STATIC)
 
Index: lib/dlopen.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/lib/dlopen.c,v
retrieving revision 1.32
diff -u -r1.32 dlopen.c
--- dlopen.c	2000/08/14 01:44:02	1.32
+++ dlopen.c	2001/04/25 00:33:27
@@ -150,6 +150,7 @@
 /* loads a single mechanism */
 int _sasl_get_plugin(const char *file,
 		     const char *entryname,
+		     const char *altentryname,
 		     const sasl_callback_t *verifyfile_cb,
 		     void **entrypointptr,
 		     void **libraryptr)
@@ -160,8 +161,10 @@
     void *entry_point;
 #if __OpenBSD__
     char adj_entryname[1024];
+    char adj_altentryname[1024];
 #else
 #define adj_entryname entryname
+#define adj_altentryname altentryname
 #endif
 
     r = ((sasl_verifyfile_t *)(verifyfile_cb->proc))
@@ -181,10 +184,19 @@
 
 #if __OpenBSD__
     snprintf(adj_entryname, sizeof adj_entryname, "_%s", entryname);
+    snprintf(adj_altentryname, sizeof adj_altentryname, "_%s", altentryname);
 #endif
 
+    /* first the standard entry point */
     entry_point = NULL;
     entry_point = dlsym(library, adj_entryname);
+
+    /* if that fails and we have an alternate point try that */
+    if ((entry_point == NULL) && (adj_altentryname)) {
+	entry_point = NULL;
+	entry_point = dlsym(library, adj_altentryname);
+    }
+
     if (entry_point == NULL) {
 	_sasl_log(NULL, SASL_LOG_ERR, NULL, 0, 0,
 		  "unable to get entry point %s in %s: %s", adj_entryname,
@@ -256,6 +268,8 @@
 		void *library;
 		void *entry_point;
 		char name[PATH_MAX];
+		char altentrypoint[1024];
+		char *dot;
 
 		length = NAMLEN(dir);
 		if (length < 4) 
@@ -270,8 +284,19 @@
 	
 		strcpy(tmp,prefix);
 		strcat(tmp,name);
-	
-		result = _sasl_get_plugin(tmp, entryname,
+
+		/* create the alternate entry point */
+		strncpy(altentrypoint,name+3, sizeof(altentrypoint)-1);
+		dot = strchr(altentrypoint,'.');
+		if (dot) *dot = '\0';
+		strcat(altentrypoint,"_");
+		strcat(altentrypoint,entryname);		
+
+		/* Look for two entry points:
+		 * sasl_(server|client)_plug_init
+		 * <mech>_sasl_(server|client)_plug_init
+		 */
+		result = _sasl_get_plugin(tmp, entryname, altentrypoint,
 					  verifyfile_cb,
 					  &entry_point, &library);
 
Index: lib/md5.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/lib/md5.c,v
retrieving revision 1.7
diff -u -r1.7 md5.c
--- md5.c	1999/03/29 21:26:14	1.7
+++ md5.c	2001/04/25 00:33:28
@@ -153,8 +153,7 @@
 
 /* MD5 finalization. Ends an MD5 message-digest operation, writing the
        the message digest and zeroizing the context. 
-
-        */
+*/
 
 void MD5Final (digest, context)
 unsigned char digest[16]; /* message digest */
@@ -182,7 +181,7 @@
          /* Zeroize sensitive information.
 
 */
-       MD5_memset ((POINTER)context, 0, sizeof (*context)); 
+	 MD5_memset ((POINTER)context, 0, sizeof (*context));
 }
 
 /* MD5 basic transformation. Transforms state based on block.
Index: lib/saslint.h
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/lib/saslint.h,v
retrieving revision 1.33
diff -u -r1.33 saslint.h
--- saslint.h	2000/08/17 22:14:25	1.33
+++ saslint.h	2001/04/25 00:33:28
@@ -57,6 +57,7 @@
 			       int (*add_plugin)(void *,void *));
 extern int _sasl_get_plugin(const char *file,
 			    const char *entryname,
+			    const char *altentryname,
 			    const sasl_callback_t *verifyfile_callback,
 			    void **entrypoint,
 			    void **library);
@@ -211,5 +212,34 @@
 				 const char *user_realm,
 				 int flags,
 				 const char **errstr);
+
+#define CLIENT_PLUG_DEF( x ) int x ## _sasl_client_plug_init(sasl_utils_t *utils, int maxversion, int *out_version, const sasl_client_plug_t **pluglist, int *plugcount);
+
+#define SERVER_PLUG_DEF( x ) int x ## _sasl_server_plug_init(sasl_utils_t *utils, int maxversion, int *out_version, const sasl_server_plug_t **pluglist, int *plugcount);
+
+
+extern CLIENT_PLUG_DEF(crammd5)
+extern SERVER_PLUG_DEF(crammd5)
+
+extern CLIENT_PLUG_DEF(digestmd5)
+extern SERVER_PLUG_DEF(digestmd5)
+
+extern CLIENT_PLUG_DEF(anonymous)
+extern SERVER_PLUG_DEF(anonymous)
+
+extern CLIENT_PLUG_DEF(kerberos4)
+extern SERVER_PLUG_DEF(kerberos4)
+
+extern CLIENT_PLUG_DEF(gssapiv2)
+extern SERVER_PLUG_DEF(gssapiv2)
+
+extern CLIENT_PLUG_DEF(plain)
+extern SERVER_PLUG_DEF(plain)
+
+extern CLIENT_PLUG_DEF(login)
+extern SERVER_PLUG_DEF(login)
+
+extern CLIENT_PLUG_DEF(srp)
+extern SERVER_PLUG_DEF(srp)
 
 #endif /* SASLINT_H */
Index: lib/server.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/lib/server.c,v
retrieving revision 1.84
diff -u -r1.84 server.c
--- server.c	2001/02/06 20:54:28	1.84
+++ server.c	2001/04/25 00:33:28
@@ -1086,7 +1086,7 @@
 	int l = 0;
 
 	/* need to load this plugin */
-	result = _sasl_get_plugin(m->u.f, "sasl_server_plug_init",
+	result = _sasl_get_plugin(m->u.f, "sasl_server_plug_init", NULL,
 		    _sasl_find_verifyfile_callback(global_callbacks.callbacks),
 				  (void **) &entry_point, &library);
 	if (result == SASL_OK) {
Index: lib/windlopen.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/lib/windlopen.c,v
retrieving revision 1.10
diff -u -r1.10 windlopen.c
--- windlopen.c	2000/08/13 23:21:55	1.10
+++ windlopen.c	2001/04/25 00:33:28
@@ -48,6 +48,7 @@
 
 int _sasl_get_plugin(const char *file,
 		     const char *entryname,
+		     const char *altentryname,
 		     const sasl_callback_t *getpath_callback,
 		     const sasl_callback_t *verifyfile_callback,
 		     void **entrypoint,
Index: plugins/Makefile.am
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/Makefile.am,v
retrieving revision 1.39
diff -u -r1.39 Makefile.am
--- Makefile.am	2001/02/19 19:30:04	1.39
+++ Makefile.am	2001/04/25 00:33:28
@@ -66,24 +66,37 @@
 sasl_LTLIBRARIES = @SASL_MECHS@
 EXTRA_LTLIBRARIES = libplain.la libanonymous.la libkerberos4.la libcrammd5.la libscrammd5.la libgssapiv2.la libdigestmd5.la liblogin.la libsrp.la
 
+sasl_LIBRARIES = @SASL_STATIC_MECHS@
+EXTRA_LIBRARIES = libplain.a libanonymous.a libkerberos4.a libcrammd5.a libscrammd5.a libgssapiv2.a libdigestmd5.a liblogin.a libsrp.a
+
 libplain_la_SOURCES = plain.c
 libplain_la_LDFLAGS = -version-info $(plain_version)
 libplain_la_LIBADD = $(PLAIN_LIBS)
 
+libplain_a_SOURCES = plain.c
+
 libanonymous_la_SOURCES = anonymous.c
 libanonymous_la_LDFLAGS = -version-info $(anonymous_version)
 
+libanonymous_a_SOURCES = anonymous.c
+
 libkerberos4_la_SOURCES = kerberos4.c
 libkerberos4_la_LDFLAGS = -version-info $(kerberos4_version)
 libkerberos4_la_LIBADD = $(SASL_KRB_LIB) $(LIB_SOCKET)
 
+libkerberos4_a_SOURCES = kerberos4.c
+
 libgssapiv2_la_SOURCES = gssapi.c
 libgssapiv2_la_LDFLAGS = -version-info $(gssapiv2_version)
 libgssapiv2_la_LIBADD = $(GSSAPIBASE_LIBS) $(GSSAPI_LIBS) $(LIB_SOCKET)
 
+libgssapiv2_a_SOURCES = gssapi.c
+
 libcrammd5_la_SOURCES = cram.c
 libcrammd5_la_LDFLAGS = -version-info $(crammd5_version)
 
+libcrammd5_a_SOURCES = cram.c
+
 libscrammd5_la_SOURCES = scram.c
 libscrammd5_la_LDFLAGS = -version-info $(scrammd5_version)
 
@@ -91,13 +104,19 @@
 libdigestmd5_la_LDFLAGS = -version-info $(digestmd5_version)
 libdigestmd5_la_LIBADD = $(LIB_DES) $(LIB_SOCKET)
 
+libdigestmd5_a_SOURCES = digestmd5.c
+
 liblogin_la_SOURCES = login.c
 liblogin_la_LDFLAGS = -version-info $(login_version)
 liblogin_la_LIBADD = $(PLAIN_LIBS)
 
+liblogin_a_SOURCES = login.c
+
 libsrp_la_SOURCES = srp.c
 libsrp_la_LDFLAGS = -version-info $(srp_version)
 libsrp_la_LIBADD = $(SRP_LIBS)
+
+libsrp_a_SOURCES = srp.c
 
 # libx509_la_SOURCES = x509.c
 # libx509_la_LDFLAGS = -version-info $(x509_version)
Index: plugins/anonymous.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/anonymous.c,v
retrieving revision 1.34
diff -u -r1.34 anonymous.c
--- anonymous.c	2001/02/19 19:01:54	1.34
+++ anonymous.c	2001/04/25 00:33:28
@@ -199,11 +199,11 @@
   }
 };
 
-int sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_server_plug_t **pluglist,
-			  int *plugcount)
+int anonymous_sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)),
+				    int maxversion,
+				    int *out_version,
+				    const sasl_server_plug_t **pluglist,
+				    int *plugcount)
 {
   if (maxversion<ANONYMOUS_VERSION)
     return SASL_BADVERS;
@@ -412,11 +412,11 @@
   }
 };
 
-int sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_client_plug_t **pluglist,
-			  int *plugcount)
+int anonymous_sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
+				    int maxversion,
+				    int *out_version,
+				    const sasl_client_plug_t **pluglist,
+				    int *plugcount)
 {
   if (maxversion < ANONYMOUS_VERSION)
     return SASL_BADVERS;
Index: plugins/cram.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/cram.c,v
retrieving revision 1.55
diff -u -r1.55 cram.c
--- cram.c	2001/02/19 19:01:54	1.55
+++ cram.c	2001/04/25 00:33:29
@@ -796,11 +796,11 @@
   }
 };
 
-int sasl_server_plug_init(sasl_utils_t *utils,
-			  int maxversion,
-			  int *out_version,
-			  const sasl_server_plug_t **pluglist,
-			  int *plugcount)
+int crammd5_sasl_server_plug_init(sasl_utils_t *utils,
+				  int maxversion,
+				  int *out_version,
+				  const sasl_server_plug_t **pluglist,
+				  int *plugcount)
 {
   if (maxversion<CRAM_MD5_VERSION)
     return SASL_BADVERS;
@@ -1225,11 +1225,11 @@
   }
 };
 
-int sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_client_plug_t **pluglist,
-			  int *plugcount)
+int crammd5_sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
+				  int maxversion,
+				  int *out_version,
+				  const sasl_client_plug_t **pluglist,
+				  int *plugcount)
 {
   if (maxversion<CRAM_MD5_VERSION)
     return SASL_BADVERS;
Index: plugins/digestmd5.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/digestmd5.c,v
retrieving revision 1.97
diff -u -r1.97 digestmd5.c
--- digestmd5.c	2001/03/22 21:26:21	1.97
+++ digestmd5.c	2001/04/25 00:33:30
@@ -2933,11 +2933,11 @@
   }
 };
 
-int sasl_server_plug_init(sasl_utils_t * utils __attribute__((unused)),
-			  int maxversion __attribute__((unused)),
-			  int *out_version,
-			  const sasl_server_plug_t ** pluglist,
-			  int *plugcount) 
+int digestmd5_sasl_server_plug_init(sasl_utils_t * utils __attribute__((unused)),
+				    int maxversion __attribute__((unused)),
+				    int *out_version,
+				    const sasl_server_plug_t ** pluglist,
+				    int *plugcount) 
 {
   /*  if (maxversion < DIGESTMD5_VERSION)
       return SASL_BADVERS;*/
@@ -4134,11 +4134,11 @@
   }
 };
 
-int             sasl_client_plug_init(sasl_utils_t * utils __attribute__((unused)),
-				      int maxversion,
-				      int *out_version,
-				      const sasl_client_plug_t ** pluglist,
-				      int *plugcount) {
+int digestmd5_sasl_client_plug_init(sasl_utils_t * utils __attribute__((unused)),
+				    int maxversion,
+				    int *out_version,
+				    const sasl_client_plug_t ** pluglist,
+				    int *plugcount) {
   if (maxversion < DIGEST_MD5_VERSION)
     return SASL_BADVERS;
 
Index: plugins/gssapi.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/gssapi.c,v
retrieving revision 1.41
diff -u -r1.41 gssapi.c
--- gssapi.c	2001/02/19 19:01:54	1.41
+++ gssapi.c	2001/04/25 00:33:31
@@ -879,11 +879,11 @@
 };
 
 int 
-sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)), 
-		      int maxversion,
-		      int *out_version,
-		      const sasl_server_plug_t **pluglist,
-		      int *plugcount)
+gssapiv2_sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)), 
+			       int maxversion,
+			       int *out_version,
+			       const sasl_server_plug_t **pluglist,
+			       int *plugcount)
 {
 #ifdef HAVE_GSSKRB5_REGISTER_ACCEPTOR_IDENTITY
     const char *keytab;
@@ -1409,11 +1409,11 @@
 };
 
 int 
-sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)), 
-		      int maxversion,
-		      int *out_version, 
-		      const sasl_client_plug_t **pluglist,
-		      int *plugcount)
+gssapiv2_sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)), 
+			       int maxversion,
+			       int *out_version, 
+			       const sasl_client_plug_t **pluglist,
+			       int *plugcount)
 {
   if (maxversion<GSSAPI_VERSION)
     return SASL_BADVERS;
Index: plugins/kerberos4.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/kerberos4.c,v
retrieving revision 1.65
diff -u -r1.65 kerberos4.c
--- kerberos4.c	2001/02/19 19:01:54	1.65
+++ kerberos4.c	2001/04/25 00:33:31
@@ -850,11 +850,11 @@
   }
 };
 
-int sasl_server_plug_init(sasl_utils_t *utils,
-			  int maxversion,
-			  int *out_version,
-			  const sasl_server_plug_t **pluglist,
-			  int *plugcount)
+int kerberos4_sasl_server_plug_init(sasl_utils_t *utils,
+				    int maxversion,
+				    int *out_version,
+				    const sasl_server_plug_t **pluglist,
+				    int *plugcount)
 {
     const char *ret;
     unsigned int rl;
@@ -1323,11 +1323,11 @@
   }
 };
 
-int sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_client_plug_t **pluglist,
-			  int *plugcount)
+int kerberos4_sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
+				    int maxversion,
+				    int *out_version,
+				    const sasl_client_plug_t **pluglist,
+				    int *plugcount)
 {
   if (maxversion<KERBEROS_VERSION)
     return SASL_BADVERS;
Index: plugins/login.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/login.c,v
retrieving revision 1.6
diff -u -r1.6 login.c
--- login.c	2001/02/19 19:15:12	1.6
+++ login.c	2001/04/25 00:33:31
@@ -329,11 +329,11 @@
   }
 };
 
-int sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_server_plug_t **pluglist,
-			  int *plugcount)
+int login_sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)),
+				int maxversion,
+				int *out_version,
+				const sasl_server_plug_t **pluglist,
+				int *plugcount)
 {
   if (maxversion<LOGIN_VERSION)
     return SASL_BADVERS;
@@ -832,11 +832,11 @@
   }
 };
 
-int sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_client_plug_t **pluglist,
-			  int *plugcount)
+int login_sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
+				int maxversion,
+				int *out_version,
+				const sasl_client_plug_t **pluglist,
+				int *plugcount)
 {
   if (maxversion<LOGIN_VERSION)
     return SASL_BADVERS;
Index: plugins/plain.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/plain.c,v
retrieving revision 1.43
diff -u -r1.43 plain.c
--- plain.c	2001/02/19 19:01:54	1.43
+++ plain.c	2001/04/25 00:33:31
@@ -324,11 +324,11 @@
   }
 };
 
-int sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_server_plug_t **pluglist,
-			  int *plugcount)
+int plain_sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)),
+				int maxversion,
+				int *out_version,
+				const sasl_server_plug_t **pluglist,
+				int *plugcount)
 {
   if (maxversion<PLAIN_VERSION)
     return SASL_BADVERS;
@@ -794,11 +794,11 @@
   }
 };
 
-int sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_client_plug_t **pluglist,
-			  int *plugcount)
+int plain_sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
+				int maxversion,
+				int *out_version,
+				const sasl_client_plug_t **pluglist,
+				int *plugcount)
 {
   if (maxversion<PLAIN_VERSION)
     return SASL_BADVERS;
Index: plugins/srp.c
===================================================================
RCS file: /afs/andrew/system/cvs/src/sasl/plugins/srp.c,v
retrieving revision 1.2
diff -u -r1.2 srp.c
--- srp.c	2000/04/09 22:54:11	1.2
+++ srp.c	2001/04/25 00:33:32
@@ -44,6 +44,7 @@
 #include <config.h>
 #include <sasl.h>
 #include <saslplug.h>
+#include <errno.h>
 
 #include <assert.h>
 #include <ctype.h>
@@ -51,9 +52,6 @@
 /* for big number support */
 #include <gmp.h>
 
-/* for SHA1 support */
-#include <openssl/sha.h>
-
 #ifdef WIN32
 /* This must be after sasl.h, saslutil.h */
 /* xxx  # include "saslANONYMOUS.h" */
@@ -68,66 +66,109 @@
 # define L_DEFAULT_GUARD (0)
 #endif
 
-/* security bits */
-#define SRP_SUPPORTS_INTEGRITY 1
-#define SRP_SUPPORTS_SEQUENCENUMBERS 2
-#define SRP_SUPPORTS_CONFIDENTIALITY 4
-
-
-#define HASHLEN SHA_DIGEST_LENGTH
-#define MAXBIGNUMLEN 1024
-
 /* Size of N in bits */
 #define BITSFORN 128
 /* Size of diffie-hellman secrets a and b */
 #define BITSFORab 64
+/* How many bytes big should the salt be? */
+#define SRP_SALT_SIZE 16
 
-
 #define VL(x) printf x
 
+extern int errno;
+
 /* global: if we've already set a pass entry */
 static int mydb_initialized = 0;
 
-typedef struct netstring_s {
+/* Generic Hash function definitions */
+typedef int  (*srp_hash_len_t)(sasl_utils_t *utils);
+typedef int  (*srp_hash_init_t)(sasl_utils_t *utils, char *key, int keylen, void **ctx);
+typedef void (*srp_hash_update_t)(sasl_utils_t *utils, void *ctx, char *data, int datalen);
+typedef void (*srp_hash_final_t)(sasl_utils_t *utils, char *outdata, void *ctx);
+
+#define OPTION_REPLAY_DETECTION "replay detection"
+#define OPTION_INTEGRITY "integrity="
+#define OPTION_CONFIDENTIALITY "confidentiality="
 
-    int size;
-    
-    char data[1]; /* allocate to size you need */
+/* Forward decl */
+static int
+ReadUserInfo(sasl_utils_t *utils, char *authid, char *realm,
+	     mpz_t *N, mpz_t *g, char **salt, int *saltlen, mpz_t *v, const char **errstr);
 
-} netstring_t;
+/***************** MD5 Hash Functions for Integrity Layer ****************/
 
-/* doesn't contain netstring formatting */
-typedef struct netdata_s {
+static int
+srp_md5Len(sasl_utils_t *utils __attribute__((unused)))
+{
+    return 16;
+}
 
-    int size;
-    
-    char data[1]; /* allocate to size you need */
+static int
+srp_md5Init(sasl_utils_t *utils, char *key, int keylen, void **ctx)
+{
+    HMAC_MD5_CTX *ret;
 
-} netdata_t;
+    ret = utils->malloc(sizeof(HMAC_MD5_CTX));
+    if (!ret) return SASL_NOMEM;
+
+    utils->hmac_md5_init(ret, key, keylen);
 
+    *ctx = ret;
 
+    return SASL_OK;
+}
 
-typedef struct hash_s {
+static void
+srp_md5Update(sasl_utils_t *utils, void *context, char *data, int datalen)
+{
+    HMAC_MD5_CTX *ctx = (HMAC_MD5_CTX *)context;
 
-    unsigned char data[SHA_DIGEST_LENGTH];
-    int len;
+    utils->MD5Update(&ctx->ictx, data, datalen);    
+}
+
+static void
+srp_md5Final(sasl_utils_t *utils, char *outdata, void *context)
+{
+    HMAC_MD5_CTX *ctx = (HMAC_MD5_CTX *)context;
+
+    utils->hmac_md5_final(outdata, ctx);
+}
+
+/******************** Options *************************/
+
+typedef struct layer_option_s {
+    char *name;
+    int bit;
+    int ssf;
+
+    srp_hash_len_t    HashLen;
+    srp_hash_init_t   HashInit;
+    srp_hash_update_t HashUpdate;
+    srp_hash_final_t  HashFinal;
 
-} hash_t;
+} layer_option_t;
 
-typedef struct interleaved_s {
+static layer_option_t integrity_options[] = {
+    {"hmac-md5", 0x1, 0, &srp_md5Len, &srp_md5Init, &srp_md5Update, &srp_md5Final},
+    {NULL,       0x0, 0,        NULL,         NULL,           NULL,          NULL}
+};
 
-    unsigned char data[SHA_DIGEST_LENGTH*2];
+static layer_option_t confidentiality_options[] = {
+    /* nothing yet */
+    {NULL,       0x0, 0,        NULL,         NULL,           NULL,          NULL}
+};
 
-} interleaved_t;
 
-typedef struct savedinfo_s {
+typedef struct srp_options_s {
 
-    char salt[16];
+    int replay_detection;
 
-    mpz_t verifier;
+    int integrity;
+    int confidentiality;
 
-} savedinfo_t;
+} srp_options_t;
 
+/* The main SRP context */
 typedef struct context_s {
     int state;
 
@@ -144,273 +185,311 @@
     mpz_t a;
     mpz_t A;
 
-    interleaved_t sharedsecretK;
+    char *K;
+    int Klen;
+
+    char *M1;
+    int M1len;
 
-    char *authid;
+    char *authid; /* authentication id */
+    char *userid; /* authorization id */
     char *realm;
     sasl_secret_t *password;
 
-    unsigned char client_options;
-    unsigned char server_options;
+    char *client_options;
+    char *server_options;
 
-    hash_t M1; /* client needs to save between steps 3 and 4 */
-    savedinfo_t *sinfo;
+    srp_options_t client_opts;
 
-} context_t;
-
+    char *salt;
+    int saltlen;
 
-/* forward declarations */
-static int create_public_server(mpz_t g, mpz_t N, mpz_t v,
-				mpz_t b, mpz_t B);
-
-static char frombits(unsigned int i)
-{
-    assert(i <= 15);
+    /* Layer foo */
+    int enabled_integrity_layer;
+    int enabled_replay_detection;
+
+    int seqnum_out;
+    int seqnum_in;
+
+    srp_hash_len_t    HashLen;
+    srp_hash_init_t   HashInit;
+    srp_hash_update_t HashUpdate;
+    srp_hash_final_t  HashFinal;
+
+    /* encode and decode need these */
+    sasl_utils_t *utils;
+    char *buffer;                    
+    int bufsize;
+    char sizebuf[4];
+    int cursize;
+    int size;
+    int needsize;
 
-    if (i<=9) return '0'+i;
+} context_t;
 
-    return 'a'+ (i-10);
-}
+/*******************************************
+ *	Layer Functions	 	           *
+ *                                         *
+ *******************************************/
 
-static int tobits(char c)
+static int
+layer_encode(void *context,
+		 const char *input,
+		 unsigned inputlen,
+		 char **output,
+		 unsigned *outputlen)
 {
-    if ((int) isdigit(c))
-	return c-'0';
+    context_t      *text = (context_t *) context;
+    int hashlen = 0;
+    char hashdata[16]; /* xxx */
+    int tmpnum;
 
-    if ((c>='a') && (c<='f'))
-	return c-'a'+10;
+  assert(inputlen > 0);
 
-    if ((c>='A') && (c<='F'))
-	return c-'A'+10;
+  if (text->enabled_integrity_layer) {
+      void *hmac_ctx = NULL;
 
-    return 0;
-}
+      text->HashInit(text->utils, text->K, text->Klen, &hmac_ctx);
 
+      text->HashUpdate(text->utils, hmac_ctx, (char *)input, inputlen);
 
-/* copy a string */
-static int
-srp_strdup(sasl_utils_t * utils, const char *in, char **out, int *outlen)
-{
-  size_t len = strlen(in);
+      if (text->enabled_replay_detection) {
+	  tmpnum = htonl(text->seqnum_out);
+	  text->HashUpdate(text->utils, hmac_ctx, (char *) &tmpnum, 4);
+	    
+	  text->seqnum_out++;	  
+      }
 
-  if (outlen!=NULL) {
-      *outlen = len;
+      text->HashFinal(text->utils, hashdata, hmac_ctx);
+      hashlen = 16; /* xxx */
   }
 
-  *out = utils->malloc(len + 1);
-  if (!*out) {
-      return SASL_NOMEM;
-  }
+  /* 4 for length + input size + hashlen for integrity (could be zero) */
+  *outputlen = 4 + inputlen + hashlen;
 
-  strcpy((char *) *out, in);
+  *output = text->utils->malloc(*outputlen);
+  if (!*output) return SASL_NOMEM;
+  
+  tmpnum = inputlen+hashlen;
+  tmpnum = htonl(tmpnum);
+  memcpy(*output,     &tmpnum, 4);
+  memcpy((*output)+4, input, inputlen);
+  memcpy((*output)+4+inputlen, hashdata, hashlen);
+  
   return SASL_OK;
 }
-
-static netdata_t *create_netdata_bigint(mpz_t n, sasl_utils_t *utils)
-{
-    int size;
-    netdata_t *ret;
-    int prefixlen=0;
-    int lup;
-    char *str;
-
-    size = mpz_sizeinbase (n, 16);
-
-    str = (char *) utils->malloc(size+10);
-    if (!str) return NULL;
-    mpz_get_str (str, 16, n);
-
-    ret = (netdata_t *) utils->malloc(sizeof(netdata_t)+20+size);
-    if (!ret) return NULL;
-
-    if (size%2!=0) {
-	ret->data[0]=tobits(str[0]);
-	size--;
-	str++;
-	prefixlen=1;
-    }
-
-    for (lup=0;lup<size/2;lup++)
-    {
-	ret->data[prefixlen+lup] = (tobits(str[lup*2]) << 4);
-	ret->data[prefixlen+lup] |= tobits(str[lup*2+1]);
-    }
-
-    ret->size = prefixlen+(size/2);
-
-    return ret;
-}
-
-static netstring_t *create_netstring_bigint(mpz_t n, sasl_utils_t *utils)
-{
-    int size;
-    int prefixlen;
-    netstring_t *ret;
-    int lup;
-    char *str;
-
-    size = mpz_sizeinbase (n, 16);
-
-    str = (char *) utils->malloc(size+10);
-    if (!str) return NULL;
-    mpz_get_str (str, 16, n);
 
-    ret = (netstring_t *) utils->malloc(sizeof(netstring_t)+20+size);
-    if (!ret) return NULL;
+static int
+decode(context_t *text,
+       const char *input,
+       unsigned inputlen,
+       char **output,
+       unsigned *outputlen)
+{
+    int hashlen = 0;
+
+    if (text->enabled_integrity_layer) {
+	int tmpnum;
+	char hashdata[16];
+	int i;
+	void *hmac_ctx = NULL;
+
+	text->HashInit(text->utils, text->K, text->Klen, &hmac_ctx);
+
+	hashlen = 16; /* xxx */
+
+	if ((int)inputlen < hashlen) {
+	    VL(("Input is smaller than hash length: %d vs %d\n",inputlen, hashlen));
+	    return SASL_FAIL;
+	}
 
-    sprintf(ret->data,"%d:",(size+1)/2);
-    prefixlen = strlen(ret->data);
+	/* create my version of the hash */
+	text->HashUpdate(text->utils, hmac_ctx, (char *)input, inputlen - hashlen);
 
-    if (size%2!=0) {
-	ret->data[prefixlen]=tobits(str[0]);
-	size--;
-	str++;
-	prefixlen++;
-    }
+	if (text->enabled_replay_detection) {
+	    tmpnum = htonl(text->seqnum_in);
+	    text->HashUpdate(text->utils, hmac_ctx, (char *) &tmpnum, 4);
+	    
+	    text->seqnum_in ++;
+	}
+	
+	text->HashFinal(text->utils, hashdata, hmac_ctx);
 
-    for (lup=0;lup<size/2;lup++)
-    {
-	ret->data[prefixlen+lup] = (tobits(str[lup*2]) << 4);
-	ret->data[prefixlen+lup] |= tobits(str[lup*2+1]);
+	/* compare to hash given */
+	for (i = 0; i < hashlen; i++) {
+	    if (hashdata[i] != input[inputlen - hashlen + i]) {
+		VL(("Hash is incorrect\n"));
+		return SASL_FAIL;
+	    }
+	}
     }
-
-    ret->data[prefixlen+size/2] = ',';
-    ret->data[prefixlen+(size/2)+1] = '\0';
-
-    ret->size = prefixlen+(size/2)+1;
-
-    return ret;
-}
-
-/*
- * Create a netstring from a character array
- */
-
-static netstring_t *create_netstring_str(char *str, int len, sasl_utils_t *utils)
-{
-    netstring_t *ret;
-    int prefixlen;
-
-    ret = (netstring_t *) utils->malloc(sizeof(netstring_t)+10+len);
 
-    sprintf(ret->data,"%d:",len);
-    prefixlen = strlen(ret->data);
+    *output = text->utils->malloc(inputlen - hashlen);
+    if (!*output) return SASL_NOMEM;
 
-    memcpy(ret->data+prefixlen,str,len);
+    *outputlen = inputlen - hashlen;
+    memcpy(*output, input, *outputlen);
 
-    ret->data[prefixlen+len]=',';
-    ret->data[prefixlen+len+1]='\0';
-
-    ret->size = prefixlen+len+1;
-
-    return ret;
+    return SASL_OK;
 }
 
-static void Hash(unsigned char *data, unsigned long len, hash_t *hash)
-{
-    SHA_CTX c;
-
-    SHA1_Init(&c);
+static int
+layer_decode(void *context,
+	     const char *input,
+	     unsigned inputlen,
+	     char **output,
+	     unsigned *outputlen)
+{
+    int tocopy;
+    unsigned diff;
+    context_t *text=context;
+    char *extra;
+    unsigned int extralen=0;
+    int r;
+
+    if (text->needsize>0) { /* 4 bytes for how long message is */
+	/* if less than 4 bytes just copy those we have into text->size */
+	if (inputlen<4) 
+	    tocopy=inputlen;
+	else
+	  tocopy=4;
+      
+	if (tocopy>text->needsize)
+	    tocopy=text->needsize;
 
-    SHA1_Update(&c,data,len);
+	memcpy(text->sizebuf+4-text->needsize, input, tocopy);
+	text->needsize-=tocopy;
+	
+	input+=tocopy;
+	inputlen-=tocopy;
 
-    SHA1_Final(&(hash->data[0]),&c);
+	if (text->needsize==0) /* got all of size */
+	{
+	    memcpy(&(text->size), text->sizebuf, 4);
+	    text->cursize=0;
+	    text->size=ntohl(text->size);
+	    
+	    /* too big? */
+	    if ((text->size>0xFFFF) || (text->size < 0)) {
+		VL(("Size out of range: %d\n",text->size));
+		return SASL_FAIL;
+	    }
+	    
+	    if (text->bufsize < text->size + 5) {
+		text->buffer = text->utils->realloc(text->buffer, text->size + 5);
+		text->bufsize = text->size + 5;
+	    }
+	    if (text->buffer == NULL) return SASL_NOMEM;
+	}
+	*outputlen=0;
+	*output=NULL;
+	if (inputlen==0) /* have to wait until next time for data */
+	    return SASL_OK;
+	
+	if (text->size==0)  /* should never happen */
+	    return SASL_FAIL;
+    }
     
-    hash->len = SHA_DIGEST_LENGTH; 
-
-    /*    int lup;
-
-    memset(hash->data, 'z', sizeof(hash->data));
-
-    if (len > SHA_DIGEST_LENGTH) len = SHA_DIGEST_LENGTH;
-
-    for (lup=0;lup<(int)len;lup++)
-	hash->data[lup] = data[lup];
-
-	hash->len = SHA_DIGEST_LENGTH;*/
-}
-
-static int Hash_bigint(mpz_t num, hash_t *hash, sasl_utils_t *utils)
-{ 
-    int size;
-    int lup;
-    char *str;
-    char *data;
-
-    size = mpz_sizeinbase (num, 16);
+    diff=text->size - text->cursize; /* bytes need for full message */
     
-    str = (char *) utils->malloc(size+10);
-    if (!str) return SASL_NOMEM;
-    mpz_get_str (str, 16, num);
+    if (! text->buffer)
+	return SASL_FAIL;
     
-    data = (char *) utils->malloc(size+10);
-    if (!data) return SASL_NOMEM;
-
-    for (lup=0;lup<size/2;lup++)
-    {
-	data[lup] = (tobits(str[lup*2]) << 4);
-	data[lup] = tobits(str[lup*2+1]);
+    if (inputlen < diff) { /* not enough for a decode */
+	memcpy(text->buffer+text->cursize, input, inputlen);
+	text->cursize+=inputlen;
+	*outputlen=0;
+	*output=NULL;
+	return SASL_OK;
+    } else {
+	memcpy(text->buffer+text->cursize, input, diff);
+	input+=diff;      
+	inputlen-=diff;
+    }
+
+    /* We have enough data to return something */
+    r = decode(text, text->buffer, text->size, output, outputlen);
+    if (r) return r;
+
+    text->size = -1;
+    text->needsize = 4;
+
+    /* if received more than the end of a packet */
+    if (inputlen!=0) {
+	extra = NULL;
+	layer_decode(text, input, inputlen,
+		       &extra, &extralen);
+	if (extra != NULL) {
+	    /* if received 2 packets merge them together */
+	    *output = text->utils->realloc(*output, *outputlen+extralen);
+	    memcpy(*output + *outputlen, extra, extralen); 
+	    *outputlen += extralen;
+	    text->utils->free(extra);
+	}
     }
-
-    Hash(data, size/2, hash);
-
-    utils->free(str);
-    utils->free(data);
-
+    
     return SASL_OK;
 }
 
-static int SHA_Interleave(mpz_t num, interleaved_t *inter, sasl_utils_t *utils)
-{
-    netstring_t *tmpns;
-    char *T;
-    int Tlen;
-    char *E, *F;
-    int lup;
-    hash_t G;
-    hash_t H;
+/*******************************************
+ *	Helper Functions		   *
+ *                                         *
+ *******************************************/
 
-    tmpns = create_netstring_bigint(num, utils);
-    if (!tmpns) return SASL_NOMEM;
-    
-    /* removing leading zeros is already done right? */
+/* Dispose of a SRP context (could be server or client)
+ *
+ *
+ */ 
+static void dispose(void *conn_context, sasl_utils_t *utils)
+{
+  context_t *text = conn_context;
 
-    /* if odd kill first byte */
-    T = tmpns->data;
-    Tlen = tmpns->size;
-    if (Tlen % 2 !=0) { T++; Tlen--; }
+  if (!text)
+    return;
 
-    E = (char *) utils->malloc(Tlen/2+1);
-    if (!E) return SASL_NOMEM;
-    F = (char *) utils->malloc(Tlen/2+1);
-    if (!F) return SASL_NOMEM;
+  mpz_clear(text->N);
+  mpz_clear(text->g);
+  mpz_clear(text->S);
+  mpz_clear(text->v);
+  mpz_clear(text->b);
+  mpz_clear(text->B);
+  mpz_clear(text->a);
+  mpz_clear(text->A);
+
+  if (text->K)                utils->free(text->K);
+  if (text->M1)               utils->free(text->M1);
+
+  if (text->authid)           utils->free(text->authid);
+  if (text->userid)           utils->free(text->userid);
+  if (text->realm)            utils->free(text->realm);
+  if (text->password)         utils->free(text->password);
+  if (text->salt)             utils->free(text->salt);
+
+  if (text->client_options)   utils->free(text->client_options);
+  if (text->server_options)   utils->free(text->server_options);
+  if (text->buffer)           utils->free(text->buffer);
 
-    /* E gets even bytes. F gets odd */
-    for (lup=0;lup<Tlen/2;lup++)
-    {
-	E[lup]=T[lup*2];
-	F[lup]=T[lup*2+1];
-    }
+  utils->free(text);
+}
 
-    utils->free(tmpns);
 
-    /* hash E and F into G and H*/
-    Hash(E,Tlen/2, &G);
-    Hash(F,Tlen/2, &H);
+/* copy a string */
+static int
+srp_strdup(sasl_utils_t * utils, const char *in, char **out, int *outlen)
+{
+  size_t len = strlen(in);
 
-    utils->free(E);
-    utils->free(F);
+  if (outlen!=NULL) {
+      *outlen = len;
+  }
 
-    /* interleave hashes into 'inter' */
-    for (lup=0;lup<HASHLEN*2;lup++)
-    {
-	if (lup%2 == 0)
-	    inter->data[lup]=G.data[lup/2];
-	else
-	    inter->data[lup]=H.data[(lup-1)/2];		
-    }
+  *out = utils->malloc(len + 1);
+  if (!*out) {
+      return SASL_NOMEM;
+  }
 
-    return SASL_OK;
+  strcpy((char *) *out, in);
+  return SASL_OK;
 }
 
 /* returns the realm we should pretend to be in */
@@ -466,69 +545,1207 @@
     return ret;
 }
 
+#define MAX_BUFFER_LEN 2147483643
+#define MAX_UTF8_LEN 65535
+#define MAX_OS_LEN 255
 
 
+/*
+ * Make a SRP buffer
+ *
+ * in1 must exist but the rest may be NULL
+ *
+ */
 static int
-server_start(void *glob_context __attribute__((unused)),
-             sasl_server_params_t *params,
-	     const char *challenge __attribute__((unused)),
-	     int challen __attribute__((unused)),
-	     void **conn,
-	     const char **errstr)
+MakeBuffer(sasl_utils_t *utils, 
+	   char *in1, int in1len,
+	   char *in2, int in2len,
+	   char *in3, int in3len,
+	   char *in4, int in4len,
+	   char **out,
+	   unsigned *outlen)
 {
-  context_t *text;
+    int len;
+    int inbyteorder;
 
-  /* holds state are in */
-  if (!conn)
-      return SASL_BADPARAM;
+    if (!in1) {
+	VL(("At least one buffer must be active\n"));
+	return SASL_FAIL;
+    }
 
-  /* holds state are in */
-  text = params->utils->malloc(sizeof(context_t));
-  if (text==NULL) return SASL_NOMEM;
+    len = in1len + in2len + in3len + in4len;
 
-  memset(text, '\0', sizeof(context_t));
-  text->state=1;
-  *conn=text;
-  
-  if (errstr)
-      *errstr = NULL;
+    if (len > MAX_BUFFER_LEN) {
+	VL(("String too long to create SRP buffer string\n"));
+	return SASL_FAIL;
+    }
 
-  return SASL_OK;
-}
+    *out = utils->malloc(len + 4);
+    if (!*out) return SASL_NOMEM;
 
+    /* put length in */
+    inbyteorder = htonl(len);
+    memcpy(*out, &inbyteorder, 4);
 
-static int bigint_fromstr(unsigned char *data, int len, sasl_utils_t *utils, mpz_t ret)
-{
-    char *str;
-    int lup;
+    /* copy in data */
+    memcpy((*out)+4, in1, in1len);
 
-    mpz_init(ret);
+    if (in2len)
+	memcpy((*out)+4+in1len, in2, in2len);
 
-    /* convert to base 16 */
-    str = (char *) utils->malloc(len*2+10);
-    if (!str) return SASL_NOMEM;
+    if (in3len)
+	memcpy((*out)+4+in1len+in2len, in3, in3len);
 
-    for (lup=0;lup<len;lup++)
-    {
-	str[lup*2]   = frombits(data[lup] >> 4);
-	str[lup*2+1] = frombits(data[lup] & 15);
+    if (in4len)
+	memcpy((*out)+4+in1len+in2len+in3len, in4, in4len);
+
+    *outlen = len + 4;
+
+    return SASL_OK;
+}
+
+/* Un'buffer' a string
+ *
+ * 'out' becomes a pointer into 'in' not an allocation
+ */
+static int
+UnBuffer(char *in, int inlen, char **out, int *outlen)
+{
+    int lenbyteorder;
+    int len;
+
+    if ((!in) || (inlen < 4)) {
+	VL(("Buffer is not big enough to be SRP buffer: %d\n", inlen));
+	return SASL_FAIL;
+    }
+
+    /* get the length */
+    memcpy(&lenbyteorder, in, 4);
+    len = ntohl(lenbyteorder);
+
+    /* make sure it's right */
+    if (len + 4 != inlen) {
+	VL(("SRP Buffer isn't of the right length\n"));
+	return SASL_FAIL;
     }
+
+    *out = in+4;
+    *outlen = len;
     
-    str[lup*2]='\0';
+    return SASL_OK;
+}
+
+static int
+MakeUTF8(sasl_utils_t *utils,
+	 char *in,
+	 char **out,
+	 int *outlen)
+{
+    int llen;
+    short len;
+    short inbyteorder;
+
+    if (!in) {
+	VL(("Can't create utf8 string from null"));
+	return SASL_FAIL;
+    }
+
+    /* xxx actual utf8 conversion */
+
+    llen = strlen(in);
+
+    if (llen > MAX_UTF8_LEN) {
+	VL(("String too long to create utf8 string\n"));
+	return SASL_FAIL;
+    }
+    len = (short)llen;
+
+    *out = utils->malloc(len+2);
+    if (!*out) return SASL_NOMEM;
+
+    /* put in len */
+    inbyteorder = htons(len);
+    memcpy(*out, &inbyteorder, 2);
+
+    /* put in data */
+    memcpy((*out)+2, in, len);
 
-    mpz_set_str (ret, str, 16);
+    *outlen = len+2;
+
+    return SASL_OK;
+}
+
+static int
+GetUTF8(sasl_utils_t *utils, char *data, int datalen, char **outstr, char **left, int *leftlen)
+{
+    short lenbyteorder;
+    int len;
+
+    if ((!data) || (datalen < 2)) {
+	VL(("Buffer is not big enough to be SRP UTF8\n"));
+	return SASL_FAIL;
+    }
+
+    /* get the length */
+    memcpy(&lenbyteorder, data, 2);
+    len = ntohs(lenbyteorder);
+
+    /* make sure it's right */
+    if (len + 2 > datalen) {
+	VL(("Not enough data for this SRP UTF8\n"));
+	return SASL_FAIL;
+    }
+
+    *outstr = (char *)utils->malloc(len+1);
+    if (!*outstr) return SASL_NOMEM;
+
+    memcpy(*outstr, data+2, len);
+    (*outstr)[len] = '\0';
+    
+    *left = data+len+2;
+    *leftlen = datalen - (len+2);
 
-    utils->free(str);
+    return SASL_OK;
+}
+
+static int
+MakeOS(sasl_utils_t *utils,
+       char *in, 
+       int inlen,
+       char **out,
+       int *outlen)
+{
+    if (!in) {
+	VL(("Can't create SRP os string from null"));
+	return SASL_FAIL;
+    }
+
+    if (inlen > MAX_OS_LEN) {
+	VL(("String too long to create SRP os string\n"));
+	return SASL_FAIL;
+    }
+
+    *out = utils->malloc(inlen+1);
+    if (!*out) return SASL_NOMEM;
+
+    /* put in len */
+    (*out)[0] = inlen & 0xFF;
+
+    /* put in data */
+    memcpy((*out)+1, in, inlen);
+
+    *outlen = inlen+1;
+
+    return SASL_OK;
+}
+
+static int
+GetOS(sasl_utils_t *utils, char *data, int datalen, char **outstr, int *outlen, char **left, int *leftlen)
+{
+    int len;
+
+    if ((!data) || (datalen < 1)) {
+	VL(("Buffer is not big enough to be SRP os\n"));
+	return SASL_FAIL;
+    }
+
+    /* get the length */
+    len = (unsigned char)data[0];
+
+    /* make sure it's right */
+    if (len + 1 > datalen) {
+	VL(("Not enough data for this SRP os\n"));
+	return SASL_FAIL;
+    }
+
+    *outstr = (char *)utils->malloc(len+1);
+    if (!*outstr) return SASL_NOMEM;
+
+    memcpy(*outstr, data+1, len);
+    (*outstr)[len] = '\0';
+
+    *outlen = len;
+    
+    *left = data+len+1;
+    *leftlen = datalen - (len+1);
+
+    return SASL_OK;
+}
+
+static int 
+tobits(char c)
+{
+    if ((int) isdigit(c))
+	return c-'0';
+
+    if ((c>='a') && (c<='f'))
+	return c-'a'+10;
+
+    if ((c>='A') && (c<='F'))
+	return c-'A'+10;
+
+    return 0;
+}
+
+/* Convert a big integer to it's byte representation
+ *
+ *
+ */
+static int
+BigIntToBytes(mpz_t num, char *out, int maxoutlen, int *outlen)
+{
+    char buf[4096];
+    char *bufp = buf;
+    int len;
+    int prefixlen = 0;
+    int i;
+
+    len = mpz_sizeinbase (num, 16);
+
+    if (len > maxoutlen) return SASL_FAIL;
+
+    mpz_get_str (buf, 16, num);
+
+    if (len%2!=0) {
+	out[0]=tobits(*bufp);
+	bufp++;
+	len--;
+	prefixlen=1;
+    }
+
+    for (i=0; i< len/2; i++ )
+    {
+	out[prefixlen+i] = (tobits(*bufp) << 4);
+	bufp++;
+	out[prefixlen+i] |= tobits(*bufp);
+	bufp++;
+    }
+
+    *outlen = prefixlen+(len/2);
+
+    return SASL_OK;    
+}
+
+static int
+MakeMPI(sasl_utils_t *utils,
+	mpz_t num,
+	char **out,
+	int *outlen)
+{
+    int shortlen;
+    int len;
+    short inbyteorder;
+    int alloclen;
+    int r;
+
+    alloclen = mpz_sizeinbase (num, 16);
+   
+    *out = utils->malloc(alloclen+2);
+    if (!*out) return SASL_NOMEM;
+
+    r = BigIntToBytes(num, (*out)+2, alloclen, &len);
+    if (r) {
+	utils->free(*out);
+	return r;
+    }
+
+    *outlen = 2+len;
+
+    /* put in len */
+    shortlen = len;
+    inbyteorder = htons(shortlen);
+    memcpy(*out, &inbyteorder, 2);
+
+    return SASL_OK;
+}
+
+static char 
+frombits(unsigned int i)
+{
+    assert(i <= 15);
+
+    if (i<=9) return '0'+i;
+
+    return 'a'+ (i-10);
+}
+
+static void
+DataToBigInt(unsigned char *in, int inlen, mpz_t *outnum)
+{
+    int i;
+    char buf[4096];
+
+    mpz_init(*outnum);    
+
+    memset(buf, '\0', sizeof(buf));
+
+    for (i = 0; i < inlen; i++) 
+    {
+	buf[i*2]   = frombits(in[i] >> 4);
+	buf[i*2+1] = frombits(in[i] & 15);
+    }
+    
+    mpz_set_str (*outnum, buf, 16);
+}
+
+static int
+GetMPI(unsigned char *data, int datalen, mpz_t *outnum, char **left, int *leftlen)
+{
+
+
+    short lenbyteorder;
+    int len;
+
+    if ((!data) || (datalen < 2)) {
+	VL(("Buffer is not big enough to be SRP MPI: %d\n", datalen));
+	return SASL_FAIL;
+    }
+
+    /* get the length */
+    memcpy(&lenbyteorder, data, 2);
+    len = ntohs(lenbyteorder);
+
+    /* make sure it's right */
+    if (len + 2 > datalen) {
+	VL(("Not enough data for this SRP MPI: we have %d; it say it's %d\n",datalen, len+2));
+	return SASL_FAIL;
+    }
+
+    DataToBigInt(data+2, len, outnum);
+
+    *left = data+len+2;
+    *leftlen = datalen - (len+2);
+
+    return SASL_OK;
+}
+
+static void
+GetRandBigInt(mpz_t out)
+{
+    mpz_init(out);
+
+    /* xxx likely should use sasl random funcs */
+    mpz_random(out, BITSFORab/(8*sizeof(int)));
+}
+
+/* Call the hash function on the data of a BigInt
+ *
+ */
+static void
+HashData(sasl_utils_t *utils, char *in, int inlen, unsigned char outhash[16])
+{
+    MD5_CTX md5ctx;
+
+    utils->MD5Init(&md5ctx);
+    utils->MD5Update(&md5ctx, in, inlen);
+    utils->MD5Final(outhash, &md5ctx);
+}
+
+/* Call the hash function on the data of a BigInt
+ *
+ */
+static int
+HashBigInt(sasl_utils_t *utils, mpz_t in, unsigned char outhash[16])
+{
+    int r;
+    char buf[4096];
+    int buflen;
+    MD5_CTX md5ctx;
+    
+    r = BigIntToBytes(in, buf, sizeof(buf)-1, &buflen);
+    if (r) return r;
+
+    utils->MD5Init(&md5ctx);
+    utils->MD5Update(&md5ctx, buf, buflen);
+    utils->MD5Final(outhash, &md5ctx);
+
+    return 0;
+}
+
+static int
+HashInterleaveBigInt(sasl_utils_t *utils, mpz_t num, char **out, int *outlen)
+{
+    int r;
+    char buf[4096];
+    int buflen;
+
+    int klen;
+    int limit;
+    int i;
+    int offset;
+    int j;
+    MD5_CTX mdEven;
+    MD5_CTX mdOdd;
+    unsigned char Evenb[16];
+    unsigned char Oddb[16];
+
+    /* make bigint into bytes */
+    r = BigIntToBytes(num, buf, sizeof(buf)-1, &buflen);
+    if (r) return r;
+
+    limit = buflen;
+
+    /* skip by leading zero's */
+    for (offset = 0; offset < limit && buf[offset] == 0x00; offset++) {
+	/* nada */
+    }
+	
+    klen = (limit - offset) / 2;
+
+    utils->MD5Init(&mdEven);
+    utils->MD5Init(&mdOdd);
+
+    j = limit - 1;
+    for (i = 0; i < klen; i++) {
+	utils->MD5Update(&mdEven, buf + j, 1);
+	j--;
+	utils->MD5Update(&mdOdd, buf + j, 1);
+	j--;
+    }
+
+    utils->MD5Final(Evenb, &mdEven);
+    utils->MD5Final(Oddb, &mdOdd);
+
+    *out = utils->malloc(32);
+    if (!*out) return SASL_NOMEM;
+    *outlen = 32;
+      
+    for (i = 0, j = 0; i < 16; i++)
+    {
+	(*out)[j++] = Evenb[i];
+	(*out)[j++] = Oddb[i];
+    }
+
+    return SASL_OK;
+}
+
+static void
+PrintBigInt(char *str, mpz_t num)
+{
+    char buf[4096];
+
+    mpz_get_str (buf, 10, num);
+
+    VL(("%s Big Int is %s\n",str, buf));
+
+}
+
+/*
+ * Calculate 'x' which is needed to calculate 'K'
+ *
+ */
+static int
+CalculateX(sasl_utils_t *utils,
+	   const char *salt, 
+	   int saltlen, 
+	   const char *user, 
+	   const char *pass, 
+	   int passlen, 
+	   mpz_t *x)
+{
+    MD5_CTX md5ctx;
+    char hash[16]; /* xxx */
+
+    /* x = H(salt | user | ':' | pass)
+     *
+     */      
+
+    utils->MD5Init(&md5ctx);
+
+    utils->MD5Update(&md5ctx, salt, saltlen);
+
+    utils->MD5Update(&md5ctx, user, strlen(user));
+    utils->MD5Update(&md5ctx, ":", 1);
+    utils->MD5Update(&md5ctx, pass, passlen);
+
+    utils->MD5Final(hash, &md5ctx);
+
+    DataToBigInt(hash, 16, x);
+
+    return SASL_OK;
+}
+
+/* Calculate shared context key K
+ *
+ * User:  x = H(s, password)
+ * User:  S = (B - g^x) ^ (a + ux)
+ *                  
+ * User:  K = H(S)
+ *
+ */
+static int
+CalculateK_client(sasl_utils_t *utils,
+		  char *salt,
+		  int saltlen,
+		  context_t *text,
+		  char *user,
+		  char *pass,
+		  int passlen,
+		  char **key,
+		  int *keylen)
+{
+    int r;
+    unsigned char hash[16];
+    mpz_t x;
+    mpz_t u;
+    mpz_t aux;
+    mpz_t gx;
+    mpz_t base;
+    mpz_t S;
+
+    r = CalculateX(utils, salt, saltlen, user, pass, passlen, &x);
+    if (r) return r;
+
+    /* gx = g^x */
+    mpz_init(gx);
+    mpz_powm (gx, text->g, x, text->N);
+
+    /* base = B - gx */
+    mpz_init(base);
+    mpz_sub(base, text->B, gx);
+
+    /* u is first 32 bits of B hashed; MSB first */
+    r = HashBigInt(utils, text->B, hash);
+    if (r) return r;
+    mpz_init(u);
+    DataToBigInt(hash, 4, &u);
+
+    /* a + ux */
+    mpz_init(aux);
+    mpz_mul(aux, u, x);
+    mpz_add(aux, aux, text->a);
+
+    /* S = base^aux % N */
+    mpz_init(S);
+    mpz_powm (S, base, aux, text->N);    
+
+    /* K = Hi(S) */
+    r = HashInterleaveBigInt(utils, S, key, keylen);
+    if (r) return r;
+
+    return SASL_OK;
+}
+
+
+
+/*
+ *  H(
+ *            bytes(H( bytes(N) )) ^ bytes( H( bytes(g) )))
+ *          | bytes(H( bytes(U) ))
+ *          | bytes(s)
+ *          | bytes(H( bytes(L) ))
+ *          | bytes(A)
+ *          | bytes(B)
+ *          | bytes(K)
+ *      )
+ *
+ * H() is the result of digesting the designated input/data with the
+ * underlying Message Digest Algorithm function (see Section 1).
+ *
+ * ^ is the bitwise XOR operator.
+ */
+static int
+CalculateM1(sasl_utils_t *utils,
+	    mpz_t N,
+	    mpz_t g,
+	    char *U,     /* username */
+	    char *salt, int saltlen,  /* salt */
+	    char *L,     /* server's options */
+	    mpz_t A,     /* client's public key */
+	    mpz_t B,     /* server's public key */
+	    char *K, int Klen,
+	    char **out, int *outlen)
+{
+    int i;
+    int r;
+    unsigned char p1a[16];
+    unsigned char p1b[16];
+    unsigned char p1[16];
+    int p1len;
+    char p2[16];
+    int p2len;
+    char *p3;
+    int p3len;
+    char p4[16];
+    int p4len;
+    char p5[1024];
+    int p5len;
+    char p6[1024];
+    int p6len;
+    char *p7;
+    int p7len;
+    char *tot;
+    int totlen = 0;
+    char *totp;
+
+    /* p1) bytes(H( bytes(N) )) ^ bytes( H( bytes(g) )) */
+    r = HashBigInt(utils, N, p1a);
+    if (r) return r;
+    r = HashBigInt(utils, g, p1b);
+    if (r) return r;
+
+    for (i = 0; i < 16; i++) {
+	p1[i] = (p1a[i] ^ p1b[i]);
+    }
+    p1len = 16;
+
+    /* p2) bytes(H( bytes(U) )) */
+    HashData(utils, U, strlen(U), p2);
+    p2len = 16;
+
+    /* p3) bytes(s) */
+    p3 = salt;
+    p3len = saltlen;
+
+    /* p4) bytes(H( bytes(L) )) */
+    HashData(utils, L, strlen(L), p4);
+    p4len = 16;
+
+    /* p5) bytes(A) */
+    r = BigIntToBytes(A, p5, sizeof(p5), &p5len);
+    if (r) return r;
+    
+    /* p6) bytes(B) */
+    r = BigIntToBytes(B, p6, sizeof(p6), &p6len);
+    if (r) return r;
+
+    /* p7) bytes(K) */
+    p7 = K;
+    p7len = Klen;
+
+    /* merge p1-p7 together */
+    totlen = p1len + p2len + p3len + p4len + p5len + p6len + p7len;
+    tot = utils->malloc(totlen);
+    if (!tot) return SASL_NOMEM;
+
+    totp = tot;
+
+    memcpy(totp, p1, p1len); totp+=p1len;
+    memcpy(totp, p2, p2len); totp+=p2len;
+    memcpy(totp, p3, p3len); totp+=p3len;
+    memcpy(totp, p4, p4len); totp+=p4len;
+    memcpy(totp, p5, p5len); totp+=p5len;
+    memcpy(totp, p6, p6len); totp+=p6len;
+    memcpy(totp, p7, p7len); totp+=p7len;
+
+    /* do the hash over the whole thing */
+    *out = utils->malloc(16);
+    if (!*out) {
+	utils->free(tot);
+	return SASL_NOMEM;
+    }
+    *outlen = 16;
+
+    HashData(utils, tot, totlen, *out);
+    utils->free(tot);
+
+    return SASL_OK;
+}
+
+/*
+ *          H(
+ *                  bytes(A)
+ *                | bytes(H( bytes(U) ))
+ *                | bytes(H( bytes(I) ))
+ *                | bytes(H( bytes(o) ))
+ *                | bytes(M1)
+ *                | bytes(K)
+ *            )
+ *
+ *
+ *where: 
+ *
+ * H() is the result of digesting the designated input/data with the
+ * underlying Message Digest Algorithm function (see Section 1)
+ *
+ */
+static int
+CalculateM2(sasl_utils_t *utils,
+	    mpz_t A,
+	    char *U,
+	    char *I,
+	    char *o,
+	    char *M1, int M1len,
+	    char *K, int Klen,
+	    char **out, int *outlen)
+{
+    int r;
+    unsigned char p1[1024];
+    int p1len;
+    char p2[16];
+    int p2len;
+    char p3[16];
+    int p3len;
+    char p4[16];
+    int p4len;
+    char *p5;
+    int p5len;
+    char *p6;
+    int p6len;
+    char *tot;
+    int totlen = 0;
+    char *totp;
+
+    /* p1) bytes(A) */
+    r = BigIntToBytes(A, p1, sizeof(p1), &p1len);
+    if (r) return r;    
+
+    /* p2) bytes(H( bytes(U) )) */
+    HashData(utils, U, strlen(U), p2);
+    p2len = 16;
+
+    /* p3) bytes(H( bytes(I) )) */
+    HashData(utils, I, strlen(I), p3);
+    p3len = 16;
+
+    /* p4) bytes(H( bytes(o) )) */
+    HashData(utils, o, strlen(o), p4);
+    p4len = 16;
+
+    /* p5)  bytes(M1) */
+    p5 = M1;
+    p5len = M1len;
+    
+    /* bytes(K) */
+    p6 = K;
+    p6len = Klen;
+	
+    /* merge p1-p6 together */
+    totlen = p1len + p2len + p3len + p4len + p5len + p6len;
+    tot = utils->malloc(totlen);
+    if (!tot) return SASL_NOMEM;
+
+    totp = tot;
+
+    memcpy(totp, p1, p1len); totp+=p1len;
+    memcpy(totp, p2, p2len); totp+=p2len;
+    memcpy(totp, p3, p3len); totp+=p3len;
+    memcpy(totp, p4, p4len); totp+=p4len;
+    memcpy(totp, p5, p5len); totp+=p5len;
+    memcpy(totp, p6, p6len); totp+=p6len;
+
+    /* do the hash over the whole thing */
+    *out = utils->malloc(16);
+    if (!*out) {
+	return SASL_NOMEM;
+	utils->free(tot);
+    }
+    *outlen = 16;
+
+    HashData(utils, tot, totlen, *out);
+    utils->free(tot);
+
+    return SASL_OK;
+}
+
+/* Parse an option out of an option string
+ * Place found option in 'option'
+ * 'nextptr' points to rest of string or NULL if at end
+ */
+static int
+ParseOption(sasl_utils_t *utils, char *in, char **option, char **nextptr)
+{
+    char *comma;
+    int len;
+    int i;
+
+    if (strlen(in) == 0) {
+	*option = NULL;
+	return SASL_OK;
+    }
+
+    comma = strchr(in,',');    
+    if (comma == NULL) comma = in + strlen(in);
+
+    len = comma - in;
+
+    *option = utils->malloc(len + 1);
+    if (!*option) return SASL_NOMEM;
+
+    /* lowercase string */
+    for (i = 0; i < len; i++) {
+	(*option)[i] = tolower((int)in[i]);
+    }
+    (*option)[len] = '\0';
+
+    if (*comma) {
+	*nextptr = comma+1;
+    } else {
+	*nextptr = NULL;
+    }
+
+    return SASL_OK;
+}
+
+static int
+FindBit(char *name, layer_option_t *opts)
+{
+    while (opts->name) {
+	VL(("Looking for [%s] this is [%s]\n",name,opts->name));
+	if (strcmp(name, opts->name)==0) {
+	    return opts->bit;
+	}
+
+	opts++;
+    }
+
+    return 0;
+}
+
+static layer_option_t *
+FindOptionFromBit(int bit, layer_option_t *opts)
+{
+    while (opts->name) {
+	if (opts->bit == bit) {
+	    return opts;
+	}
+
+	opts++;
+    }
+
+    return NULL;
+}
+
+static int
+ParseOptionString(char *str, srp_options_t *opts)
+{
+    if (strcmp(str,OPTION_REPLAY_DETECTION)==0) {
+	if (opts->replay_detection) {
+	    VL(("Replay Detection option appears twice\n"));
+	    return SASL_FAIL;
+	}
+	opts->replay_detection = 1;
+    } else if (strncmp(str,OPTION_INTEGRITY,strlen(OPTION_INTEGRITY))==0) {
+
+	int bit = FindBit(str+strlen(OPTION_INTEGRITY), integrity_options);
+
+	if (bit == 0) return SASL_OK;
+
+	if (bit & opts->integrity) {
+	    VL(("Option %s exists multiple times\n",str));
+	    return SASL_FAIL;
+	}
+
+	opts->integrity = opts->integrity | bit;
+
+    } else if (strncmp(str,OPTION_CONFIDENTIALITY,strlen(OPTION_CONFIDENTIALITY))==0) {
+
+	int bit = FindBit(str+strlen(OPTION_CONFIDENTIALITY), confidentiality_options);
+	if (bit == 0) return SASL_OK;
+
+	if (bit & opts->confidentiality) {
+	    VL(("Option %s exists multiple times\n",str));
+	    return SASL_FAIL;
+	}
+
+	opts->confidentiality = opts->confidentiality | bit;
+
+    } else {
+	VL(("Option not undersood: %s\n",str));
+	return SASL_FAIL;
+    }
+
+    return SASL_OK;
+}
+
+static int
+ParseOptions(sasl_utils_t *utils, char *in, srp_options_t *out)
+{
+    int r;
+
+    memset(out, 0, sizeof(srp_options_t));
+
+    while (in) {
+	char *opt;
+
+	r = ParseOption(utils, in, &opt, &in);
+	if (r) return r;
+
+	if (opt == NULL) return SASL_OK;
+
+	VL(("Got option: [%s]\n",opt));
+
+	r = ParseOptionString(opt, out);
+	if (r) return r;
+    }
+
+    return SASL_OK;
+}
+
+static layer_option_t *
+FindBest(int available, layer_option_t *opts)
+{
+    while (opts->name) {
+	VL(("FindBest %d %d\n",available, opts->bit));
+
+	if (available & opts->bit) {
+	    return opts;
+	}
+
+	opts++;
+    }
+
+    return NULL;
+}
+
+static int
+OptionsToString(sasl_utils_t *utils, srp_options_t *opts, char **out)
+{
+    char *ret = NULL;
+    int alloced = 0;
+    int first = 1;
+    layer_option_t *optlist;
+
+    ret = utils->malloc(1);
+    if (!ret) return SASL_NOMEM;
+    alloced = 1;
+    ret[0] = '\0';
+
+    if (opts->replay_detection) {
+	alloced += strlen(OPTION_REPLAY_DETECTION)+1;
+	ret = utils->realloc(ret, alloced);
+	if (!ret) return SASL_NOMEM;
+
+	if (!first) strcat(ret, ",");
+	strcat(ret, OPTION_REPLAY_DETECTION);
+	first = 0;
+    }
+
+    optlist = integrity_options;
+    while(optlist->name) {
+	if (opts->integrity & optlist->bit) {
+	    alloced += strlen(OPTION_INTEGRITY)+strlen(optlist->name)+1;
+	    ret = utils->realloc(ret, alloced);
+	    if (!ret) return SASL_NOMEM;
+
+	    if (!first) strcat(ret, ",");
+	    strcat(ret, OPTION_INTEGRITY);
+	    strcat(ret, optlist->name);
+	    first = 0;
+	}
+
+	optlist++;
+    }
+
+    optlist = confidentiality_options;
+    while(optlist->name) {
+	if (opts->confidentiality & optlist->bit) {
+	    alloced += strlen(OPTION_CONFIDENTIALITY)+strlen(optlist->name)+1;
+	    ret = utils->realloc(ret, alloced);
+	    if (!ret) return SASL_NOMEM;
+
+	    if (!first) strcat(ret, ",");
+	    strcat(ret, OPTION_CONFIDENTIALITY);
+	    strcat(ret, optlist->name);
+	    first = 0;
+	}
+
+	optlist++;
+    }
+    
+    *out = ret;
+    return SASL_OK;
+}
+
+static int
+CreateServerOptions(sasl_utils_t *utils,
+		    sasl_security_properties_t *props,
+		    char **out)
+{
+    srp_options_t opts;
+    layer_option_t *optlist;
+
+    /* zero out options */
+    memset(&opts,0,sizeof(srp_options_t));
+
+
+    /* Add integrity options */
+    optlist = integrity_options;
+    while(optlist->name) {
+	if ((props->min_ssf <= 1) && (props->max_ssf >= 1)) {
+	    opts.integrity |= optlist->bit;
+	}
+	optlist++;
+    }
+
+    /* if we set any integrity options we can advertise replay detection */
+    if (opts.integrity) {
+	opts.replay_detection = 1;
+    }
+
+    /* Add integrity options */
+    optlist = confidentiality_options;
+    while(optlist->name) {
+	if (((int)props->min_ssf <= optlist->ssf) && ((int)props->max_ssf >= optlist->ssf)) {
+	    opts.confidentiality |= optlist->bit;
+	}
+	optlist++;
+    }
+
+    return OptionsToString(utils, &opts, out);
+}
+		    
+
+static int
+CreateClientOpts(sasl_client_params_t *params, 
+		 srp_options_t *available, 
+		 srp_options_t *out)
+{
+    int external;
+    int limit;
+    int musthave;
+
+    /* zero out output */
+    memset(out, 0, sizeof(srp_options_t));
+
+    /* get requested ssf */
+    external = params->external_ssf;
+
+    /* what do we _need_?  how much is too much? */
+    if ((int)params->props.max_ssf > external) {
+	limit = params->props.max_ssf - external;
+    } else {
+	limit = 0;
+    }
+    if ((int)params->props.min_ssf > external) {
+	musthave = params->props.min_ssf - external;
+    } else {
+	musthave = 0;
+    }
+
+    /* we now go searching for an option that gives us at least "musthave"
+       and at most "limit" bits of ssf. */
+    if ((limit > 1) && (available->confidentiality)) {
+	VL(("xxx No good privacy layers\n"));
+	return SASL_FAIL;
+    }
+
+    VL(("Available integrity = %d\n",available->integrity));
+
+    if ((limit >= 1) && (musthave <= 1) && (available->integrity)) {
+	/* integrity */
+	layer_option_t *iopt;
+	
+	iopt = FindBest(available->integrity, integrity_options);
+	
+	if (iopt) {
+	    out->integrity = iopt->bit;
+	    return SASL_OK;
+	}
+    }
+
+    if (musthave <= 0) { /* xxx how do we know if server doesn't support no layer??? */
+	/* no layer */
+	return SASL_OK;
+
+    }
+
+    
+    VL(("Can't find an acceptable layer\n"));
+    return SASL_TOOWEAK;
+}
+
+/* Set the options (called my client and server)
+ *
+ * Set up variables/hashes/that sorta thing so layers
+ * will operate properly
+ */
+static int
+SetOptions(srp_options_t *opts,
+	   context_t *text,
+	   sasl_utils_t *utils,
+	   sasl_out_params_t *oparams)
+{
+    text->utils = utils;
+    text->size=-1;
+    text->needsize=4;
+
+    if ((opts->integrity == 0) && (opts->confidentiality == 0)) {
+	oparams->encode = NULL;
+	oparams->decode = NULL;
+	oparams->mech_ssf = 0;
+	VL(("Using no layer\n"));	
+	return SASL_OK;
+    }
+    
+    oparams->encode = &layer_encode;
+    oparams->decode = &layer_decode;
+
+    text->enabled_replay_detection = opts->replay_detection;
+
+    if (opts->integrity) {
+	layer_option_t *iopt;
+
+	text->enabled_integrity_layer = 1;
+	oparams->mech_ssf = 1;
+
+	iopt = FindOptionFromBit(opts->integrity, integrity_options);
+	if (!iopt) {
+	    VL(("Unable to find integrity layer option now\n"));
+	    return SASL_FAIL;
+	}
+
+	text->HashLen    = iopt->HashLen;
+	text->HashInit   = iopt->HashInit;
+	text->HashUpdate = iopt->HashUpdate;
+	text->HashFinal  = iopt->HashFinal;
+    }
+
+    /* conf foo */
+
+    return SASL_OK;
+}
+
+
+typedef struct netstring_s {
+
+    int size;
+    
+    char data[1]; /* allocate to size you need */
+
+} netstring_t;
+
+/* doesn't contain netstring formatting */
+typedef struct netdata_s {
+
+    int size;
+    
+    char data[1]; /* allocate to size you need */
+
+} netdata_t;
+
+
+
+
+static int
+server_start(void *glob_context __attribute__((unused)),
+             sasl_server_params_t *params,
+	     const char *challenge __attribute__((unused)),
+	     int challen __attribute__((unused)),
+	     void **conn,
+	     const char **errstr)
+{
+  context_t *text;
+
+  /* holds state are in */
+  if (!conn)
+      return SASL_BADPARAM;
+
+  /* holds state are in */
+  text = params->utils->malloc(sizeof(context_t));
+  if (text==NULL) return SASL_NOMEM;
 
-    return SASL_OK;
-}
+  memset(text, '\0', sizeof(context_t));
+  text->state = 0;
+  *conn=text;
+  
+  if (errstr)
+      *errstr = NULL;
 
-static int bigint_fromnetdata(netdata_t *ns, sasl_utils_t *utils, mpz_t ret)
-{
-    return bigint_fromstr(ns->data, ns->size, utils,ret);
+  return SASL_OK;
 }
 
-
+#if 0
 /* The probability of a
    false positive is (1/4)**REPS.  A reasonable value of reps is 25. */
 #define REPS 25
@@ -600,415 +1817,465 @@
     return SASL_FAIL;
 }
 
+#endif /* 0 */
+
+/* N in base16 */
+#define BIGN_STRING "AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73"
 
 /* A large safe prime (N = 2q+1, where q is prime) All arithmetic is done modulo N */
-static int generate_N_and_g(mpz_t N,mpz_t bigg)
+static int generate_N_and_g(mpz_t N, mpz_t g)
 {
-
-#define BIGNUM "3Kn/YYiomHkFkfM1x4kayR125MGkzpLUDy3y14FlTMwYnhZkjrMXnoC2TcFAecNlU5kFzgcpKYUbBOPZFRtyf3"
-    {
-	char dec[4000];
-	int declen;
-	int lup;
-
-	lup = sasl_decode64(BIGNUM,strlen(BIGNUM),dec,&declen);
-
-	printf("error = %d\n",lup);
+    int result;
+    
+    mpz_init(N);
+    result = mpz_set_str (N, BIGN_STRING, 16);
+    if (result) return SASL_FAIL;
 
-	printf("len = %d\n",strlen(BIGNUM));
-	printf("declen = %d\n",declen);
+    mpz_init(g);
+    mpz_set_ui (g, 2);
 
-	/*	for (lup=0;lup<declen;lup++) {
-	    printf("%d %d\n",lup,dec[lup]);
-	    }*/
+    return SASL_OK;
+}
 
-	for (lup=0;lup<10;lup++) {
-	    printf("%c",frombits( (dec[lup] >> 4) & 15));
-	    printf("%c",frombits( dec[lup] & 15));
-	}
-	printf("\n");
+static int
+ServerCalculateK(sasl_utils_t *utils, mpz_t v,
+		 mpz_t N, mpz_t g, mpz_t b, mpz_t B, mpz_t A,
+		 char **key, int *keylen)
+{
+    unsigned char hash[16];
+    mpz_t u;
+    mpz_t S;
+    int r;
 
+    /* B = v + g^b */
+    mpz_init(B);
 
-    }
+    mpz_powm(B, g, b, N);
+    mpz_add(B, B, v);
+    mpz_mod(B, B, N);
 
-    /*
-     * 512 bits
-     *  N = dca9ff6188a898790591
-     *  g = 2
+    /* calculate K
+     *
+     * Host:  S = (Av^u) ^ b              (computes session key)
+     * Host:  K = Hi(S)
      */
-
-    {
-	int result;
 
-	mpz_init(N);
-	result = mpz_set_str (N, "dca9ff6188a898790591", 16);
-	if (result) return SASL_FAIL;
-	mpz_init(bigg);
-	mpz_set_ui (bigg, 2);
-    }
+    /* u is first 32 bits of B hashed; MSB first */
+    r = HashBigInt(utils, B, hash);
+    if (r) return r;
+
+    mpz_init(u);
+    DataToBigInt(hash, 4, &u);
+
+    mpz_init(S);
+    mpz_powm(S, v, u, N);
+    mpz_mul(S, S, A);
+    mpz_mod(S, S, N);
+
+    mpz_powm(S, S, b, N);
+
+    /* K = Hi(S) */
+    r = HashInterleaveBigInt(utils, S, key, keylen);
+    if (r) return r;
 
     return SASL_OK;
 }
 
-static void merge_netstrings(sasl_utils_t *utils,
-			     netstring_t *ns1,netstring_t *ns2,netstring_t *ns3,
-			     char **out, int *outlen)
+static int
+server_step1(context_t *text,
+	     sasl_server_params_t *params,
+	     const char *clientin,
+	     int clientinlen,
+	     char **serverout,
+	     int *serveroutlen,
+	     sasl_out_params_t *oparams __attribute__((unused)),
+	     const char **errstr)
 {
-    int totallen;
-    char lenstr[30];
-    char *tmp;
-
-    /* calculate total length of strings */
-    totallen = 0;
-    if (ns1)
-	totallen+=ns1->size;
-    if (ns2)
-	totallen+=ns2->size;
-    if (ns3)
-	totallen+=ns3->size;
-
-    snprintf(lenstr,sizeof(lenstr),"%d:",totallen);
-    
-    *outlen = strlen(lenstr) + totallen + 1;
-    *out = utils->malloc(*outlen);
-    
-    tmp = *out;
-    memcpy(tmp,lenstr, strlen(lenstr));
-    tmp+=strlen(lenstr);
+    char *data;
+    int datalen;
+    int r;    
+    char *mpiN = NULL;
+    int mpiNlen;
+    char *mpig = NULL;
+    int mpiglen;
+    char *utf8L = NULL;
+    int utf8Llen;
+    char *realm = NULL;
+    char *user = NULL;
 
-    if (ns1) {
-	memcpy( tmp, ns1->data, ns1->size);
-	tmp+=ns1->size;
-    }
-    if (ns2) {
-	memcpy( tmp, ns2->data, ns2->size);
-	tmp+=ns2->size;
+    /* if nothing we send nothing and except data next time */
+    if ((clientinlen == 0) && (text->state == 0)) {
+	text->state++;
+	*serverout = NULL;
+	*serveroutlen = 0;
+	return SASL_CONTINUE;
     }
-    if (ns3) {
-	memcpy( tmp, ns3->data, ns3->size);
-	tmp+=ns3->size;
+
+    /* Expect:
+     *  { utf8(U) }
+     *
+     */
+    r = UnBuffer((char *) clientin, clientinlen, &data, &datalen);
+    if (r) {
+	*errstr = "Error 'unbuffer'ing input for step 1";
+	return r;
     }
-    tmp[0]=',';
-}
 
-static int checkvalid_netstring(char *in, int inlen, char **datastart, int *datalen)
-{
-    char lenstr[20];
-    int pos = 0;
-    
-    /* see how big it says it is */
-    while ((pos<inlen) && (pos < (int) sizeof(lenstr)) && (isdigit((int) in[pos]))) {
-	lenstr[pos] = in[pos];
-	pos++;
+    r = GetUTF8(params->utils, data, datalen, &text->authid, &data, &datalen);
+    if (r) {
+	*errstr = "Error getting UTF8 string from input";
+	return r;
     }
-    
-    if (pos == 0) {
-	VL (("netstring doesn't contain length indicator\n"));
+
+    if (datalen != 0) {
+	*errstr = "Extra data to SRP step 1";
 	return SASL_FAIL;
     }
 
-    lenstr[pos]='\0';
-
-    (*datalen) = strtol(lenstr, NULL, 10);
+    /* Get the realm */
+    r = parseuser(params->utils, &user, &realm, params->user_realm,
+		  params->serverFQDN, text->authid);
+    if (r) {
+	*errstr = "Error getting realm";
+	goto fail;
+    }
 
-    if (errno == ERANGE) {
-	VL(("Underflow or overflow occured\n"));
-	return SASL_FAIL;
+    /* Get user data */
+    r = ReadUserInfo(params->utils, user, realm,
+		     &text->N, &text->g, &text->salt, &text->saltlen, &text->v, errstr);
+    if (r) {
+	/* readuserinfo sets errstr */
+	goto fail;
     }
 
-    if ((*datalen) < 0) {
-	VL(("Negative netstring length\n"));
-	return SASL_FAIL;
+    r = CreateServerOptions(params->utils, &params->props, &text->server_options);
+    if (r) {
+	*errstr = "Error creating server options";
+	goto fail;
     }
 
-    if (inlen < pos+1+(*datalen)+1) {
-	VL(("Netsrring wrong size (%d vs %d)\n", inlen, pos+1+(*datalen)+1));
-	return SASL_FAIL;
+    /* Send out:
+     *
+     * L = server_options (avaible layers etc)
+     *
+     * { mpi(N) mpi(g) utf8(L) }
+     *
+     */
+    
+    r = MakeMPI(params->utils, text->N, &mpiN, &mpiNlen);
+    if (r) {
+	*errstr = "Error creating 'mpi' string for N";
+	goto fail;
     }
     
-    if (in[pos]!=':') {
-	VL(("Netstring missing required colon\n"));
-	return SASL_FAIL;
+    r = MakeMPI(params->utils, text->g, &mpig, &mpiglen);
+    if (r) {
+	*errstr = "Error creating 'mpi' string for g";
+	goto fail;
     }
-
-    if (in[pos+(*datalen)+1]!=',') {
-	VL(("Netstring missing required comma\n"));
-	return SASL_FAIL;
+    
+    r = MakeUTF8(params->utils, text->server_options, &utf8L, &utf8Llen);
+    if (r) {
+	*errstr = "Error creating 'UTF8' string for L (server options)";
+	goto fail;
     }
-
-    *datastart = in+pos+1;
-
-    return SASL_OK;
-}
-
-static int split_netstrings(sasl_utils_t *utils,
-			    netdata_t **nd1, netdata_t **nd2, netdata_t **nd3,
-			    char *in, int inlen)
-{
-    char *datastart, *ns_str;
-    int datalen, ns_len;
-    int result;
-
-    /*    int lup;
     
-        for (lup=0;lup<inlen;lup++)
-    {
-	if (isalnum(in[lup]))
-	    printf("%d %c %d\n",lup,in[lup],in[lup]);
-	else
-	    printf("%d ? %d\n",lup,in[lup]);
-	    } */
-
-    result = checkvalid_netstring(in, inlen, &datastart, &datalen);
-    if (result!=SASL_OK) return result;
-
-    if (nd1) {
-	result = checkvalid_netstring(datastart, datalen, &ns_str, &ns_len);
-	if (result!=SASL_OK) return result;
-
-	*nd1 = utils->malloc(sizeof(netstring_t)+ns_len+1);
-	if (!*nd1) return SASL_NOMEM;
-
-	(*nd1)->size = ns_len;
-	memcpy((*nd1)->data, ns_str, ns_len);
-	(*nd1)->data[ns_len] = '\0';
-
-	datastart = ns_str+ns_len+1;
+    r = MakeBuffer(params->utils, mpiN, mpiNlen, mpig, mpiglen, utf8L, utf8Llen, NULL, 0,
+		   serverout, serveroutlen);
+    if (r) {
+	*errstr = "Error creating SRP buffer from data in step 1";
+	goto fail;
     }
 
-    if (nd2) {
-
-	result = checkvalid_netstring(datastart, datalen, &ns_str, &ns_len);
-	if (result!=SASL_OK) return result;
+    r = SASL_CONTINUE;
+    text->state = 2;
 
-	*nd2 = utils->malloc(sizeof(netstring_t)+ns_len+1);
-	if (!*nd2) return SASL_NOMEM;
+ fail:
 
-	(*nd2)->size = ns_len;
-	memcpy((*nd2)->data, ns_str, ns_len);
-	(*nd2)->data[ns_len] = '\0';
+    if (user)   params->utils->free(user);
+    if (realm)  params->utils->free(realm);
+    if (mpiN)   params->utils->free(mpiN);
+    if (mpig)   params->utils->free(mpig);
+    if (utf8L)  params->utils->free(utf8L);
 
-	datastart = ns_str+ns_len+1;
-    }
+    return r;
+}
 
-    if (nd3) {
-	result = checkvalid_netstring(datastart, datalen, &ns_str, &ns_len);
-	if (result!=SASL_OK) return result;
+static int
+server_step2(context_t *text,
+	     sasl_server_params_t *params,
+	     const char *clientin,
+	     int clientinlen,
+	     char **serverout,
+	     int *serveroutlen,
+	     sasl_out_params_t *oparams __attribute__((unused)),
+	     const char **errstr)
+{
+    char *data;
+    int datalen;
+    int r;    
+    char *osS = NULL;
+    int osSlen;
+    char *mpiB = NULL;
+    int mpiBlen;
+    srp_options_t client_opts;
 
-	*nd3 = utils->malloc(sizeof(netstring_t)+ns_len+1);
-	if (!*nd3) return SASL_NOMEM;
+    /* Expect:
+     *
+     * o = client options
+     *
+     * { utf8(I) mpi(A) utf8(o) }
+     *
+     */
+    r = UnBuffer((char *) clientin, clientinlen, &data, &datalen);
+    if (r) {
+	*errstr = "Error UnBuffering input in step 2";
+	return r;
+    }
 
-	(*nd3)->size = ns_len;
-	memcpy((*nd3)->data, ns_str, ns_len);
-	(*nd3)->data[ns_len] = '\0';
+    r = GetUTF8(params->utils, data, datalen, &text->userid, &data, &datalen);
+    if (r) {
+	*errstr = "Error parsing out userid";
+	return r;
+    }
 
-	datastart = ns_str+ns_len+1;
+    r = GetMPI(data, datalen, &text->A, &data, &datalen);
+    if (r) {
+	*errstr = "Error parsing out 'A'";
+	return r;
     }
 
-    VL(("netstring split worked\n"));
-    
-    return SASL_OK;
-}
+    r = GetUTF8(params->utils, data, datalen, &text->client_options, &data, &datalen);
+    if (r) {
+	*errstr = "Error parsing out client options 'o'";
+	return r;
+    }
 
-static int calculate_server_evidence(char *authname,
-				     mpz_t A,
-				     unsigned char client_options,
-				     hash_t *M1,
-				     interleaved_t *K,
-				     hash_t *out,
-				     sasl_utils_t *utils)
-{
-    char *concatstr;
-    int len;
-    char *M2;
-    netdata_t *tmpnd;
+    if (datalen != 0) {
+	*errstr = "Extra data in request step 2";
+	return SASL_FAIL;
+    }
 
-    tmpnd = create_netdata_bigint(A, utils);
-    if (tmpnd==NULL) return SASL_NOMEM;
+    /* Generate b */
+    GetRandBigInt(text->b);
 
-    len = strlen(authname) + tmpnd->size + 1 + HASHLEN + sizeof(K->data);
+    /* Calculate K (and B) */
+    r = ServerCalculateK(params->utils, text->v,
+			 text->N, text->g, text->b, text->B, text->A,
+			 &text->K, &text->Klen);
+    if (r) {
+	*errstr = "Error calculating K";
+	return r;
+    }
 
-    concatstr = (char *) utils->malloc(len+1);
-    if (!concatstr) return SASL_NOMEM;
+    /* parse client options */
+    r = ParseOptions(params->utils, text->client_options, &client_opts);
+    if (r) {
+	*errstr = "Error parsing user's options";
+	return r;
+    }
 
-    /* Server calculate evidence M2
-     * M2 = H(U | A | o | M1 | K)
-    */
+    r = SetOptions(&client_opts, text, params->utils, oparams);
+    if (r) {
+	*errstr = "Error setting options";
+	return r;   
+    }
 
-    M2 = (char *) concatstr;
+    /* Send out:
+     *
+     * s - salt
+     * B - server's public key
+     *
+     * { os(s) mpi(B) }
+     */
     
-    /* add U (authname) */
-    memcpy(M2, authname, strlen(authname));
-    M2+=strlen(authname);
-
-    /* append A */
-    memcpy(M2,tmpnd->data, tmpnd->size);
-    M2+=tmpnd->size;
-    utils->free(tmpnd);    
-
-    /* append o (options) */
-    M2[0] = client_options;
-    M2+=1;
-
-    /* append M1 */
-    memcpy(M2, M1->data, sizeof(M1->data));
-    M2+=sizeof(M1->data);
-
-    /* append K */
-    memcpy(M2, K->data, sizeof(K->data));
+    r = MakeOS(params->utils, text->salt, text->saltlen, &osS, &osSlen);
+    if (r) {
+	*errstr = "Error turning salt into 'os' string";
+	goto end;
+    }
     
-    Hash(concatstr, len, out);
-
-    return SASL_OK;
-}
-
-static int calculate_client_evidence(mpz_t N, mpz_t g,
-				     char *salt, int saltlen,
-				     unsigned char server_options,
-				     mpz_t A, mpz_t B,
-				     interleaved_t *K,
-				     hash_t *out,
-				     sasl_utils_t *utils)
-{
-    hash_t Hn;
-    hash_t Hg;
-    char concatstr[HASHLEN+MAXBIGNUMLEN+1+MAXBIGNUMLEN+MAXBIGNUMLEN+HASHLEN*2];
-    char *M1;
-    int lup;
-    netdata_t *tmpnd;
-
-    /* Client calculate evidence M1
-       M1 = H(H(N) XOR H(g) | s | Z | A | B | K)
-    */
-
-    Hash_bigint(N, &Hn, utils);
-    Hash_bigint(g, &Hg, utils);
+    r = MakeMPI(params->utils, text->B, &mpiB, &mpiBlen);
+    if (r) {
+	*errstr = "Error turning 'B' into 'mpi' string";
+	goto end;
+    }
     
-    /* Hn XOR Hg into Hn*/
-    for (lup=0;lup<HASHLEN;lup++)
-	Hn.data[lup]=Hn.data[lup]^Hg.data[lup];
-
-    M1 = (char *) concatstr;
-    memcpy(M1,Hn.data, HASHLEN);
-    M1+=HASHLEN;
+    r = MakeBuffer(params->utils, osS, osSlen, mpiB, mpiBlen, NULL, 0, NULL, 0,
+		   serverout, serveroutlen);
+    if (r) {
+	*errstr = "Error putting all the data together in step 2";
+	goto end;
+    }
     
-
-    /* append salt */
-    memcpy(M1,salt, saltlen);
-    M1+=saltlen;
-
-    /* append Z (options) */
-    M1[0] = server_options;
-    M1+=1;
-
-    /* append A */
-    tmpnd = create_netdata_bigint(A, utils);
-    if (tmpnd==NULL) return SASL_NOMEM;
-    memcpy(M1,tmpnd->data, tmpnd->size);
-    M1+=tmpnd->size;
-    utils->free(tmpnd);
-
-    /* append B */
-    tmpnd = create_netdata_bigint(B, utils);
-    if (tmpnd==NULL) return SASL_NOMEM;
-    memcpy(M1,tmpnd->data, tmpnd->size);
-    M1+=tmpnd->size;
-    utils->free(tmpnd);
-
-    /* append K */
-    memcpy(M1, K->data, sizeof(K->data));
-    M1+=sizeof(K->data);
+    text->state ++;
+    r = SASL_CONTINUE;
 
-    Hash(concatstr, M1-concatstr, out);
+ end:
+    if (osS)     params->utils->free(osS);
+    if (mpiB)    params->utils->free(mpiB);
 
-    return SASL_OK;
+    return r;
 }
 
-
 
-
-static int get_salt_and_verifier(const char *userid, const char *realm,
-				 sasl_utils_t *utils, savedinfo_t **sinfo,
-				 const char **errstr)
+static int
+server_step3(context_t *text,
+	     sasl_server_params_t *params,
+	     const char *clientin,
+	     int clientinlen,
+	     char **serverout,
+	     int *serveroutlen,
+	     sasl_out_params_t *oparams __attribute__((unused)),
+	     const char **errstr)
 {
-    sasl_server_getsecret_t *getsecret;
-    void *getsecret_context;
-    sasl_secret_t *sec=NULL;
-    int result;
-    int saltlen=16;
-    char *vstr;
-    int vlen;
-
-    /* get callback so we can request the secret */
-    result = utils->getcallback(utils->conn,
-				SASL_CB_SERVER_GETSECRET,
-				&getsecret,
-				&getsecret_context);
-    if (result != SASL_OK) {
-	VL(("result = %i trying to get secret callback\n",result));
-	return result;
+    char *data;
+    int datalen;
+    int r;    
+    char *M1 = NULL;
+    int M1len;
+    char *myM1 = NULL;
+    int myM1len;
+    char *M2 = NULL;
+    int M2len;
+    int i;
+    char *osM2 = NULL;
+    int osM2len;
+    
+    /* Expect:
+     *
+     * M1 = client evidence
+     *
+     * { os(M1) }
+     *
+     */
+    r = UnBuffer((char *) clientin, clientinlen, &data, &datalen);
+    if (r) {
+	*errstr = "Error parsing input buffer in step 3";
+	goto end;
     }
-    if (! getsecret) {
-	VL(("Received NULL getsecret callback\n"));
-	return SASL_FAIL;
+
+    r = GetOS(params->utils, data, datalen, &M1,&M1len, &data, &datalen);
+    if (r) {
+	*errstr = "Error getting 'os' M1 (client evidenice)";
+	goto end;
     }
 
-    /* Request secret */
-    result = getsecret(getsecret_context, "SRP", userid, realm, &sec);
-    if (result == SASL_NOUSER || !sec) {
-      if (errstr) *errstr = "no secret in database";
-      return SASL_NOUSER;
+    if (datalen != 0) {
+	r = SASL_FAIL;
+	*errstr = "Extra data in input SRP step 3";
+	goto end;
     }
-    if (result != SASL_OK) {
-	return result;
+
+    /* See if M1 is correct */
+    r = CalculateM1(params->utils, text->N, text->g, text->authid, text->salt, text->saltlen,
+		    text->server_options, text->A, text->B, text->K, text->Klen,
+		    &myM1, &myM1len);
+    if (r) {	
+	*errstr = "Extra calculating M1";
+	goto end;
     }
 
-    if (sec->len < saltlen) {
-	VL(("Secret database corruption (size %d)\n",sec->len));
-	if (errstr) *errstr = "secret database corruption";
-	return SASL_FAIL;
+    if (myM1len != M1len) {
+	*errstr = "M1 lengths do not match";
+	VL(("M1 lengths do not match: %d vs %d",M1len, myM1len));
+	goto end;
     }
 
-    /* data is in format
+    for (i = 0; i < myM1len; i++) {
+	if (myM1[i] != M1[i]) {
+	    *errstr = "client evidence does not match what we calculated. Probably a password error";
+	    r = SASL_BADAUTH;
+	    goto end;
+	}
+    }
+
+    /* calculate M2 to send */
+    r = CalculateM2(params->utils, text->A, text->authid, text->userid,
+		    text->client_options, myM1, myM1len, text->K, text->Klen,
+		    &M2, &M2len);
+    if (r) {
+	*errstr = "Error calculating M2 (server evidence)";
+	goto end;
+    }
+    
+    /* Send out:
+     *
+     * M2 = 
      *
-     * salt - series of bytes
-     * verifier - netstring
-     */    
-    *sinfo = (savedinfo_t *) utils->malloc(sizeof(savedinfo_t));
-    if (!*sinfo) return SASL_NOMEM;
+     * { os(M2) }
+     */
+    
+    r = MakeOS(params->utils, M2, M2len, &osM2, &osM2len);
+    if (r) {
+	*errstr = "Error making 'os' string from M2 (server evidence)";
+	goto end;
+    }
+    
+    r = MakeBuffer(params->utils, osM2, osM2len, NULL, 0, NULL, 0, NULL, 0,
+		   serverout, serveroutlen);
+    if (r) {
+	*errstr = "Error making output buffer in SRP step 3";
+	goto end;
+    }
+    
+    text->state ++;
+    r = SASL_CONTINUE;
+ end:
 
-    saltlen = sizeof( (*sinfo)->salt);
+    if (osM2)   params->utils->free(osM2);
+    if (M2)     params->utils->free(M2);
+    if (myM1)   params->utils->free(myM1);
+    if (M1)     params->utils->free(M1);
 
-    memcpy( (*sinfo)->salt, sec->data, saltlen);
+    return r;    
+}
 
-    result = checkvalid_netstring((char *) sec->data+saltlen,sec->len-saltlen, &vstr, &vlen);
-    if (result!=SASL_OK) {
-	VL(("Invalid netstring saved. Database corrupted\n"));
-	return result;          
+static int
+server_step4(context_t *text,
+	     sasl_server_params_t *params __attribute__((unused)),
+	     const char *clientin __attribute__((unused)),
+	     int clientinlen,
+	     char **serverout,
+	     int *serveroutlen,
+	     sasl_out_params_t *oparams,
+	     const char **errstr)
+{
+    if (clientinlen > 0) {
+	*errstr = "Data is not valid in SRP step 4";
+	return SASL_FAIL;
     }
 
-    result = bigint_fromstr(vstr, vlen, utils, (*sinfo)->verifier);
-    if (result!=SASL_OK) {
-	VL(("Unable to make bigint from string\n"));
-	return result;
-    }
+    /* Set oparams */
+    oparams->doneflag=1;
+
+    oparams->authid = text->authid;
+    text->authid = NULL; /* set to null so we don't free */
+    oparams->user = text->userid; /* set username */
+    text->userid = NULL; /* set to null so we don't free */
+    oparams->realm = NULL;
     
+    oparams->param_version = 0;
+
+    *serverout = NULL;
+    *serveroutlen = 0;
+
+    text->state++;
     return SASL_OK;
 }
 
-
 static int
-server_continue_step (void *conn_context,
-	       sasl_server_params_t *sparams,
-	       const char *clientin,
-	       int clientinlen,
-	       char **serverout,
-	       int *serveroutlen,
-	       sasl_out_params_t *oparams,
-	       const char **errstr)
+server_continue_step(void *conn_context,
+		     sasl_server_params_t *sparams,
+		     const char *clientin,
+		     int clientinlen,
+		     char **serverout,
+		     int *serveroutlen,
+		     sasl_out_params_t *oparams,
+		     const char **errstr)
 {
-  int result;
   context_t *text = (context_t *) conn_context;
+  const char *myerrstr;
 
   if (!sparams
       || !serverout
@@ -1019,216 +2286,27 @@
   if (clientinlen < 0)
       return SASL_BADPARAM;
 
-  if (errstr)
-      *errstr = NULL;
+  if (!errstr) errstr = &myerrstr;
+  *errstr = NULL;
 
   VL(("SRP server step %d\n",text->state));
-
-  if (text->state == 1) {
-      netstring_t *ns1;
-      netstring_t *ns2;
-      netstring_t *ns3;
-
-      /* Server sends N, g, and Z */
-
-      /*
-       * N  - A large safe prime (N = 2q+1, where q is prime) All arithmetic is done modulo N 
-       * g  - generator
-       */
-
-       /* generate N and g */
-       result = generate_N_and_g(text->N,text->g);
-       if (result!=SASL_OK) return result;
-
-       /* set Z */
-       /* xxx everything off right now */
-       text->server_options = 0;
-       
-       ns1 = create_netstring_bigint(text->N,sparams->utils);
-       ns2 = create_netstring_bigint(text->g,sparams->utils);
-       ns3 = create_netstring_str(&(text->server_options),1,sparams->utils);
-
-       /* put them all together */
-       merge_netstrings(sparams->utils,ns1,ns2,ns3, serverout, serveroutlen);
 
-       text->state = 2;
-
-       return SASL_CONTINUE;
-  }
-  if (text->state == 2) {
-      netdata_t *nd1=NULL;
-      netdata_t *nd2=NULL;
-      netdata_t *nd3=NULL;
-
-      netstring_t *ns1=NULL;
-      netstring_t *ns2=NULL;
-      int result;
-      hash_t hashedB;
-      unsigned int u;
-      mpz_t x;
-
-      /* We received:
-       *
-       * U - authname 
-       * A - client's public key
-       * o - options
-       */
-
-      result = split_netstrings(sparams->utils, &nd1,&nd2,&nd3,
-				(char *) clientin, clientinlen);
-      if (result!=SASL_OK) return result;
-
-      result = bigint_fromnetdata(nd2,sparams->utils ,text->A);
-      if (result!=SASL_OK) return result;
-
-      printf("server A: ");
-      mpz_out_str (stdout, 10, text->A);
-      printf("\n");
+  switch(text->state)
+      {
+      case 0:
+      case 1: return server_step1(text, sparams, clientin, clientinlen,
+				  serverout, serveroutlen, oparams, errstr);
+      case 2: return server_step2(text, sparams, clientin, clientinlen,
+				  serverout, serveroutlen, oparams, errstr);
+      case 3: return server_step3(text, sparams, clientin, clientinlen,
+				  serverout, serveroutlen, oparams, errstr);
+      case 4: return server_step4(text, sparams, clientin, clientinlen,
+				  serverout, serveroutlen, oparams, errstr);
 
-      if (nd3->size!=1) {
-	  VL(("Options is wrong size\n"));
+      default:
+	  *errstr = "Invalid SRP server step";
 	  return SASL_FAIL;
       }
-      text->client_options = nd3->data[0];
-
-      /* xxx do something with options */
-      
-      /* We send:
-       *
-       * s - salt
-       * B - server public key
-       */
-
-      result = parseuser(sparams->utils, &text->authid, &text->realm, sparams->user_realm,
-			 sparams->serverFQDN, nd1->data);
-      if (result != SASL_OK) {
-	  return result;
-      }
-
-      printf("authid = %s realm = %s\n",text->authid,text->realm);
-
-      result = get_salt_and_verifier(text->authid,text->realm,
-				     sparams->utils, &(text->sinfo), errstr);
-      if (result!=SASL_OK) return result;
-
-      VL(("Retrieved salt from db\n"));
-
-      ns1 = create_netstring_str(text->sinfo->salt, sizeof(text->sinfo->salt), sparams->utils);
-
-      VL(("Calculating B\n"));
-
-      /* B = (v + g^b) %N */
-      result = create_public_server(text->g, text->N, text->sinfo->verifier, text->b, text->B);
-      if (result!=SASL_OK) return result;
-
-      ns2 = create_netstring_bigint(text->B, sparams->utils);
-
-      printf("server B: ");
-      mpz_out_str (stdout, 10, text->B);
-      printf("\n");
-
-      /* u is first 32 bits of B; MSB first */      
-      Hash_bigint(text->B, &hashedB, sparams->utils);
-      memcpy(&u, hashedB.data, 4);
-      u = ntohl(u);
-
-      printf("U = %d\n",u);
-
-      /* calculate server shared secret */
-      /* S = (A*v^u)^b %N */
-
-      mpz_init(text->S);
-
-      mpz_powm_ui (text->S, text->sinfo->verifier, u, text->N);      
-      mpz_mul (text->S, text->S, text->A);
-      mpz_powm (text->S, text->S, text->b, text->N);
-
-      result = SHA_Interleave(text->S, &text->sharedsecretK, sparams->utils);
-      if (result!=SASL_OK) return result;
-
-      printf("server calculated S: ");
-      mpz_out_str (stdout, 10, text->S);
-      printf("\n");
-
-      merge_netstrings(sparams->utils,ns1,ns2,NULL,serverout,serveroutlen);
-
-      text->state = 3;
-
-      return SASL_CONTINUE;
-  }
-
-  if (text->state == 3) {
-
-      netstring_t *ns1=NULL;      
-      unsigned char *M1in;
-      int M1inlen;
-      hash_t M1;
-      hash_t M2;
-      int lup;
-
-      /*
-       * Recieve M1 evidence
-       *
-       */
-      result = checkvalid_netstring((char *) clientin, clientinlen, (char **) &M1in, &M1inlen);
-      if (result!=SASL_OK) return result;      
-
-      /* Let's calculate M1 ourselves and see if it matches */
-      result = calculate_client_evidence(text->N, text->g,
-					 text->sinfo->salt, sizeof(text->sinfo->salt),
-					 text->server_options,
-					 text->A, text->B,
-					 &text->sharedsecretK,
-					 &M1,
-					 sparams->utils);
-      if (result!=SASL_OK) return result;      
-      
-      for (lup=0;lup<HASHLEN;lup++)
-      {
-	  if (M1in[lup]!=M1.data[lup]) {
-	      if (errstr) *errstr = "Client evidence is wrong";
-	      return SASL_BADAUTH;
-	  }
-      }
-
-      /*
-       * Calculate and send:
-       *  M2
-       */
-
-      result = calculate_server_evidence(text->authid,
-					 text->A,
-					 text->client_options,
-					 &M1,
-					 &text->sharedsecretK,
-					 &M2,
-					 sparams->utils);
-      if (result!=SASL_OK) return result;      
-      
-      ns1 = create_netstring_str(M2.data, sizeof(M2.data), sparams->utils);
-      if (ns1==NULL) return SASL_NOMEM;
-      
-      *serverout = sparams->utils->malloc(ns1->size+1);
-      if (!*serverout) return SASL_NOMEM;
-      memcpy(*serverout, ns1->data, ns1->size);
-      *serveroutlen = ns1->size;
-
-      /* Set the oparams */
-      oparams->doneflag=1;
-      result = srp_strdup(sparams->utils, text->authid, &oparams->user, NULL); 
-      result = srp_strdup(sparams->utils, text->realm, &oparams->realm, NULL); 
-      result = srp_strdup(sparams->utils, text->authid, &oparams->authid, NULL);
-      oparams->mech_ssf = 0;
-      oparams->maxoutbuf = 0;
-      oparams->encode = NULL;
-      oparams->decode = NULL;
-      oparams->param_version = 0;
-
-      text->state = 4;
-      return SASL_OK;
-  }
-
-  return SASL_FAIL;
 }
 
 /*
@@ -1290,205 +2368,282 @@
   return result;
 }
 
-static int calculate_x(sasl_utils_t *utils,
-		       const char *user, int userlen,
-		       const char *pass, int passlen,
-		       char *salt, int saltlen,
-		       mpz_t x)
-{
-    char *userpassstr = NULL;
-    char *saltfoo =NULL;
-    hash_t userpasshash;
-    hash_t hashx;
-    int result;
 
-    /* create <username> | ':' | <pass> */
-    userpassstr = utils->malloc(userlen+1+passlen+1);
-    if (!userpassstr) {
-	result = SASL_NOMEM;
-	goto done;
+/* xxx this can leak */
+static int
+ReadUserInfo(sasl_utils_t *utils, char *authid, char *realm,
+	     mpz_t *N, mpz_t *g, char **salt, int *saltlen, mpz_t *v, const char **errstr)
+{
+    sasl_secret_t  *sec = NULL;
+    sasl_server_getsecret_t *getsecret;
+    void *getsecret_context;
+    int r;
+    char *data;
+    int datalen;
+
+    r = utils->getcallback(utils->conn,
+			   SASL_CB_SERVER_GETSECRET,
+			   (int (**) ()) &getsecret,
+			   &getsecret_context);
+
+    if ((r != SASL_OK) || (!getsecret)) {
+	*errstr = "Error getting getsecret callback";
+	return r;
     }
-	
-    strcpy(userpassstr, user);
-    userpassstr[userlen]=':';
-    memcpy(userpassstr+userlen+1, pass, passlen);
-    userpassstr[userlen+1+passlen]='\0';
-
-    /* SHA( <username> | ':' | <pass> ) */
-    Hash(userpassstr, userlen+1+passlen, &userpasshash);
-    
-    /* create <salt> | SHA ( ... ) */
-    saltfoo = utils->malloc(saltlen+HASHLEN+1);
-    if (!saltfoo) {
-	result = SASL_NOMEM;
-	goto done;
+
+    /* We use the user's DIGEST secret */
+    r = getsecret(getsecret_context, "SRP-MD5-120", authid, realm, &sec);
+    if ((r) || (!sec)) {
+	*errstr = "unable to get user's secret";
+	return r;
     }
-    
-    memcpy(saltfoo, salt, saltlen);
-    memcpy(saltfoo+saltlen, userpasshash.data, HASHLEN);
 
-    /* x = SHA( <salt> | SHA (... )) */
-    Hash(saltfoo, saltlen+HASHLEN, &hashx);
+    /* The secret data is encoded just like data we send over the wire. It has
+     *
+     *  salt - os 
+     *  N    - mpi
+     *  g    - mpi
+     *  v    - mpi
+     */
+    r = UnBuffer(sec->data, sec->len, &data, &datalen);
+    if (r) {
+	*errstr = "Error UnBuffering secret data";
+	goto end;
+    }
 
-    result = bigint_fromstr(hashx.data, sizeof(hashx.data), utils, x);
-    if (result!=SASL_OK) goto done;
+    r = GetOS(utils, data, datalen, salt, saltlen, &data, &datalen);
+    if (r) {
+	*errstr = "Error parsing out salt";
+	goto end;
+    }
 
- done:
-    
-    if (userpassstr) utils->free(userpassstr);
-    if (saltfoo) utils->free(saltfoo);
+    r = GetMPI(data, datalen, N, &data, &datalen);
+    if (r) {
+	*errstr = "Error parsing out 'N'";
+	goto end;
+    }
 
-    return result;
-}
-/*
- * Flatten an saved_info_t into bytes
- *
- * we need to save:
- * salt      
- * mpz_t verifier;
- *
- * store salt as series of bytes
- * verifier as netstring 
- *
- */
+    r = GetMPI(data, datalen, g, &data, &datalen);
+    if (r) {
+	*errstr = "Error parsing out 'g'";
+	goto end;
+    }
 
-static sasl_secret_t *flatten_sinfo(savedinfo_t *sinfo, sasl_utils_t *utils)
-{
+    r = GetMPI(data, datalen, v, &data, &datalen);
+    if (r) {
+	*errstr = "Error parsing out 'v'";
+	goto end;
+    }
 
-    int result;
-    int toalsize;
-    netstring_t *ns1;
-    sasl_secret_t *sec;
-    int totalsize;
+    if (datalen != 0) {
+	*errstr = "Extra data in request step 2";
+	r = SASL_FAIL;
+	goto end;
+    }
 
-    ns1 = create_netstring_bigint(sinfo->verifier, utils);
-    if (!ns1) return NULL;
+    /* Free and return */
+ end:
+    if (sec) utils->free(sec);
 
-    totalsize = sizeof(sinfo->salt) + ns1->size;
+    return r;
+}
+
 
-    sec=(sasl_secret_t *) utils->malloc(sizeof(sasl_secret_t)+
-					totalsize+1);
-    if (!sec) return NULL;
+
+static int
+GetSaveInfo(sasl_utils_t *utils,
+	    const char *user,
+	    const char *pass, unsigned passlen,
+	    sasl_secret_t **sec,
+	    const char **errstr)
+{
+    mpz_t N;
+    mpz_t g;
+    mpz_t v;
+    mpz_t x;
+    char salt[SRP_SALT_SIZE];
+    int saltlen;
+    int r;    
+    char *osSalt = NULL;
+    int osSaltlen;
+    char *mpiN = NULL;
+    int mpiNlen;
+    char *mpig = NULL;
+    int mpiglen;
+    char *mpiv = NULL;
+    int mpivlen;    
+    char *buffer = NULL;
+    int bufferlen;
+
+    /* generate <salt> */    
+    saltlen = sizeof(salt);
+    utils->rand(utils->rpool, salt, saltlen);
+
+    r = generate_N_and_g(N, g);
+    if (r) {
+	*errstr = "Error calculating N and g";
+	return r;
+    }
+
+    r = CalculateX(utils, salt, saltlen, user, pass, passlen, &x);
+    if (r) {
+	*errstr = "Error calculating 'x'";
+	return r;
+    }
+
+    /* v = g^x */
+    mpz_init(v);
+    mpz_powm (v, g, x, N);
 
-    memcpy(sec->data, sinfo->salt, sizeof(sinfo->salt));
-    memcpy(sec->data+sizeof(sinfo->salt), ns1->data, ns1->size);
+    /*
+     * We need to save:
+     *  salt
+     *  N
+     *  g
+     *  v
+     */
 
-    sec->len = totalsize;
+    r = MakeOS(utils, salt, saltlen, &osSalt, &osSaltlen);
+    if (r) {
+	*errstr = "Error turning salt into 'os' string";
+	goto end;
+    }
+    
+    r = MakeMPI(utils, N, &mpiN, &mpiNlen);
+    if (r) {
+	*errstr = "Error turning 'N' into 'mpi' string";
+	goto end;
+    }
+
+    r = MakeMPI(utils, g, &mpig, &mpiglen);
+    if (r) {
+	*errstr = "Error turning 'g' into 'mpi' string";
+	goto end;
+    }
+    
+    r = MakeMPI(utils, v, &mpiv, &mpivlen);
+    if (r) {
+	*errstr = "Error turning 'N' into 'mpi' string";
+	goto end;
+    }
+
+    r = MakeBuffer(utils, osSalt, osSaltlen, mpiN, mpiNlen, mpig, mpiglen, mpiv, mpivlen,
+		   &buffer, &bufferlen);
+    if (r) {
+	*errstr = "Error putting all the data together in step 2";
+	goto end;
+    }    
+    
+    /* Put 'buffer' into sasl_secret_t */
+    *sec = utils->malloc(sizeof(sasl_secret_t)+bufferlen+1);
+    if (!*sec) {
+	r = SASL_NOMEM;
+	goto end;
+    }
+    memcpy((*sec)->data, buffer, bufferlen);
+    (*sec)->len = bufferlen;    
+
+    /* Clean everything up */
+ end:
+    if (osSalt) utils->free(osSalt);
+    if (mpiN)   utils->free(mpiN);
+    if (mpig)   utils->free(mpig);
+    if (mpiv)   utils->free(mpiv);
+    if (buffer) utils->free(buffer);
+    mpz_clear(N);
+    mpz_clear(g);
+    mpz_clear(v);
+    mpz_clear(x);
 
-    return sec;
+    return r;   
 }
 
 static int
-setpass(void *glob_context __attribute__((unused)),
-	sasl_server_params_t *sparams,
-	const char *userstr,
-	const char *pass,
-	unsigned passlen,
-	int flags __attribute__((unused)),
-	const char **errstr)
+srp_setpass(void *glob_context __attribute__((unused)),
+	    sasl_server_params_t *sparams,
+	    const char *userstr,
+	    const char *pass,
+	    unsigned passlen,
+	    int flags,
+	    const char **errstr)
 {
-    int userlen = strlen(userstr);
-    
-    int result;
+    const char *myerrstr;
+    int r;
     sasl_server_putsecret_t *putsecret;
     void *putsecret_context;
     char *user = NULL;
     char *realm = NULL;
-
-    savedinfo_t sinfo;
-    sasl_secret_t *sec = NULL;
+    sasl_secret_t *sec;
 
-    if (errstr) {
-	*errstr = NULL;
-    }
+    if (!errstr) errstr = &myerrstr;
+    *errstr = NULL;
 
-    result = parseuser(sparams->utils, &user, &realm, sparams->user_realm,
+    r = parseuser(sparams->utils, &user, &realm, sparams->user_realm,
 		       sparams->serverFQDN, userstr);
-    if (result != SASL_OK) {
-	return result;
+    if (r) {
+	*errstr = "Error parsing user";
+	return r;
     }
 
     if ((flags & SASL_SET_DISABLE) || pass == NULL) {
 	sec = NULL;
     } else {
-	mpz_t N, g, x;
-
-	/* generate <salt> */    
-	sparams->utils->rand(sparams->utils->rpool, sinfo.salt, sizeof(sinfo.salt));
-    
-	/* x = SHA( <salt> | SHA (... )) */
-	result = calculate_x(sparams->utils,
-			     user, userlen,
-			     pass, passlen,
-			     sinfo.salt, sizeof(sinfo.salt),
-			     x);
-	if (result!=SASL_OK) return result;
-
-	result = generate_N_and_g(N, g);
-	if (result!=SASL_OK) return result;
-
-	/* calculate v = g^x % N */
-	mpz_init(sinfo.verifier);
-	mpz_powm(sinfo.verifier,g,x,N);
-
-
-	/* flatten sinfo */
-	sec = flatten_sinfo(&sinfo, sparams->utils);
-
-	if (sec == NULL) {
-	    result = SASL_NOMEM;
-	    goto cleanup;
+	r = GetSaveInfo(sparams->utils, user, pass, passlen, &sec, errstr);
+	if (r) {
+	    *errstr = "Error creating data for SRP to save";
+	    return r;
 	}
     }
 
     /* get the callback for saving to the password db */
-    result = sparams->utils->getcallback(sparams->utils->conn,
-					 SASL_CB_SERVER_PUTSECRET,
-					 &putsecret,
-					 &putsecret_context);
-    if (result != SASL_OK) {
+    r = sparams->utils->getcallback(sparams->utils->conn,
+				    SASL_CB_SERVER_PUTSECRET,
+				    &putsecret,
+				    &putsecret_context);
+    if (r) {
+	*errstr = "Error getting putsecret callback";
 	goto cleanup;
     }
 
     /* do the store */
-    result = putsecret(putsecret_context,
-		       "SRP", 
-		       user,
-		       realm,
-		       sec);
+    r = putsecret(putsecret_context,
+		  "SRP-MD5-120", 
+		  user,
+		  realm,
+		  sec);
 
-    if (result != SASL_OK) {
+    if (r) {
+	*errstr = "Error putting secret";
 	goto cleanup;
     }
 
     /* put entry in db to say we have at least one user */
-    result = mechanism_fill_db("SRP", sparams);
+    r = mechanism_fill_db("SRP-MD5-120", sparams);
 
     VL(("Setpass for SRP successful\n"));
 
  cleanup:
-    if (sec) {
-	memset(sec, 0, sizeof(sasl_secret_t) + sizeof(savedinfo_t));
-	sparams->utils->free(sec);
-    }
 
     if (user) 	sparams->utils->free(user);
     if (realm) 	sparams->utils->free(realm);
-    return result;
+    if (sec)    sparams->utils->free(sec);
+
+    return r;
 }
 
+/* XXX for now we only support one hash type */
 static const sasl_server_plug_t plugins[] = 
 {
   {
-    "SRP",		        /* mech_name */
+    "SRP-MD5-120",	        /* mech_name */
     0,				/* max_ssf */
     SASL_SEC_NOPLAINTEXT,	/* security_flags */
     NULL,			/* glob_context */
     &server_start,		/* mech_new */
     &server_continue_step,	/* mech_step */
-    NULL,			/* mech_dispose */
+    &dispose,			/* mech_dispose */
     NULL,			/* mech_free */
-    &setpass,			/* setpass */
+    &srp_setpass,		/* setpass */
     NULL,			/* user_query */
     NULL,			/* idle */
     NULL,			/* install_credentials */
@@ -1497,11 +2652,11 @@
   }
 };
 
-int sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_server_plug_t **pluglist,
-			  int *plugcount)
+int srp_sasl_server_plug_init(sasl_utils_t *utils __attribute__((unused)),
+			      int maxversion,
+			      int *out_version,
+			      const sasl_server_plug_t **pluglist,
+			      int *plugcount)
 {
   if (maxversion<SRP_VERSION)
     return SASL_BADVERS;
@@ -1514,17 +2669,6 @@
   return SASL_OK;
 }
 
-static void dispose(void *conn_context, sasl_utils_t *utils)
-{
-  context_t *text;
-  text=conn_context;
-
-  if (!text)
-    return;
-
-  utils->free(text);
-}
-
 /* put in sasl_wrongmech */
 static int
 client_start(void *glob_context __attribute__((unused)),
@@ -1541,60 +2685,12 @@
   if (text==NULL) return SASL_NOMEM;
 
   memset(text, '\0', sizeof(context_t));
-  text->state=0;  
+  text->state = 0;  
   *conn=text;
 
   return SASL_OK;
 }
 
-/*
- * Create large random a
- * A = g^a % N
- *
- */
-
-static netstring_t *create_public_client(mpz_t g, mpz_t N, mpz_t a, mpz_t A, 
-					 sasl_utils_t *utils)
-{
-    mpz_init(a);
-    mpz_init(A);
-
-    /* xxx likely should use sasl random funcs */
-    mpz_random(a,BITSFORab/(8*sizeof(int))); 
-
-    /* A = g^a % N */
-    mpz_powm (A, g, a, N);
-
-    return create_netstring_bigint(A, utils);
-}
-
-/*
- * Create large random b
- * B = (v + g^b) % N
- *
- */
-
-static int create_public_server(mpz_t g, mpz_t N, mpz_t v,
-				mpz_t b, mpz_t B)
-{
-    mpz_init(b);
-    mpz_init(B);
-
-    /* xxx likely should use sasl random funcs */
-    mpz_random(b,BITSFORab/(8*sizeof(int))); 
-
-    /*  g^b % N */
-    mpz_powm (B, g, b, N);
-
-    /* v + (g^b%N)  */
-    mpz_add (B, B, v);
-
-    /* B = (v + g^b) % N */
-    mpz_mod (B, B, N);
-
-    return SASL_OK;
-}
-
 /* 
  * Trys to find the prompt with the lookingfor id in the prompt list
  * Returns it if found. NULL otherwise
@@ -1603,17 +2699,17 @@
 static sasl_interact_t *find_prompt(sasl_interact_t *promptlist,
 				    unsigned int lookingfor)
 {
-  if (promptlist==NULL) return NULL;
-
-  while (promptlist->id!=SASL_CB_LIST_END)
-  {
-    if (promptlist->id==lookingfor)
-      return promptlist;
-
-    promptlist++;
-  }
-
-  return NULL;
+    if (promptlist==NULL) return NULL;
+    
+    while (promptlist->id!=SASL_CB_LIST_END)
+    {
+	if (promptlist->id==lookingfor)
+	    return promptlist;
+	
+	promptlist++;
+    }
+    
+    return NULL;
 }
 
 static int get_authid(sasl_client_params_t *params,
@@ -1672,6 +2768,70 @@
 
 }
 
+/*
+ * Somehow retrieve the userid
+ * This is the same as in digest-md5 so change both
+ */
+
+static int
+get_userid(sasl_client_params_t *params,
+	   char **userid,
+	   sasl_interact_t **prompt_need)
+{
+  int result;
+  sasl_getsimple_t *getuser_cb;
+  void *getuser_context;
+  sasl_interact_t *prompt;
+  const char *ptr;
+
+  /* see if we were given the userid in the prompt */
+  prompt=find_prompt(*prompt_need,SASL_CB_USER);
+  if (prompt!=NULL) {
+      if (!prompt->result) {
+	  return SASL_BADPARAM;
+      }
+
+      VL(("Found userid in callback\n"));
+
+      /* copy it */
+      *userid=params->utils->malloc(prompt->len+1);
+      if ((*userid)==NULL) return SASL_NOMEM;
+
+      strncpy(*userid, prompt->result, prompt->len+1);
+      return SASL_OK;
+  }
+
+  /* Try to get the callback... */
+  result = params->utils->getcallback(params->utils->conn,
+				      SASL_CB_USER,
+				      &getuser_cb,
+				      &getuser_context);
+  switch (result) {
+  case SASL_INTERACT:
+    return SASL_INTERACT;
+  case SASL_OK:
+    if (!getuser_cb)
+      return SASL_FAIL;
+    result = getuser_cb(getuser_context,
+			SASL_CB_USER,
+			&ptr,
+			NULL);
+    if (result != SASL_OK)
+      return result;
+    if (!ptr) return SASL_BADPARAM;
+
+    *userid=params->utils->malloc(strlen(ptr)+1);
+    if ((*userid)==NULL) return SASL_NOMEM;
+    strcpy(*userid, ptr);
+
+    break;
+  default:
+    /* sucess */
+    break;
+  }
+
+  return result;
+}
 
 static int get_password(sasl_client_params_t *params,
 		      sasl_secret_t **password,
@@ -1759,13 +2919,15 @@
 
 static int make_prompts(sasl_client_params_t *params,
 			sasl_interact_t **prompts_res,
-			int auth_res,
+			int auth_res, /* authentication id */
+			int user_res, /* authorization id */
 			int pass_res)
 {
   int num=1;
   sasl_interact_t *prompts;
 
   if (auth_res==SASL_INTERACT) num++;
+  if (user_res==SASL_INTERACT) num++;
   if (pass_res==SASL_INTERACT) num++;
 
   if (num==1) return SASL_FAIL;
@@ -1778,14 +2940,25 @@
   {
     /* We weren't able to get the callback; let's try a SASL_INTERACT */
     (prompts)->id=SASL_CB_AUTHNAME;
-    (prompts)->challenge="Authorization Name";
+    (prompts)->challenge="Authentication Name";
     (prompts)->prompt="Please enter your authorization name";
     (prompts)->defresult=NULL;
 
     VL(("authid callback added\n"));
     prompts++;
   }
+  if (user_res == SASL_INTERACT) {
+    /*
+     * We weren't able to get the callback; let's try a SASL_INTERACT
+     */
+    (prompts)->id=SASL_CB_USER;
+    (prompts)->challenge="Authorization Name";
+    (prompts)->prompt="Please enter your authorization name";
+    (prompts)->defresult=NULL;
 
+    VL(("userid callback added\n"));
+    prompts++;
+  }
   if (pass_res==SASL_INTERACT)
   {
     /* We weren't able to get the callback; let's try a SASL_INTERACT */
@@ -1809,313 +2982,437 @@
 }
 
 static int
-client_continue_step(void *conn_context,
-		sasl_client_params_t *params,
-		const char *serverin,
-		int serverinlen,
-		sasl_interact_t **prompt_need,
-		char **clientout,
-		int *clientoutlen,
-		sasl_out_params_t *oparams)
+client_step1(context_t *text,
+	     sasl_client_params_t *params,
+	     const char *serverin  __attribute__((unused)),
+	     int serverinlen,
+	     sasl_interact_t **prompt_need,
+	     char **clientout,
+	     int *clientoutlen,
+	     sasl_out_params_t *oparams  __attribute__((unused)))
+{
+    int auth_result=SASL_OK;
+    int pass_result=SASL_OK;
+    int user_result=SASL_OK;
+    int r;
+    char *utf8U = NULL;
+    int utf8Ulen;
+
+    /* Expect: 
+     *   absolutly nothing
+     * 
+     */
+    if (serverinlen > 0) {
+	VL(("Invalid input to first step of SRP\n"));
+	return SASL_FAIL;
+    }
+
+
+    /* try to get the authid */
+    if (text->authid==NULL)
+    {
+	VL (("Trying to get authid\n"));
+	auth_result=get_authid(params,
+			       &text->authid,
+			       prompt_need);
+	  
+	if ((auth_result!=SASL_OK) && (auth_result!=SASL_INTERACT))
+	    return auth_result;	  
+    }
+
+    /* try to get the userid */
+    if (text->userid == NULL) {
+      VL(("Trying to get authorization id\n"));
+      user_result = get_userid(params,
+			       (char **) &text->userid,
+			       prompt_need);
+
+      if ((user_result != SASL_OK) && (user_result != SASL_INTERACT))
+      {
+	  return user_result;
+      }
+    }
+      
+    /* try to get the password */
+    if (text->password==NULL)
+    {
+	VL (("Trying to get password\n"));
+	pass_result=get_password(params,
+				 &text->password,
+				 prompt_need);
+	
+	if ((pass_result!=SASL_OK) && (pass_result!=SASL_INTERACT))
+	    return pass_result;
+    }
+    
+    /* free prompts we got */
+    if (prompt_need) free_prompts(params,*prompt_need);
+
+    /* if there are prompts not filled in */
+    if ((auth_result==SASL_INTERACT) ||
+	(user_result==SASL_INTERACT) ||
+	(pass_result==SASL_INTERACT))
+    {
+	/* make the prompt list */
+	int result=make_prompts(params,prompt_need,
+				auth_result, user_result, pass_result);
+	if (result!=SASL_OK) return result;
+	
+	VL(("returning prompt(s)\n"));
+	return SASL_INTERACT;
+    }
+
+    VL(("Sending authid: %s\n",text->authid));
+
+    /* send authentication identity 
+     * { utf8(U) }
+     */
+
+    r = MakeUTF8(params->utils, text->authid, &utf8U, &utf8Ulen);
+    if (r) goto done;
+
+    r = MakeBuffer(params->utils, utf8U, utf8Ulen, NULL, 0, NULL, 0, NULL, 0,
+		   clientout, clientoutlen);
+    if (r) goto done;
+
+    text->state++;
+    r = SASL_CONTINUE;
+
+ done:
+
+    if (utf8U)    params->utils->free(utf8U);
+
+    return r;
+}
+
+static int
+client_step2(context_t *text,
+	     sasl_client_params_t *params,
+	     const char *serverin,
+	     int serverinlen,
+	     sasl_interact_t **prompt_need __attribute__((unused)),
+	     char **clientout,
+	     int *clientoutlen,
+	     sasl_out_params_t *oparams __attribute__((unused)))
 {
-  int result;
-  context_t *text;
-  text=conn_context;
+    char *data;
+    int datalen;
+    int r;    
+    char *utf8I = NULL, *mpiA = NULL, *utf8o = NULL;
+    int utf8Ilen, mpiAlen, utf8olen;
+    srp_options_t server_opts;
 
-  VL(("SRP client step %d\n",text->state));
+    /* expect:
+     *  { mpi(N) mpi(g) utf8(L) }
+     *
+     */
+    r = UnBuffer((char *) serverin, serverinlen, &data, &datalen);
+    if (r) return r;
+
+    r = GetMPI((unsigned char *)data, datalen, &text->N, &data, &datalen);
+    if (r) {
+	VL(("Error getting MPI string for 'N'\n"));
+	goto done;
+    }
 
-  if (text->state == 0) {
+    r = GetMPI((unsigned char *) data, datalen, &text->g, &data, &datalen);
+    if (r) {
+	VL(("Error getting MPI string for 'g'\n"));
+	goto done;
+    }
 
-      /* nothing. server makes first challenge */
+    r = GetUTF8(params->utils, data, datalen, &text->server_options, &data, &datalen);
+    if (r) {
+	VL(("Error getting UTF8 string for 'L'"));
+	goto done;
+    }
 
-      *clientout=params->utils->malloc(1);
-      if (! (*clientout)) return SASL_NOMEM;
-      (*clientout)[0]='\0';
-      *clientoutlen = 0;
-
-      VL(("Step one succeeded!\n"));
-      text->state = 1;
-      return SASL_CONTINUE;
-  }
+    if (datalen != 0) {
+	VL(("Extra data parsing buffer\n"));
+	goto done;
+    }
 
-  if (text->state == 1) {
+    /* parse server options */
+    memset(&server_opts, 0, sizeof(srp_options_t));
+    r = ParseOptions(params->utils, text->server_options, &server_opts);
+    if (r) {
+	VL(("Error parsing options\n"));
+	goto done;
+    }
 
-      netdata_t *nd1;
-      netdata_t *nd2;
-      netdata_t *nd3;
-
-      netstring_t *ns1;
-      netstring_t *ns2;
-      netstring_t *ns3;
-
-      int result;
-      int auth_result=SASL_OK;
-      int pass_result=SASL_OK;
+    /* create an 'a' */
+    GetRandBigInt(text->a);
 
-      /* try to get the userid */
-      if (text->authid==NULL)
-      {
-	  VL (("Trying to get authid\n"));
-	  auth_result=get_authid(params,
-				 &text->authid,
-				 prompt_need);
-	  
-	  if ((auth_result!=SASL_OK) && (auth_result!=SASL_INTERACT))
-	      return auth_result;	  
-      }
+    /* calculate 'A' 
+     *
+     * A = g^a % N 
+     */
+    mpz_init(text->A);
+    mpz_powm (text->A, text->g, text->a, text->N);
+
+    /* make o */
+    r = CreateClientOpts(params, &server_opts, &text->client_opts);
+    if (r) {
+	VL(("Error creating client options\n"));
+	goto done;
+    }
+
+    r = OptionsToString(params->utils, &text->client_opts, &text->client_options);
+    if (r) {
+	VL(("Error converting client options to an option string\n"));
+	goto done;
+    }
       
-      /* try to get the password */
-      if (text->password==NULL)
-      {
-	  VL (("Trying to get password\n"));
-	  pass_result=get_password(params,
-				   &text->password,
-				   prompt_need);
-	  
-	  if ((pass_result!=SASL_OK) && (pass_result!=SASL_INTERACT))
-	      return pass_result;
-      }
+    /* Send out:
+     *
+     * I - authorization
+     * A - client's public key
+     * o - client option list
+     *
+     * { uf8(I) mpi(A) utf8(o) }
+     */
+    
+    r = MakeUTF8(params->utils, text->userid, &utf8I, &utf8Ilen);
+    if (r) {
+	VL(("Error making UTF8 string from userid ('I')\n"));
+	goto done;
+    }
+
+    r = MakeMPI(params->utils, text->A, &mpiA, &mpiAlen);
+    if (r) {
+	VL(("Error making MPI string from A\n"));
+	goto done;
+    }
+
+    r = MakeUTF8(params->utils, text->client_options, &utf8o, &utf8olen);
+    if (r) {
+	VL(("Error making UTF8 string from client options ('o')\n"));
+	goto done;
+    }
+
+    r = MakeBuffer(params->utils, utf8I, utf8Ilen, mpiA, mpiAlen, utf8o, utf8olen, NULL, 0,
+		   clientout, clientoutlen);
+    if (r) {
+	VL(("Error making output buffer\n"));
+	goto done;
+    }
 
+    text->state ++;
+    r = SASL_CONTINUE;
+
+ done:
     
-      /* free prompts we got */
-      if (prompt_need) free_prompts(params,*prompt_need);
+    if (utf8I)    params->utils->free(utf8I);
+    if (mpiA)     params->utils->free(mpiA);
+    if (utf8o)    params->utils->free(utf8o);
 
-      /* if there are prompts not filled in */
-      if ((auth_result==SASL_INTERACT) ||
-	  (pass_result==SASL_INTERACT))
-      {
-	  /* make the prompt list */
-	  int result=make_prompts(params,prompt_need,
-				  auth_result, pass_result);
-	  if (result!=SASL_OK) return result;
-	  
-	  VL(("returning prompt(s)\n"));
-	  return SASL_INTERACT;
-      }
+    return r;
+}
+
+static int
+client_step3(context_t *text,
+	     sasl_client_params_t *params,
+	     const char *serverin,
+	     int serverinlen,
+	     sasl_interact_t **prompt_need __attribute__((unused)),
+	     char **clientout,
+	     int *clientoutlen,
+	     sasl_out_params_t *oparams  __attribute__((unused)))
+{
+    char *data;
+    int datalen;
+    int r;    
+    char *osM1 = NULL;
+    int osM1len;
+
+    /* Expect:
+     *  { os(s) mpi(B) }
+     *
+     */
+    r = UnBuffer((char *) serverin, serverinlen, &data, &datalen);
+    if (r) return r;
 
-      printf("authid = %s\n",text->authid);
+    r = GetOS(params->utils, (unsigned char *)data, datalen, &text->salt, &text->saltlen, &data, &datalen);
+    if (r) return r;
 
-      /* We received:
-       *
-       * N
-       * g
-       * Z - server options
-       */
-      result = split_netstrings(params->utils, &nd1,&nd2,&nd3, (char *) serverin, serverinlen);
-      if (result!=SASL_OK) return result;
-
-      printf("split worked\n");
+    r = GetMPI((unsigned char *) data, datalen, &text->B, &data, &datalen);
+    if (r) return r;
+
+    if (datalen != 0) {
+	VL(("Extra data parsing buffer\n"));
+	return SASL_FAIL;
+    }
+    
+    /* Calculate shared context key K
+     *
+     */
+    r = CalculateK_client(params->utils, text->salt, text->saltlen, text, text->authid, 
+			  text->password->data, text->password->len, &text->K, &text->Klen);
+    if (r) return r;
 
-      result = bigint_fromnetdata(nd1, params->utils, text->N);
-      if (result!=SASL_OK) return result;
+    r = SetOptions(&text->client_opts, text, params->utils, oparams);
+    if (r) return r;
 
-      result = bigint_fromnetdata(nd2, params->utils, text->g);
-      if (result!=SASL_OK) return result;
+    /* Now calculate M1 (client evidence)
+     *
+     */
+    r = CalculateM1(params->utils, text->N, text->g, text->authid, text->salt, text->saltlen,
+		    text->server_options, text->A, text->B, text->K, text->Klen,
+		    &text->M1, &text->M1len);
+    if (r) return r;
 
-      if (nd3->size!=1) {
-	  VL(("Options is wrong size\n"));
-	  return SASL_FAIL;
-      }
-      text->server_options = nd3->data[0];
+    /* Send:
+     *
+     * { os(M1) }
+     */
+    
+    r = MakeOS(params->utils, text->M1, text->M1len, &osM1, &osM1len);
+    if (r) {
+	VL(("Error creating OS string for M1\n"));
+	goto done;
+    }
+
+    r = MakeBuffer(params->utils, osM1, osM1len, NULL, 0, NULL, 0, NULL, 0,
+		   clientout, clientoutlen);
+    if (r) {
+	VL(("Error creating buffer in step 3\n"));
+	goto done;
+    }
 
-      printf("got N and g\n");
+    text->state++;
+    r = SASL_CONTINUE;
+ done:
+
+    if (osM1)    params->utils->free(osM1);
+
+    return r;
+}
 
-      printf("client g: ");
-      mpz_out_str (stdout, 10, text->g);
-      printf("\n");
+static int
+client_step4(context_t *text,
+	     sasl_client_params_t *params,
+	     const char *serverin,
+	     int serverinlen,
+	     sasl_interact_t **prompt_need __attribute__((unused)),
+	     char **clientout,
+	     int *clientoutlen,
+	     sasl_out_params_t *oparams __attribute__((unused)))
+{
+    char *data;
+    int datalen;
+    int r;    
+    char *serverM2 = NULL;
+    int serverM2len;
+    int i;
+    char *myM2 = NULL;
+    int myM2len;
 
-      printf("client N: ");
-      mpz_out_str (stdout, 10, text->N);
-      printf("\n");
+    /* Input:
+     *
+     * M2 - server evidence
+     *
+     *   { os(M2) }
+     */
+    r = UnBuffer((char *) serverin, serverinlen, &data, &datalen);
+    if (r) return r;
 
-      /* U  - authname
-       * A  - public key
-       * o  - options byte
-       */
-      ns1 = create_netstring_str(text->authid,strlen(text->authid), params->utils);
+    r = GetOS(params->utils, (unsigned char *)data, datalen, &serverM2, &serverM2len,
+	      &data, &datalen);
+    if (r) return r;
+
+    if (datalen != 0) {
+	VL(("Extra data parsing buffer\n"));
+	r = SASL_FAIL;
+	goto done;
+    }
 
-      ns2 = create_public_client(text->g,text->N, text->a, text->A, params->utils);
+    /* calculate our own M2 */
+    r = CalculateM2(params->utils, text->A, text->authid, text->userid,
+		    text->client_options, text->M1, text->M1len, text->K, text->Klen,
+		    &myM2, &myM2len);
+    if (r) {
+	VL(("Error calculating our own M2 (server evidence)\n"));
+	goto done;
+    }
 
-      printf("created public netstring\n");
+    /* compare to see if is server spoof */
+    if (myM2len != serverM2len) {
+	VL(("Server M2 length wrong\n"));
+	r = SASL_FAIL;
+	goto done;
+    }
 
-      /* xxx client options */
-      text->client_options = 0;
+    
+    for (i = 0; i < myM2len; i++) {
+	if (serverM2[i] != myM2[i]) {
+	    VL(("Server spoof detected. M2 incorrect\n"));
+	    r = SASL_FAIL;
+	    goto done;
+	}
+    }
 
-      /* create options */
-      ns3 = create_netstring_str(&text->client_options,1, params->utils);
+    /* Send out: nothing
+     *
+     */
+    *clientout = NULL;
+    *clientoutlen = 0;
 
-      merge_netstrings(params->utils, ns1,ns2,ns3,clientout,clientoutlen);
+    text->state++;
+    r = SASL_OK;
 
-      text->state = 2;
-      return SASL_CONTINUE;
-  }
-  if (text->state == 2) { /* client step 2 */
-      netdata_t *nd1;
-      netdata_t *nd2;
-      netstring_t *ns1;
-      netstring_t *tmpns;
-      mpz_t exp;
-      int lup;
-      hash_t hashedB;
-      unsigned int u;
-      hash_t hashx;
-      mpz_t x;
-
-      /* We received 
-       *
-       * s - salt
-       * B - server public key
-       */
-
-      result = split_netstrings(params->utils, &nd1,&nd2,NULL, (char *) serverin, serverinlen);
-      if (result!=SASL_OK) return result;
-
-      result = bigint_fromnetdata(nd2, params->utils, text->B);
-      if (result!=SASL_OK) return result;
-
-      printf("client B: ");
-      mpz_out_str (stdout, 10, text->B);
-      printf("\n");
-
-      printf("foo\n");
-      /* Calculate shared secret S */
-      /* S = (B - g^x) ^ (a+u*x) %N */
-
-
-      /* u is first 32 bits of B; MSB first */      
-      Hash_bigint(text->B, &hashedB, params->utils);
-      memcpy(&u, hashedB.data, 4);
-      u = ntohl(u);      
-
-      printf("client U = %d\n",u);
-
-      /* generate x */
-      result = calculate_x(params->utils,
-			   text->authid, strlen(text->authid), 
-			   text->password->data,text->password->len, 
-			   nd1->data, nd1->size,
-			   x);
-      if (result!=SASL_OK) return result;
-
-      /* exp = a+u*x */
-      mpz_init(exp);
-      mpz_mul_ui (exp, x, u);
-      mpz_add(exp,exp,text->a);
-
-      /* (tmp)S = B - g^x */
-      mpz_init(text->S);
-      mpz_powm (text->S, text->g, x, text->N);     
-      printf("calculated g: ");
-      mpz_out_str (stdout, 10, text->g);
-      printf("\n");
-      printf("calculated x: ");
-      mpz_out_str (stdout, 10, x);
-      printf("\n");
-      printf("calculated N: ");
-      mpz_out_str (stdout, 10, text->N);
-      printf("\n");
-       printf("calculated tmpS 1: ");
-      mpz_out_str (stdout, 10, text->S);
-      printf("\n");
-
-      mpz_sub(text->S, text->B,text->S);
-
-      printf("calculated tmpS: ");
-      mpz_out_str (stdout, 10, text->S);
-      printf("\n");
-
-      /* S = tmpS^exp % N */
-      mpz_powm(text->S, text->S, exp, text->N);
-
-      printf("client calculated S: ");
-      mpz_out_str (stdout, 10, text->S);
-      printf("\n");
-
-      result = SHA_Interleave(text->S, &text->sharedsecretK, params->utils);
-      if (result!=SASL_OK) return result;
-
-      /*
-       * Give out:
-       *  M1
-       *
-       */
-
-      result = calculate_client_evidence(text->N, text->g,
-					 nd1->data, nd1->size,
-					 text->server_options,
-					 text->A, text->B,
-					 &text->sharedsecretK,
-					 &(text->M1),
-					 params->utils);
-      if (result!=SASL_OK) return result;
+ done:
 
+    if (serverM2)    params->utils->free(serverM2);
+    if (myM2)        params->utils->free(myM2);
 
-      ns1 = create_netstring_str(text->M1.data, sizeof(text->M1.data), params->utils);
-      if (ns1==NULL) return SASL_NOMEM;
-      
-      *clientout = params->utils->malloc(ns1->size+1);
-      if (!*clientout) return SASL_NOMEM;
-      memcpy(*clientout, ns1->data, ns1->size);
-      *clientoutlen = ns1->size;
-      
+    return r;
+}
 
-      text->state = 3;
-      return SASL_CONTINUE;
-  }
+static int
+client_continue_step(void *conn_context,
+		     sasl_client_params_t *params,
+		     const char *serverin,
+		     int serverinlen,
+		     sasl_interact_t **prompt_need,
+		     char **clientout,
+		     int *clientoutlen,
+		     sasl_out_params_t *oparams)
+{
+  context_t *text = conn_context;
 
-  if (text->state == 3) {
+  VL(("SRP client step %d\n",text->state));
 
-      unsigned char *M2in;
-      int M2inlen;
-      hash_t M2;
-      int lup;
-      
-      /*
-       * Retrieve M2 and verify it
-       *
-       */
-      result = checkvalid_netstring((char *) serverin, serverinlen, (char *) &M2in, &M2inlen);
-      if (result!=SASL_OK) return result;      
-
-      /* Let's calculate M2 ourselves and see if it matches */
-      result = calculate_server_evidence(text->authid,
-					 text->A,
-					 text->client_options,
-					 &(text->M1),
-					 &text->sharedsecretK,
-					 &M2,
-					 params->utils);
-      if (result!=SASL_OK) return result;      
-      
-      for (lup=0;lup<HASHLEN;lup++)
+  switch(text->state)
       {
-	  if (M2in[lup]!=M2.data[lup]) {
-	      VL (("Server evidence failure\n"));
-	      return SASL_FAIL;
-	  }
+      case 0:
+      case 1: return client_step1(text, params, serverin, serverinlen, 
+				  prompt_need, clientout, clientoutlen, oparams);
+      case 2: return client_step2(text, params, serverin, serverinlen, 
+				  prompt_need, clientout, clientoutlen, oparams);
+      case 3: return client_step3(text, params, serverin, serverinlen, 
+				  prompt_need, clientout, clientoutlen, oparams);
+      case 4: return client_step4(text, params, serverin, serverinlen, 
+				  prompt_need, clientout, clientoutlen, oparams);
+      default:
+	  VL(("Invalid SRP step\n"));
+	  return SASL_FAIL;
       }
 
-      *clientout = params->utils->malloc(1);
-      if (!*clientout) return SASL_NOMEM;
-      (*clientout)[0] = '\0';
-      *clientoutlen = 0;
-
-      text->state = 4;     
-      return SASL_OK;
-  }
-
   return SASL_FAIL;
 }
 
 static const long client_required_prompts[] = {
   SASL_CB_AUTHNAME,
+  SASL_CB_PASS,
   SASL_CB_LIST_END
 };
 
+
+/* XXX For now we only support one hash type */
 static const sasl_client_plug_t client_plugins[] = 
 {
   {
-    "SRP",	   	        /* mech_name */
+    "SRP-MD5-120",   	        /* mech_name */
     0,				/* max_ssf */
     SASL_SEC_NOPLAINTEXT,	/* security_flags */
     client_required_prompts,	/* required_prompts */
@@ -2129,11 +3426,11 @@
   }
 };
 
-int sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
-			  int maxversion,
-			  int *out_version,
-			  const sasl_client_plug_t **pluglist,
-			  int *plugcount)
+int srp_sasl_client_plug_init(sasl_utils_t *utils __attribute__((unused)),
+			      int maxversion,
+			      int *out_version,
+			      const sasl_client_plug_t **pluglist,
+			      int *plugcount)
 {
   if (maxversion < SRP_VERSION)
     return SASL_BADVERS;
