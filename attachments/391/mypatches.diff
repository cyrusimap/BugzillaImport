diff -C 3 -r cyrus-imapd-2.2.12.superold/imap/annotate.c cyrus-imapd-2.2.12.old/imap/annotate.c
*** cyrus-imapd-2.2.12.superold/imap/annotate.c	2005-02-14 09:39:54 +0300
--- cyrus-imapd-2.2.12.old/imap/annotate.c	2005-10-31 15:38:37 +0300
***************
*** 373,381 ****
      int keylen, r;
      struct find_rock frock;
  
!     frock.mglob = glob_init(mailbox, GLOB_HIERARCHY);
!     frock.eglob = glob_init(entry, GLOB_HIERARCHY);
!     GLOB_SET_SEPARATOR(frock.eglob, '/');
      frock.proc = proc;
      frock.rock = rock;
  
--- 373,381 ----
      int keylen, r;
      struct find_rock frock;
  
!     /* can't understand it yet -- sorcerer */
!     frock.mglob = glob_init(mailbox, '.', GLOB_HIERARCHY);
!     frock.eglob = glob_init(entry, '/', GLOB_HIERARCHY);
      frock.proc = proc;
      frock.rock = rock;
  
***************
*** 1022,1028 ****
      while (a) {
  	int attribcount;
  
! 	g = glob_init(a->s, GLOB_HIERARCHY);
  	
  	for (attribcount = 0;
  	     annotation_attributes[attribcount].name;
--- 1022,1028 ----
      while (a) {
  	int attribcount;
  
! 	g = glob_init(a->s, '.', GLOB_HIERARCHY);
  	
  	for (attribcount = 0;
  	     annotation_attributes[attribcount].name;
***************
*** 1055,1062 ****
  	int entrycount;
  	int check_db = 0; /* should we check the db for this entry? */
  
! 	g = glob_init(e->s, GLOB_HIERARCHY);
! 	GLOB_SET_SEPARATOR(g, '/');
  
  	for (entrycount = 0;
  	     non_db_entries[entrycount].name;
--- 1055,1061 ----
  	int entrycount;
  	int check_db = 0; /* should we check the db for this entry? */
  
! 	g = glob_init(e->s, '/', GLOB_HIERARCHY);
  
  	for (entrycount = 0;
  	     non_db_entries[entrycount].name;
diff -C 3 -r cyrus-imapd-2.2.12.superold/imap/imapd.c cyrus-imapd-2.2.12.old/imap/imapd.c
*** cyrus-imapd-2.2.12.superold/imap/imapd.c	2005-10-31 15:41:06 +0300
--- cyrus-imapd-2.2.12.old/imap/imapd.c	2005-10-31 15:38:57 +0300
***************
*** 1693,1698 ****
--- 1693,1709 ----
      }
  }
  
+ static void userid_tointernal(struct namespace *namespace, char *userid)
+ {
+     char hiersep_orig = namespace->hier_sep;
+ 
+     namespace->hier_sep='/';
+     mboxname_hiersep_tointernal(namespace, userid,
+ 				config_virtdomains ?
+ 				strcspn(userid, "@") : 0);
+     namespace->hier_sep=hiersep_orig;
+ }
+ 
  /*
   * Autocreate Inbox and subfolders upon login
   */
***************
*** 1880,1888 ****
      }
  
      /* Translate any separators in userid */
!     mboxname_hiersep_tointernal(&imapd_namespace, imapd_userid,
! 				config_virtdomains ?
! 				strcspn(imapd_userid, "@") : 0);
  
      freebuf(&passwdbuf);
  
--- 1891,1897 ----
      }
  
      /* Translate any separators in userid */
!     userid_tointernal(&imapd_namespace, imapd_userid);
  
      freebuf(&passwdbuf);
  
***************
*** 2029,2037 ****
      }
  
      /* Translate any separators in userid */
!     mboxname_hiersep_tointernal(&imapd_namespace, imapd_userid,
! 				config_virtdomains ?
! 				strcspn(imapd_userid, "@") : 0);
  
      autocreate_inbox();
  
--- 2038,2044 ----
      }
  
      /* Translate any separators in userid */
!     userid_tointernal(&imapd_namespace, imapd_userid);
  
      autocreate_inbox();
  
***************
*** 3764,3779 ****
  }	
  
  /* Callback for use by cmd_delete */
  static int delmbox(char *name,
  		   int matchlen __attribute__((unused)),
  		   int maycreate __attribute__((unused)),
  		   void *rock __attribute__((unused)))
  {
      int r;
  
!     r = mboxlist_deletemailbox(name, imapd_userisadmin,
! 			       imapd_userid, imapd_authstate,
! 			       0, 0, 0, 1);
      
      if(r) {
  	prot_printf(imapd_out, "* NO delete %s: %s\r\n",
--- 3771,3792 ----
  }	
  
  /* Callback for use by cmd_delete */
+ /* name is an external name */
  static int delmbox(char *name,
  		   int matchlen __attribute__((unused)),
  		   int maycreate __attribute__((unused)),
  		   void *rock __attribute__((unused)))
  {
      int r;
+     char intname[MAX_MAILBOX_NAME+1];
  
!     r = (*imapd_namespace.mboxname_tointernal)(&imapd_namespace, name,
! 					       imapd_userid, intname);
! 
!     if(!r)
! 	r = mboxlist_deletemailbox(intname, imapd_userisadmin,
! 				   imapd_userid, imapd_authstate,
! 				   0, 0, 0, 1);
      
      if(r) {
  	prot_printf(imapd_out, "* NO delete %s: %s\r\n",
***************
*** 3816,3831 ****
      if (!r && !localonly &&
  	!strncmp(mailboxname+domainlen, "user.", 5) &&
  	!strchr(mailboxname+domainlen+5, '.')) {
   	int mailboxname_len = strlen(mailboxname);
  
   	/* If we aren't too close to MAX_MAILBOX_NAME, append .* */
!  	p = mailboxname + mailboxname_len; /* end of mailboxname */
!  	if (mailboxname_len < sizeof(mailboxname) - 3) {
!  	    strcpy(p, ".*");
!  	}
  	
  	/* build a list of mailboxes - we're using internal names here */
! 	mboxlist_findall(NULL, mailboxname, imapd_userisadmin, imapd_userid,
  			 imapd_authstate, delmbox, NULL);
  
  	/* take care of deleting ACLs, subscriptions, seen state and quotas */
--- 3829,3851 ----
      if (!r && !localonly &&
  	!strncmp(mailboxname+domainlen, "user.", 5) &&
  	!strchr(mailboxname+domainlen+5, '.')) {
+ 	char name_copy[MAX_MAILBOX_NAME+1];
+  	int name_len = strlen(name);
   	int mailboxname_len = strlen(mailboxname);
  
+ 	memcpy(name_copy, name, name_len);
   	/* If we aren't too close to MAX_MAILBOX_NAME, append .* */
!  	p = name_copy + name_len; /* end of name */
!  	if (name_len < sizeof(name_copy) - 3) {
! 	    *p=imapd_namespace.hier_sep;
! 	    p[1]='*';
! 	    p[2]=0;
! 	}
! 	else
! 	    *p=0;
  	
  	/* build a list of mailboxes - we're using internal names here */
! 	mboxlist_findall(&imapd_namespace, name_copy, imapd_userisadmin, imapd_userid,
  			 imapd_authstate, delmbox, NULL);
  
  	/* take care of deleting ACLs, subscriptions, seen state and quotas */
***************
*** 3867,3879 ****
  };
  
  /* Callback for use by cmd_rename */
  static int renmbox(char *name,
  		   int matchlen __attribute__((unused)),
  		   int maycreate __attribute__((unused)),
  		   void *rock)
  {
!     char oldextname[MAX_MAILBOX_NAME+1];
!     char newextname[MAX_MAILBOX_NAME+1];
      struct renrock *text = (struct renrock *)rock;
      int r;
  
--- 3887,3900 ----
  };
  
  /* Callback for use by cmd_rename */
+ /* 'name' is an external mailbox name! */
  static int renmbox(char *name,
  		   int matchlen __attribute__((unused)),
  		   int maycreate __attribute__((unused)),
  		   void *rock)
  {
!     char oldintname[MAX_MAILBOX_NAME+1];
!     char newintname[MAX_MAILBOX_NAME+1];
      struct renrock *text = (struct renrock *)rock;
      int r;
  
***************
*** 3882,3917 ****
  
      strcpy(text->newmailboxname + text->nl, name + text->ol);
  
!     r = mboxlist_renamemailbox(name, text->newmailboxname,
  			       text->partition,
  			       1, imapd_userid, imapd_authstate);
      
-     (*imapd_namespace.mboxname_toexternal)(&imapd_namespace,
- 					   name,
- 					   imapd_userid, oldextname);
-     (*imapd_namespace.mboxname_toexternal)(&imapd_namespace,
- 					   text->newmailboxname,
- 					   imapd_userid, newextname);
- 
      if(r) {
  	prot_printf(imapd_out, "* NO rename %s %s: %s\r\n",
! 		    oldextname, newextname, error_message(r));
  	if (RENAME_STOP_ON_ERROR) return r;
      } else {
  	/* If we're renaming a user, change quotaroot and ACL */
  	if (text->rename_user) {
! 	    user_copyquotaroot(name, text->newmailboxname);
! 	    user_renameacl(text->newmailboxname,
  			   text->acl_olduser, text->acl_newuser);
  	}
  
  	/* Rename mailbox annotations */
! 	annotatemore_rename(name, text->newmailboxname,
  			    text->rename_user ? text->olduser : NULL,
  			    text->newuser);
  	
  	prot_printf(imapd_out, "* OK rename %s %s\r\n",
! 		    oldextname, newextname);
      }
  
      prot_flush(imapd_out);
--- 3903,3941 ----
  
      strcpy(text->newmailboxname + text->nl, name + text->ol);
  
!     if((*imapd_namespace.mboxname_tointernal)(&imapd_namespace,
! 					      text->newmailboxname,
! 					      imapd_userid, newintname))
! 	return 0;
! 
!     if((*imapd_namespace.mboxname_tointernal)(&imapd_namespace,
! 					      name,
! 					      imapd_userid, oldintname))
! 	return 0;
! 
!     r = mboxlist_renamemailbox(oldintname, newintname,
  			       text->partition,
  			       1, imapd_userid, imapd_authstate);
      
      if(r) {
  	prot_printf(imapd_out, "* NO rename %s %s: %s\r\n",
! 		    name, text->newmailboxname, error_message(r));
  	if (RENAME_STOP_ON_ERROR) return r;
      } else {
  	/* If we're renaming a user, change quotaroot and ACL */
  	if (text->rename_user) {
! 	    user_copyquotaroot(oldintname, newintname);
! 	    user_renameacl(newintname,
  			   text->acl_olduser, text->acl_newuser);
  	}
  
  	/* Rename mailbox annotations */
! 	annotatemore_rename(oldintname, newintname,
  			    text->rename_user ? text->olduser : NULL,
  			    text->newuser);
  	
  	prot_printf(imapd_out, "* OK rename %s %s\r\n",
! 		    name, text->newmailboxname);
      }
  
      prot_flush(imapd_out);
***************
*** 3926,3935 ****
  		char *oldname, char *newname, char *partition)
  {
      int r = 0;
!     char oldmailboxname[MAX_MAILBOX_NAME+3];
!     char newmailboxname[MAX_MAILBOX_NAME+2];
!     char oldextname[MAX_MAILBOX_NAME+1];
!     char newextname[MAX_MAILBOX_NAME+1];
      int omlen, nmlen;
      char *p;
      int recursive_rename = 1;
--- 3950,3957 ----
  		char *oldname, char *newname, char *partition)
  {
      int r = 0;
!     char oldmailboxname[MAX_MAILBOX_NAME+1];
!     char newmailboxname[MAX_MAILBOX_NAME+1];
      int omlen, nmlen;
      char *p;
      int recursive_rename = 1;
***************
*** 4037,4062 ****
  
      /* rename all mailboxes matching this */
      if (!r && recursive_rename) {
  	struct renrock rock;
! 	int ol = omlen + 1;
! 	int nl = nmlen + 1;
! 
! 	(*imapd_namespace.mboxname_toexternal)(&imapd_namespace,
! 					       oldmailboxname,
! 					       imapd_userid, oldextname);
! 	(*imapd_namespace.mboxname_toexternal)(&imapd_namespace,
! 					       newmailboxname,
! 					       imapd_userid, newextname);
  
  	prot_printf(imapd_out, "* OK rename %s %s\r\n",
! 		    oldextname, newextname);
  	prot_flush(imapd_out);
  
! 	strcat(oldmailboxname, ".*");
! 	strcat(newmailboxname, ".");
  
  	/* setup the rock */
! 	rock.newmailboxname = newmailboxname;
  	rock.ol = ol;
  	rock.nl = nl;
  	rock.olduser = olduser;
--- 4059,4082 ----
  
      /* rename all mailboxes matching this */
      if (!r && recursive_rename) {
+ 	char oldextname[MAX_MAILBOX_NAME+3];
+ 	char newextname[MAX_MAILBOX_NAME+2];
+ 	int tmplen;
  	struct renrock rock;
! 	int ol;
! 	int nl;
  
+ 	ol = strlen(oldname)+1;
+ 	nl = strlen(newname)+1;
  	prot_printf(imapd_out, "* OK rename %s %s\r\n",
! 		    oldname, newname);
  	prot_flush(imapd_out);
  
! 	snprintf(oldextname, MAX_MAILBOX_NAME+3, "%s%c*", oldname, imapd_namespace.hier_sep);
! 	snprintf(newextname, MAX_MAILBOX_NAME+2, "%s%c", newname, imapd_namespace.hier_sep);
  
  	/* setup the rock */
! 	rock.newmailboxname = newextname;
  	rock.ol = ol;
  	rock.nl = nl;
  	rock.olduser = olduser;
***************
*** 4066,4074 ****
  	rock.partition = partition;
  	rock.rename_user = rename_user;
  	
! 	/* add submailboxes; we pretend we're an admin since we successfully
! 	   renamed the parent - we're using internal names here */
! 	r = mboxlist_findall(NULL, oldmailboxname, 1, imapd_userid,
  			     imapd_authstate, renmbox, &rock);
      }
  
--- 4086,4093 ----
  	rock.partition = partition;
  	rock.rename_user = rename_user;
  	
! 	/* add submailboxes; using external namespace here */
! 	r = imapd_namespace.mboxlist_findall(&imapd_namespace, oldextname, 1, imapd_userid,
  			     imapd_authstate, renmbox, &rock);
      }
  
***************
*** 4334,4344 ****
  	    pattern = buf;
  	}
  
- 	/* Translate any separators in pattern */
- 	mboxname_hiersep_tointernal(&imapd_namespace, pattern,
- 				    config_virtdomains ?
- 				    strcspn(pattern, "@") : 0);
- 
  	/* Check to see if we should only list the personal namespace */
  	if (!strcmp(pattern, "*")
  	    && config_getswitch(IMAPOPT_FOOLSTUPIDCLIENTS)) {
--- 4353,4358 ----
***************
*** 5100,5114 ****
  			 void *rock)
  {
      int* sawone = (int*) rock;
  
      if (!name) {
  	return 0;
      }
      
!     if (!(strncmp(name, "INBOX.", 6))) {
  	/* The user has a "personal" namespace. */
  	sawone[NAMESPACE_INBOX] = 1;
!     } else if (mboxname_isusermailbox(name, 0)) {
  	/* The user can see the "other users" namespace. */
  	sawone[NAMESPACE_USER] = 1;
      } else {
--- 5114,5133 ----
  			 void *rock)
  {
      int* sawone = (int*) rock;
+     char intname[MAX_MAILBOX_NAME+1];
  
      if (!name) {
  	return 0;
      }
      
!     if((*imapd_namespace.mboxname_tointernal)(&imapd_namespace, name,
! 					      imapd_userid, intname))
! 	return 0;
! 
!     if (!(strncmp(intname, "INBOX.", 6))) {
  	/* The user has a "personal" namespace. */
  	sawone[NAMESPACE_INBOX] = 1;
!     } else if (mboxname_isusermailbox(intname, 0)) {
  	/* The user can see the "other users" namespace. */
  	sawone[NAMESPACE_USER] = 1;
      } else {
***************
*** 5145,5153 ****
      } else {
  	pattern = xstrdup("%");
  	/* now find all the exciting toplevel namespaces -
! 	 * we're using internal names here
  	 */
! 	mboxlist_findall(NULL, pattern, imapd_userisadmin, imapd_userid,
  			 imapd_authstate, namespacedata, (void*) sawone);
  	free(pattern);
      }
--- 5164,5173 ----
      } else {
  	pattern = xstrdup("%");
  	/* now find all the exciting toplevel namespaces -
! 	 * we're using external names here
  	 */
! 	mboxlist_findall(&imapd_namespace, pattern, imapd_userisadmin,
! 			 imapd_userid, 
  			 imapd_authstate, namespacedata, (void*) sawone);
  	free(pattern);
      }
***************
*** 6531,6537 ****
      struct backend *be;
  };
  
! static int xfer_user_cb(char *name,
  			int matchlen __attribute__((unused)),
  			int maycreate __attribute__((unused)),
  			void *rock) 
--- 6551,6557 ----
      struct backend *be;
  };
  
! static int xfer_user_cb(char *externalname,
  			int matchlen __attribute__((unused)),
  			int maycreate __attribute__((unused)),
  			void *rock) 
***************
*** 6540,6551 ****
      char *toserver = ((struct xfer_user_rock *)rock)->toserver;
      char *topart = ((struct xfer_user_rock *)rock)->topart;
      struct backend *be = ((struct xfer_user_rock *)rock)->be;
!     char externalname[MAX_MAILBOX_NAME+1];
      int mbflags;
      int r = 0;
      char *inpath, *inpart, *inacl;
      char *path = NULL, *part = NULL, *acl = NULL;
  
      if (!r) {
  	/* NOTE: NOT mlookup() because we don't want to issue a referral */
  	/* xxx but what happens if they are remote
--- 6560,6576 ----
      char *toserver = ((struct xfer_user_rock *)rock)->toserver;
      char *topart = ((struct xfer_user_rock *)rock)->topart;
      struct backend *be = ((struct xfer_user_rock *)rock)->be;
!     char name[MAX_MAILBOX_NAME+1];
      int mbflags;
      int r = 0;
      char *inpath, *inpart, *inacl;
      char *path = NULL, *part = NULL, *acl = NULL;
  
+     r = (*imapd_namespace.mboxname_tointernal)(&imapd_namespace,
+ 					       externalname,
+ 					       imapd_userid,
+ 					       name);
+ 
      if (!r) {
  	/* NOTE: NOT mlookup() because we don't want to issue a referral */
  	/* xxx but what happens if they are remote
***************
*** 6558,6573 ****
  	path = xstrdup(inpath);
  	part = xstrdup(inpart);
  	acl = xstrdup(inacl);
-     }
- 
-     if (!r) {
- 	r = (*imapd_namespace.mboxname_toexternal)(&imapd_namespace,
- 						   name,
- 						   imapd_userid,
- 						   externalname);
-     }
- 
-     if(!r) {
  	r = do_xfer_single(toserver, topart, externalname, name, mbflags,
  			   path, part, acl, 0, mupdate_h, be);
      }
--- 6583,6588 ----
***************
*** 6706,6712 ****
  	}
  
  
! 	/* recursively move all sub-mailboxes, using internal names */
  	if(!r) {
  	    struct xfer_user_rock rock;
  
--- 6721,6727 ----
  	}
  
  
! 	/* recursively move all sub-mailboxes, using external names */
  	if(!r) {
  	    struct xfer_user_rock rock;
  
***************
*** 6716,6722 ****
  	    rock.be = be;
  
  	    snprintf(buf, sizeof(buf), "%s.*", mailboxname);
! 	    r = mboxlist_findall(NULL, buf, 1, imapd_userid,
  				 imapd_authstate, xfer_user_cb,
  				 &rock);
  	}
--- 6731,6737 ----
  	    rock.be = be;
  
  	    snprintf(buf, sizeof(buf), "%s.*", mailboxname);
! 	    r = mboxlist_findall(&imapd_namespace, buf, 1, imapd_userid,
  				 imapd_authstate, xfer_user_cb,
  				 &rock);
  	}
***************
*** 7408,7424 ****
  /*
   * Issue a LIST or LSUB untagged response
   */
  static void mstringdata(char *cmd, char *name, int matchlen, int maycreate,
  			int listopts)
  {
!     static char lastname[MAX_MAILBOX_PATH+1];
      static int lastnamedelayed = 0;
      static int lastnamenoinferiors = 0;
      static int nonexistent = 0;
      static int sawuser = 0;
      int lastnamehassub = 0;
      int c, mbtype;
-     char mboxname[MAX_MAILBOX_PATH+1];
  
      /* We have to reset the sawuser flag before each list command.
       * Handle it as a dirty hack.
--- 7423,7440 ----
  /*
   * Issue a LIST or LSUB untagged response
   */
+ /* The 'name' variable now is an external name! // sorcerer */
  static void mstringdata(char *cmd, char *name, int matchlen, int maycreate,
  			int listopts)
  {
!     static char lastname[MAX_MAILBOX_PATH+1]="";
!     char intname[MAX_MAILBOX_PATH+1];
      static int lastnamedelayed = 0;
      static int lastnamenoinferiors = 0;
      static int nonexistent = 0;
      static int sawuser = 0;
      int lastnamehassub = 0;
      int c, mbtype;
  
      /* We have to reset the sawuser flag before each list command.
       * Handle it as a dirty hack.
***************
*** 7430,7439 ****
      }
      mstringdatacalls++;
  
      if (lastnamedelayed) {
  	/* Check if lastname has children */
  	if (name && strncmp(lastname, name, strlen(lastname)) == 0 &&
! 	    name[strlen(lastname)] == '.') {
  	    lastnamehassub = 1;
  	}
  	prot_printf(imapd_out, "* %s (", cmd);
--- 7446,7459 ----
      }
      mstringdatacalls++;
  
+     if(name && (*imapd_namespace.mboxname_tointernal)(&imapd_namespace, name,
+ 					      imapd_userid, intname))
+ 	return;
+ 
      if (lastnamedelayed) {
  	/* Check if lastname has children */
  	if (name && strncmp(lastname, name, strlen(lastname)) == 0 &&
! 	    name[strlen(lastname)] == imapd_namespace.hier_sep) {
  	    lastnamehassub = 1;
  	}
  	prot_printf(imapd_out, "* %s (", cmd);
***************
*** 7458,7466 ****
  	}
  	prot_printf(imapd_out, ") \"%c\" ", imapd_namespace.hier_sep);
  		    
! 	(*imapd_namespace.mboxname_toexternal)(&imapd_namespace, lastname,
! 					       imapd_userid, mboxname);
! 	printstring(mboxname);
  	prot_printf(imapd_out, "\r\n");
  	lastnamedelayed = lastnamenoinferiors = nonexistent = 0;
      }
--- 7478,7484 ----
  	}
  	prot_printf(imapd_out, ") \"%c\" ", imapd_namespace.hier_sep);
  		    
! 	printstring(lastname);
  	prot_printf(imapd_out, "\r\n");
  	lastnamedelayed = lastnamenoinferiors = nonexistent = 0;
      }
***************
*** 7474,7480 ****
      /* Suppress any output of a partial match */
      if ((name[matchlen]
  	 && strncmp(lastname, name, matchlen) == 0
! 	 && (lastname[matchlen] == '\0' || lastname[matchlen] == '.'))) {
  	return;
      }
  	
--- 7492,7498 ----
      /* Suppress any output of a partial match */
      if ((name[matchlen]
  	 && strncmp(lastname, name, matchlen) == 0
! 	 && (lastname[matchlen] == '\0' || lastname[matchlen] == imapd_namespace.hier_sep))) {
  	return;
      }
  	
***************
*** 7482,7488 ****
       * We can get a partial match for "user" multiple times with
       * other matches inbetween.  Handle it as a special case
       */
!     if (matchlen == 4 && strncasecmp(name, "user", 4) == 0) {
  	if (sawuser) return;
  	sawuser = 1;
      }
--- 7500,7506 ----
       * We can get a partial match for "user" multiple times with
       * other matches inbetween.  Handle it as a special case
       */
!     if (matchlen == 4 && strncasecmp(intname, "user", 4) == 0) {
  	if (sawuser) return;
  	sawuser = 1;
      }
***************
*** 7492,7508 ****
      nonexistent = 0;
  
      /* Now we need to see if this mailbox exists */
!     /* first convert "INBOX" to "user.<userid>" */
!     if (!strncasecmp(lastname, "inbox", 5)) {
! 	(*imapd_namespace.mboxname_tointernal)(&imapd_namespace, "INBOX",
! 					       imapd_userid, mboxname);
! 	strlcat(mboxname, lastname+5, sizeof(mboxname));
!     }
!     else
! 	strlcpy(mboxname, lastname, sizeof(mboxname));
  
      /* Look it up */
!     nonexistent = mboxlist_detail(mboxname, &mbtype,
  				  NULL, NULL, NULL, NULL);
      if(!nonexistent && (mbtype & MBTYPE_RESERVE))
  	nonexistent = IMAP_MAILBOX_RESERVED;
--- 7510,7521 ----
      nonexistent = 0;
  
      /* Now we need to see if this mailbox exists */
! 
!     /* The 'intname' variable cannot be "INBOX", therefore we don't
!        need to convert it to "user.<userid>" */
  
      /* Look it up */
!     nonexistent = mboxlist_detail(intname, &mbtype,
  				  NULL, NULL, NULL, NULL);
      if(!nonexistent && (mbtype & MBTYPE_RESERVE))
  	nonexistent = IMAP_MAILBOX_RESERVED;
***************
*** 7517,7525 ****
      if (c) name[matchlen] = '\0';
      prot_printf(imapd_out, "* %s (", cmd);
      if (c) {
! 	/* Handle namespace prefix as a special case */ 
! 	if (!strcmp(name, "user") ||
! 	    !strcmp(name, imapd_namespace.prefix[NAMESPACE_SHARED])) {
  	    prot_printf(imapd_out, "\\Noselect");
  	    if (listopts & LIST_EXT)
  		prot_printf(imapd_out, " \\PlaceHolder");
--- 7530,7538 ----
      if (c) name[matchlen] = '\0';
      prot_printf(imapd_out, "* %s (", cmd);
      if (c) {
! 	/* Handle namespace prefix as a special case */
!  	if (!strcmp(name, imapd_namespace.prefix[NAMESPACE_USER]) ||
!  	    !strcmp(name, imapd_namespace.prefix[NAMESPACE_SHARED])) {
  	    prot_printf(imapd_out, "\\Noselect");
  	    if (listopts & LIST_EXT)
  		prot_printf(imapd_out, " \\PlaceHolder");
***************
*** 7538,7546 ****
      }
      prot_printf(imapd_out, ") \"%c\" ", imapd_namespace.hier_sep);
  
!     (*imapd_namespace.mboxname_toexternal)(&imapd_namespace, name,
! 					   imapd_userid, mboxname);
!     printstring(mboxname);
      prot_printf(imapd_out, "\r\n");
      if (c) name[matchlen] = c;
      return;
--- 7551,7557 ----
      }
      prot_printf(imapd_out, ") \"%c\" ", imapd_namespace.hier_sep);
  
!     printstring(name);
      prot_printf(imapd_out, "\r\n");
      if (c) name[matchlen] = c;
      return;
diff -C 3 -r cyrus-imapd-2.2.12.superold/imap/mboxlist.c cyrus-imapd-2.2.12.old/imap/mboxlist.c
*** cyrus-imapd-2.2.12.superold/imap/mboxlist.c	2005-10-31 15:41:04 +0300
--- cyrus-imapd-2.2.12.old/imap/mboxlist.c	2005-10-31 15:38:38 +0300
***************
*** 1752,1786 ****
      long minmatch;
      struct glob *g = rock->g;
      long matchlen;
  
      /* don't list mailboxes outside of the default domain */
      if (!rock->domainlen && !rock->isadmin && strchr(key, '!')) return 0; 
  
      minmatch = 0;
-     if (rock->inboxoffset) {
- 	char namebuf[MAX_MAILBOX_NAME+1];
  
! 	if(keylen >= sizeof(namebuf)) {
! 	    syslog(LOG_ERR, "oversize keylen in mboxlist.c:find_p()");
! 	    return 0;
! 	}
! 	memcpy(namebuf, key, keylen);
! 	namebuf[keylen] = '\0';
! 	
! 	if (rock->inboxoffset) {
! 	    namebuf[rock->inboxoffset] = rock->inboxcase[0];
! 	    namebuf[rock->inboxoffset+1] = rock->inboxcase[1];
! 	    namebuf[rock->inboxoffset+2] = rock->inboxcase[2];
! 	    namebuf[rock->inboxoffset+3] = rock->inboxcase[3];
! 	    namebuf[rock->inboxoffset+4] = rock->inboxcase[4];
! 	}
! 	
! 	matchlen = glob_test(g, namebuf+rock->inboxoffset,
! 			     keylen-rock->inboxoffset, &minmatch);
!     } else {
! 	matchlen = glob_test(g, key, keylen, &minmatch);
      }
  
      /* If its not a match, skip it -- partial matches are ok. */
      if(matchlen == -1) return 0;
  
--- 1752,1790 ----
      long minmatch;
      struct glob *g = rock->g;
      long matchlen;
+     char namebuf[MAX_MAILBOX_NAME+1];
+     char namebuf_out[MAX_MAILBOX_NAME+1];
  
      /* don't list mailboxes outside of the default domain */
      if (!rock->domainlen && !rock->isadmin && strchr(key, '!')) return 0; 
  
      minmatch = 0;
  
!     memcpy(namebuf, key, keylen);
!     namebuf[keylen] = '\0';
! 
!     /* right work with an alternate (not the build-in)
!        namespace -- sorcerer */
!     if(keylen >= sizeof(namebuf)) {
! 	syslog(LOG_ERR, "oversize keylen in mboxlist.c:find_p()");
! 	return 0;
!     }
!     if(rock->inboxoffset) {
! 	namebuf[rock->inboxoffset] = rock->inboxcase[0];
! 	namebuf[rock->inboxoffset+1] = rock->inboxcase[1];
! 	namebuf[rock->inboxoffset+2] = rock->inboxcase[2];
! 	namebuf[rock->inboxoffset+3] = rock->inboxcase[3];
! 	namebuf[rock->inboxoffset+4] = rock->inboxcase[4];
      }
  
+     /* if cant get the external name then skip the current
+        key -- sorcerer */
+     if((rock->namespace->mboxname_toexternal)(rock->namespace, namebuf+rock->inboxoffset, auth_canonuser(rock->auth_state), namebuf_out))
+ 	return 0;
+ 
+     matchlen = glob_test(g, namebuf_out,
+ 			 strlen(namebuf_out), &minmatch);
+ 
      /* If its not a match, skip it -- partial matches are ok. */
      if(matchlen == -1) return 0;
  
***************
*** 1881,1902 ****
  	    r = 0;		/* don't bother checking */
  	}
  
! 	if (!r && rock->inboxoffset) {
! 	    namebuf[rock->inboxoffset] = rock->inboxcase[0];
! 	    namebuf[rock->inboxoffset+1] = rock->inboxcase[1];
! 	    namebuf[rock->inboxoffset+2] = rock->inboxcase[2];
! 	    namebuf[rock->inboxoffset+3] = rock->inboxcase[3];
! 	    namebuf[rock->inboxoffset+4] = rock->inboxcase[4];
! 	}
! 	
! 	matchlen = glob_test(g, namebuf+rock->inboxoffset,
! 			     keylen-rock->inboxoffset, &minmatch);
  
! 	if (matchlen == -1) {
! 	    r = 0;
! 	    break;
! 	}
  
  	switch (r) {
  	case 0:
  	    /* found the entry; output it */
--- 1885,1916 ----
  	    r = 0;		/* don't bother checking */
  	}
  
! 	/* right work with an alternate (not the build-in)
! 	   namespace // sorcerer */
! 	{
! 	    char namebuf_out[MAX_MAILBOX_NAME+1];
! 	    if(rock->inboxoffset) {
! 		namebuf[rock->inboxoffset] = rock->inboxcase[0];
! 		namebuf[rock->inboxoffset+1] = rock->inboxcase[1];
! 		namebuf[rock->inboxoffset+2] = rock->inboxcase[2];
! 		namebuf[rock->inboxoffset+3] = rock->inboxcase[3];
! 		namebuf[rock->inboxoffset+4] = rock->inboxcase[4];
! 	    }
! 	    if((rock->namespace->mboxname_toexternal)(rock->namespace, namebuf+rock->inboxoffset, auth_canonuser(rock->auth_state), namebuf_out)) {
! 		r = 0;
! 		break;
! 	    }
! 	    strcpy(namebuf, namebuf_out);
  
! 	    matchlen = glob_test(g, namebuf,
! 				 strlen(namebuf), &minmatch);
  
+ 	    if (matchlen == -1) {
+ 		r = 0;
+ 		break;
+ 	    }
+ 	}
+ 	
  	switch (r) {
  	case 0:
  	    /* found the entry; output it */
***************
*** 1915,1921 ****
  	    }
  
  	    rock->checkshared = 0;
! 	    r = (*rock->proc)(namebuf+rock->inboxoffset, matchlen, 
  			      1, rock->procrock);
  
  	    break;
--- 1929,1935 ----
  	    }
  
  	    rock->checkshared = 0;
! 	    r = (*rock->proc)(namebuf, matchlen, 
  			      1, rock->procrock);
  
  	    break;
***************
*** 2000,2007 ****
      if (domainpat[0] == '\0')
  	strlcpy(domainpat, pattern, sizeof(domainpat));
  
!     cbrock.g = glob_init(pattern, GLOB_HIERARCHY|GLOB_INBOXCASE);
!     cbrock.namespace = NULL;
      cbrock.domainlen = domainlen;
      cbrock.inboxcase = glob_inboxcase(cbrock.g);
      cbrock.isadmin = isadmin;
--- 2014,2021 ----
      if (domainpat[0] == '\0')
  	strlcpy(domainpat, pattern, sizeof(domainpat));
  
!     cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY|GLOB_INBOXCASE);
!     cbrock.namespace = namespace;
      cbrock.domainlen = domainlen;
      cbrock.inboxcase = glob_inboxcase(cbrock.g);
      cbrock.isadmin = isadmin;
***************
*** 2035,2050 ****
  	    }
  	    else if (r == CYRUSDB_NOTFOUND) r = 0;
  	}
- 	else if (!strncmp(pattern,
- 			  usermboxname+domainlen, usermboxnamelen-domainlen) &&
- 		 GLOB_TEST(cbrock.g, usermboxname+domainlen) != -1) {
- 	    r = DB->fetch(mbdb, usermboxname, usermboxnamelen,
- 			  &data, &datalen, NULL);
- 	    if (!r && data) {
- 		r = (*proc)(usermboxname, usermboxnamelen, 1, rock);
- 	    }
- 	    else if (r == CYRUSDB_NOTFOUND) r = 0;
- 	}
  	strlcat(usermboxname, ".", sizeof(usermboxname));
  	usermboxnamelen++;
  
--- 2049,2054 ----
***************
*** 2062,2089 ****
  
      /* Find fixed-string pattern prefix */
      for (p = pat; *p; p++) {
! 	if (*p == '*' || *p == '%' || *p == '?' || *p == '@') break;
      }
      prefixlen = p - pattern;
      *p = '\0';
  
      /*
!      * If user.X.* or INBOX.* can match pattern,
       * search for those mailboxes next
       */
      if (userid &&
! 	(!strncmp(usermboxname+domainlen, pattern, usermboxnamelen-domainlen-1) ||
! 	 !strncasecmp("inbox.", pattern, prefixlen < 6 ? prefixlen : 6))) {
  
! 	if (!strncmp(usermboxname+domainlen, pattern, usermboxnamelen-domainlen-1)) {
! 	    /* switch to pattern with domain prepended */
! 	    glob_free(&cbrock.g);
! 	    cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
! 	    cbrock.inboxoffset = 0;
! 	}
! 	else {
! 	    cbrock.inboxoffset = domainlen + userlen;
! 	}
  
  	cbrock.find_namespace = NAMESPACE_INBOX;
  	/* iterate through prefixes matching usermboxname */
--- 2066,2085 ----
  
      /* Find fixed-string pattern prefix */
      for (p = pat; *p; p++) {
! 	/* stop at the separator too */
! 	if (*p == '*' || *p == '%' || *p == '?' || *p == '@' || *p == namespace->hier_sep) break;
      }
      prefixlen = p - pattern;
      *p = '\0';
  
      /*
!      * If INBOX.* can match pattern,
       * search for those mailboxes next
       */
      if (userid &&
! 	 !strncasecmp("inbox.", pattern, prefixlen < 6 ? prefixlen : 6)) {
  
! 	cbrock.inboxoffset = domainlen + userlen;
  
  	cbrock.find_namespace = NAMESPACE_INBOX;
  	/* iterate through prefixes matching usermboxname */
***************
*** 2097,2103 ****
  	cbrock.find_namespace = NAMESPACE_USER;
  	/* switch to pattern with domain prepended */
  	glob_free(&cbrock.g);
! 	cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
  	cbrock.inboxoffset = 0;
  	if (usermboxnamelen) {
  	    usermboxname[--usermboxnamelen] = '\0';
--- 2093,2099 ----
  	cbrock.find_namespace = NAMESPACE_USER;
  	/* switch to pattern with domain prepended */
  	glob_free(&cbrock.g);
! 	cbrock.g = glob_init(domainpat, namespace->hier_sep, GLOB_HIERARCHY);
  	cbrock.inboxoffset = 0;
  	if (usermboxnamelen) {
  	    usermboxname[--usermboxnamelen] = '\0';
***************
*** 2146,2152 ****
      else
  	domainpat[0] = '\0';
  
!     cbrock.g = glob_init(pattern, GLOB_HIERARCHY|GLOB_INBOXCASE);
      cbrock.namespace = namespace;
      cbrock.domainlen = domainlen;
      cbrock.inboxcase = glob_inboxcase(cbrock.g);
--- 2142,2148 ----
      else
  	domainpat[0] = '\0';
  
!     cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY|GLOB_INBOXCASE);
      cbrock.namespace = namespace;
      cbrock.domainlen = domainlen;
      cbrock.inboxcase = glob_inboxcase(cbrock.g);
***************
*** 2208,2219 ****
      /*
       * Personal (INBOX) namespace
       *
!      * Append pattern to "INBOX.", search for those mailboxes next
       */
      if (userid) {
! 	strlcpy(patbuf, "INBOX.", sizeof(patbuf));
! 	strlcat(patbuf, pattern, sizeof(patbuf));
! 	cbrock.g = glob_init(patbuf, GLOB_HIERARCHY|GLOB_INBOXCASE);
  	cbrock.inboxcase = glob_inboxcase(cbrock.g);
  	cbrock.inboxoffset = domainlen+userlen;
  	cbrock.find_namespace = NAMESPACE_INBOX;
--- 2204,2214 ----
      /*
       * Personal (INBOX) namespace
       *
!      * Search for "INBOX.*" mailboxes next
       */
      if (userid) {
! 	/* don't touch the pattern! // sorcerer */
! 	cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY|GLOB_INBOXCASE);
  	cbrock.inboxcase = glob_inboxcase(cbrock.g);
  	cbrock.inboxoffset = domainlen+userlen;
  	cbrock.find_namespace = NAMESPACE_INBOX;
***************
*** 2243,2259 ****
  
      if (!strncmp(namespace->prefix[NAMESPACE_USER], pattern,
  		 prefixlen < len ? prefixlen : len)) {
  
- 	if (prefixlen < len) {
- 	    strlcpy(domainpat+domainlen, pattern+prefixlen,
- 		    sizeof(domainpat)-domainlen);
- 	    cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
- 	}
- 	else {
- 	    strlcpy(domainpat+domainlen, "user", sizeof(domainpat)-domainlen);
- 	    strlcat(domainpat, pattern+len, sizeof(domainpat));
- 	    cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
- 	}
  	cbrock.find_namespace = NAMESPACE_USER;
  	cbrock.inboxoffset = 0;
  	
--- 2238,2247 ----
  
      if (!strncmp(namespace->prefix[NAMESPACE_USER], pattern,
  		 prefixlen < len ? prefixlen : len)) {
+ 	/* we'll search for the requested pattern don't making any
+ 	   stupid modifications of it // sorcerer */
+ 	cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY);
  
  	cbrock.find_namespace = NAMESPACE_USER;
  	cbrock.inboxoffset = 0;
  	
***************
*** 2285,2295 ****
  	    /* Skip pattern which matches shared namespace prefix */
  	    for (p = pat+prefixlen; *p; p++) {
  		if (*p == '%') continue;
! 		else if (*p == '.') p++;
  		break;
  	    }
  
! 	    if (*pattern && !strchr(pattern, '.') &&
  		pattern[strlen(pattern)-1] == '%') {
  		/* special case:  LIST "" *% -- output prefix */
    		cbrock.checkshared = 1;
--- 2273,2283 ----
  	    /* Skip pattern which matches shared namespace prefix */
  	    for (p = pat+prefixlen; *p; p++) {
  		if (*p == '%') continue;
! 		else if (*p == namespace->hier_sep) p++;
  		break;
  	    }
  
! 	    if (*pattern && !strchr(pattern, namespace->hier_sep) &&
  		pattern[strlen(pattern)-1] == '%') {
  		/* special case:  LIST "" *% -- output prefix */
    		cbrock.checkshared = 1;
***************
*** 2298,2322 ****
  	    if ((cbrock.checkshared || prefixlen == len) && !*p) {
  		/* special case:  LIST "" % -- output prefix
   		   (if we have a shared mbox) and quit */
! 		strlcpy(domainpat+domainlen, "*", sizeof(domainpat)-domainlen);
! 		cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
  		cbrock.checkshared = 2;
  	    }
! 	    else {
! 		strlcpy(domainpat+domainlen, p, sizeof(domainpat)-domainlen);
! 		cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
! 	    }
! 		
  	    domainpat[domainlen] = '\0';
  	    DB->foreach(mbdb,
  			domainpat, domainlen,
  			&find_p, &find_cb, &cbrock,
  			NULL);
  	}
! 	else if (pattern[len] == '.') {
! 	    strlcpy(domainpat+domainlen, pattern+len+1,
! 		    sizeof(domainpat)-domainlen);
! 	    cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
  
  	    DB->foreach(mbdb,
  			domainpat, domainlen+prefixlen-(len+1),
--- 2286,2306 ----
  	    if ((cbrock.checkshared || prefixlen == len) && !*p) {
  		/* special case:  LIST "" % -- output prefix
   		   (if we have a shared mbox) and quit */
! 		cbrock.g = glob_init("*", namespace->hier_sep, GLOB_HIERARCHY);
  		cbrock.checkshared = 2;
  	    }
! 	    else
! 		cbrock.g = glob_init(pat, namespace->hier_sep, GLOB_HIERARCHY);
! 
  	    domainpat[domainlen] = '\0';
  	    DB->foreach(mbdb,
  			domainpat, domainlen,
  			&find_p, &find_cb, &cbrock,
  			NULL);
  	}
! 	else if (pattern[len] == namespace->hier_sep) {
! 	    snprintf(domainpat+domainlen, sizeof(domainpat)-domainlen, "%.*s", prefixlen-(len+1), pattern+len+1);
! 	    cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY);
  
  	    DB->foreach(mbdb,
  			domainpat, domainlen+prefixlen-(len+1),
***************
*** 2816,2823 ****
      else
  	strncpy(domainpat, pattern, sizeof(domainpat));
  
!     cbrock.g = glob_init(pattern, GLOB_HIERARCHY|GLOB_INBOXCASE);
!     cbrock.namespace = NULL;
      cbrock.domainlen = domainlen;
      cbrock.inboxcase = glob_inboxcase(cbrock.g);
      cbrock.isadmin = 1;		/* user can always see their subs */
--- 2800,2807 ----
      else
  	strncpy(domainpat, pattern, sizeof(domainpat));
  
!     cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY|GLOB_INBOXCASE);
!     cbrock.namespace = namespace;
      cbrock.domainlen = domainlen;
      cbrock.inboxcase = glob_inboxcase(cbrock.g);
      cbrock.isadmin = 1;		/* user can always see their subs */
***************
*** 2857,2872 ****
  	    }
  	    else if (r == CYRUSDB_NOTFOUND) r = 0;
  	}
- 	else if (!strncmp(pattern,
- 			  usermboxname+domainlen, usermboxnamelen-domainlen) &&
- 		 GLOB_TEST(cbrock.g, usermboxname+domainlen) != -1) {
- 	    r = SUBDB->fetch(subs, usermboxname, usermboxnamelen,
- 			     &data, &datalen, NULL);
- 	    if (!r && data) {
- 		r = (*proc)(usermboxname, usermboxnamelen, 1, rock);
- 	    }
- 	    else if (r == CYRUSDB_NOTFOUND) r = 0;
- 	}
  	strlcat(usermboxname, ".", sizeof(usermboxname));
  	usermboxnamelen++;
  
--- 2841,2846 ----
***************
*** 2881,2908 ****
  
      /* Find fixed-string pattern prefix */
      for (p = pat; *p; p++) {
! 	if (*p == '*' || *p == '%' || *p == '?' || *p == '@') break;
      }
      prefixlen = p - pattern;
      *p = '\0';
  
      /*
!      * If user.X.* or INBOX.* can match pattern,
       * search for those mailboxes next
       */
      if (userid &&
! 	(!strncmp(usermboxname+domainlen, pattern, usermboxnamelen-domainlen-1) ||
! 	 !strncasecmp("inbox.", pattern, prefixlen < 6 ? prefixlen : 6))) {
  
! 	if (!strncmp(usermboxname+domainlen, pattern, usermboxnamelen-domainlen-1)) {
! 	    /* switch to pattern with domain prepended */
! 	    glob_free(&cbrock.g);
! 	    cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
! 	    cbrock.inboxoffset = 0;
! 	}
! 	else {
! 	    cbrock.inboxoffset = strlen(userid);
! 	}
  
  	cbrock.find_namespace = NAMESPACE_INBOX;
  	/* iterate through prefixes matching usermboxname */
--- 2855,2874 ----
  
      /* Find fixed-string pattern prefix */
      for (p = pat; *p; p++) {
! 	/* stop at the separator too */
! 	if (*p == '*' || *p == '%' || *p == '?' || *p == '@' || *p == namespace->hier_sep) break;
      }
      prefixlen = p - pattern;
      *p = '\0';
  
      /*
!      * If INBOX.* can match pattern,
       * search for those mailboxes next
       */
      if (userid &&
! 	 !strncasecmp("inbox.", pattern, prefixlen < 6 ? prefixlen : 6)) {
  
! 	cbrock.inboxoffset = domainlen + userlen;
  
  	cbrock.find_namespace = NAMESPACE_INBOX;
  	/* iterate through prefixes matching usermboxname */
***************
*** 2921,2927 ****
      cbrock.find_namespace = NAMESPACE_USER;
      /* switch to pattern with domain prepended */
      glob_free(&cbrock.g);
!     cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
      cbrock.inboxoffset = 0;
      if (usermboxnamelen) {
  	usermboxname[--usermboxnamelen] = '\0';
--- 2887,2893 ----
      cbrock.find_namespace = NAMESPACE_USER;
      /* switch to pattern with domain prepended */
      glob_free(&cbrock.g);
!     cbrock.g = glob_init(domainpat, namespace->hier_sep, GLOB_HIERARCHY);
      cbrock.inboxoffset = 0;
      if (usermboxnamelen) {
  	usermboxname[--usermboxnamelen] = '\0';
***************
*** 2967,2973 ****
      else
  	domainpat[0] = '\0';
  
!     cbrock.g = glob_init(pattern, GLOB_HIERARCHY|GLOB_INBOXCASE);
      cbrock.namespace = namespace;
      cbrock.domainlen = domainlen;
      cbrock.inboxcase = glob_inboxcase(cbrock.g);
--- 2933,2939 ----
      else
  	domainpat[0] = '\0';
  
!     cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY|GLOB_INBOXCASE);
      cbrock.namespace = namespace;
      cbrock.domainlen = domainlen;
      cbrock.inboxcase = glob_inboxcase(cbrock.g);
***************
*** 3034,3042 ****
       * Append pattern to "INBOX.", search for those subscriptions next
       */
      if (userid) {
! 	strlcpy(patbuf, "INBOX.", sizeof(patbuf));
! 	strlcat(patbuf, pattern, sizeof(patbuf));
! 	cbrock.g = glob_init(patbuf, GLOB_HIERARCHY|GLOB_INBOXCASE);
  	cbrock.inboxcase = glob_inboxcase(cbrock.g);
  	cbrock.inboxoffset = domainlen+userlen;
  	cbrock.find_namespace = NAMESPACE_INBOX;
--- 3000,3007 ----
       * Append pattern to "INBOX.", search for those subscriptions next
       */
      if (userid) {
! 	/* don't touch the pattern! */
! 	cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY|GLOB_INBOXCASE);
  	cbrock.inboxcase = glob_inboxcase(cbrock.g);
  	cbrock.inboxoffset = domainlen+userlen;
  	cbrock.find_namespace = NAMESPACE_INBOX;
***************
*** 3072,3088 ****
      if (!strncmp(namespace->prefix[NAMESPACE_USER], pattern,
  		 prefixlen < len ? prefixlen : len)) {
  
! 	if (prefixlen < len) {
! 	    strlcpy(domainpat+domainlen, pattern+prefixlen,
! 		    sizeof(domainpat)-domainlen);
! 	    cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
! 	}
! 	else {
! 	    strlcpy(domainpat+domainlen, "user",
! 		   sizeof(domainpat)-domainlen);
! 	    strlcat(domainpat, pattern+len, sizeof(domainpat));
! 	    cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
! 	}
  	cbrock.find_namespace = NAMESPACE_USER;
  	cbrock.inboxoffset = 0;
  	
--- 3037,3044 ----
      if (!strncmp(namespace->prefix[NAMESPACE_USER], pattern,
  		 prefixlen < len ? prefixlen : len)) {
  
! 	/* don't touch the pattern! */
! 	cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY);
  	cbrock.find_namespace = NAMESPACE_USER;
  	cbrock.inboxoffset = 0;
  	
***************
*** 3114,3124 ****
  	    /* Skip pattern which matches shared namespace prefix */
  	    for (p = pat+prefixlen; *p; p++) {
  		if (*p == '%') continue;
! 		else if (*p == '.') p++;
  		break;
  	    }
  
! 	    if (*pattern && !strchr(pattern, '.') &&
  		pattern[strlen(pattern)-1] == '%') {
  		/* special case:  LSUB "" *% -- output prefix */
    		cbrock.checkshared = 1;
--- 3070,3080 ----
  	    /* Skip pattern which matches shared namespace prefix */
  	    for (p = pat+prefixlen; *p; p++) {
  		if (*p == '%') continue;
! 		else if (*p == namespace->hier_sep) p++;
  		break;
  	    }
  
! 	    if (*pattern && !strchr(pattern, namespace->hier_sep) &&
  		pattern[strlen(pattern)-1] == '%') {
  		/* special case:  LSUB "" *% -- output prefix */
    		cbrock.checkshared = 1;
***************
*** 3127,3140 ****
  	    if ((cbrock.checkshared || prefixlen == len) && !*p) {
  		/* special case:  LSUB "" % -- output prefix
  		   (if we have a shared mbox) and quit */
! 		strlcpy(domainpat+domainlen, "*", sizeof(domainpat)-domainlen);
! 		cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
  		cbrock.checkshared = 2;
  	    }
! 	    else {
! 		strlcpy(domainpat+domainlen, p, sizeof(domainpat)-domainlen);
! 		cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
! 	    }
  
  	    domainpat[domainlen] = '\0';
  	    SUBDB->foreach(subs,
--- 3083,3093 ----
  	    if ((cbrock.checkshared || prefixlen == len) && !*p) {
  		/* special case:  LSUB "" % -- output prefix
  		   (if we have a shared mbox) and quit */
! 		cbrock.g = glob_init("*", namespace->hier_sep, GLOB_HIERARCHY);
  		cbrock.checkshared = 2;
  	    }
! 	    else
! 		cbrock.g = glob_init(pat, namespace->hier_sep, GLOB_HIERARCHY);
  
  	    domainpat[domainlen] = '\0';
  	    SUBDB->foreach(subs,
***************
*** 3142,3151 ****
  			   &find_p, &find_cb, &cbrock,
  			   NULL);
  	}
! 	else if (pattern[len] == '.') {
! 	    strlcpy(domainpat+domainlen, pattern+len+1,
! 		    sizeof(domainpat)-domainlen);
! 	    cbrock.g = glob_init(domainpat, GLOB_HIERARCHY);
  
  	    SUBDB->foreach(subs,
  			   domainpat, domainlen+prefixlen-(len+1),
--- 3095,3103 ----
  			   &find_p, &find_cb, &cbrock,
  			   NULL);
  	}
! 	else if (pattern[len] == namespace->hier_sep) {
! 	    snprintf(domainpat+domainlen, sizeof(domainpat)-domainlen, "%.*s", prefixlen-(len+1), pattern+len+1);
! 	    cbrock.g = glob_init(pattern, namespace->hier_sep, GLOB_HIERARCHY);
  
  	    SUBDB->foreach(subs,
  			   domainpat, domainlen+prefixlen-(len+1),
diff -C 3 -r cyrus-imapd-2.2.12.superold/imap/mboxname.c cyrus-imapd-2.2.12.old/imap/mboxname.c
*** cyrus-imapd-2.2.12.superold/imap/mboxname.c	2005-02-14 09:39:57 +0300
--- cyrus-imapd-2.2.12.old/imap/mboxname.c	2005-10-31 15:38:38 +0300
***************
*** 96,101 ****
--- 96,108 ----
  #define CHARMOD64(c)  (index_mod64[(unsigned char)(c)])
  
  
+ static int mboxname_check_hierseps(struct namespace *namespace, const char *name, int namelen)
+ {
+     if(namespace->hier_sep == '/' && memchr(name, DOTCHAR, namelen))
+ 	return -1;
+     return 0;
+ }
+ 
  /*
   * Convert the external mailbox 'name' to an internal name.
   * If 'userid' is non-null, it is the name of the current user.
***************
*** 116,121 ****
--- 123,131 ----
      userlen = userid ? strlen(userid) : 0;
      namelen = strlen(name);
  
+     if(mboxname_check_hierseps(namespace, name, namelen))
+ 	return IMAP_MAILBOX_BADNAME;
+ 
      if (config_virtdomains) {
  	if (userid && (cp = strrchr(userid, '@'))) {
  	    /* user logged in as user@domain */
***************
*** 206,211 ****
--- 216,224 ----
      userlen = userid ? strlen(userid) : 0;
      namelen = strlen(name);
  
+     if(mboxname_check_hierseps(namespace, name, namelen))
+ 	return IMAP_MAILBOX_BADNAME;
+ 
      if (config_virtdomains) {
  	if (userid && (cp = strchr(userid, '@'))) {
  	    /* user logged in as user@domain */
***************
*** 664,670 ****
  
      if (strlen(name) > MAX_MAILBOX_NAME) return IMAP_MAILBOX_BADNAME;
      for (i = 0; i < NUM_BADMBOXPATTERNS; i++) {
! 	g = glob_init(badmboxpatterns[i], 0);
  	if (GLOB_TEST(g, name) != -1) {
  	    glob_free(&g);
  	    return IMAP_MAILBOX_BADNAME;
--- 677,683 ----
  
      if (strlen(name) > MAX_MAILBOX_NAME) return IMAP_MAILBOX_BADNAME;
      for (i = 0; i < NUM_BADMBOXPATTERNS; i++) {
! 	g = glob_init(badmboxpatterns[i], unixsep?'/':'.', 0);
  	if (GLOB_TEST(g, name) != -1) {
  	    glob_free(&g);
  	    return IMAP_MAILBOX_BADNAME;
diff -C 3 -r cyrus-imapd-2.2.12.superold/lib/glob.c cyrus-imapd-2.2.12.old/lib/glob.c
*** cyrus-imapd-2.2.12.superold/lib/glob.c	2003-12-08 23:57:13 +0300
--- cyrus-imapd-2.2.12.old/lib/glob.c	2005-10-31 15:38:39 +0300
***************
*** 67,74 ****
   *   4) '*' eats all '*'s and '%'s connected by any wildcard
   *   5) '%' eats all adjacent '%'s
   */
! glob *glob_init_suppress (str, flags, suppress)
      const char *str;
      int flags;
      const char *suppress;
  {
--- 67,75 ----
   *   4) '*' eats all '*'s and '%'s connected by any wildcard
   *   5) '%' eats all adjacent '%'s
   */
! glob *glob_init_suppress (str, sep_char, flags, suppress)
      const char *str;
+     char sep_char;
      int flags;
      const char *suppress;
  {
***************
*** 81,87 ****
      g = (glob *) xmalloc(sizeof (glob) + slen + strlen(str) + 1);
      if (g != 0) {
          strcpy(g->inbox, inbox);
! 	g->sep_char = '.';
  	dst = g->str;
  	/* if we're doing a substring match, put a '*' prefix (1) */
  	if (flags & GLOB_SUBSTRING) {
--- 82,88 ----
      g = (glob *) xmalloc(sizeof (glob) + slen + strlen(str) + 1);
      if (g != 0) {
          strcpy(g->inbox, inbox);
! 	g->sep_char = sep_char;
  	dst = g->str;
  	/* if we're doing a substring match, put a '*' prefix (1) */
  	if (flags & GLOB_SUBSTRING) {
***************
*** 284,312 ****
  		/* look for a match with first char following '%',
  		 * stop at a sep_char unless we're doing "*%"
  		 */
! 		ptr = phier;
! 		while (ptr != pend && *ghier != *ptr
! 		       && (*ptr != g->sep_char ||
  			   (!*ghier && gstar && *gstar == '%' && min
! 			    && ptr - start < *min))) {
! 		    ++ptr;
  		}
! 		if (ptr == pend) {
  		    gptr = ghier;
  		    break;
  		}
! 		if (*ptr == g->sep_char) {
  		    if (!*ghier && min
! 			&& *min < ptr - start && ptr != pend
! 			&& *ptr == g->sep_char
! 			) {
! 			*min = gstar ? ptr - start + 1 : -1;
! 			return (ptr - start);
  		    }
  		    ghier = NULL;
  		    sepfound = 1;
  		} else {
! 		    phier = ++ptr;
  		    gptr = ghier + 1;
  		}
  	    }
--- 285,311 ----
  		/* look for a match with first char following '%',
  		 * stop at a sep_char unless we're doing "*%"
  		 */
! 		while (phier != pend && *ghier != *phier
! 		       && (*phier != g->sep_char ||
  			   (!*ghier && gstar && *gstar == '%' && min
! 			    && phier - start < *min))) {
! 		    ++phier;
  		}
! 		if (phier == pend) {
  		    gptr = ghier;
+ 		    ptr = phier;
  		    break;
  		}
! 		if (*ghier != *phier && *phier == g->sep_char) {
  		    if (!*ghier && min
! 			&& *min < phier - start && phier != pend) {
! 			*min = gstar ? phier - start + 1 : -1;
! 			return (phier - start);
  		    }
  		    ghier = NULL;
  		    sepfound = 1;
  		} else {
! 		    ptr = ++phier;
  		    gptr = ghier + 1;
  		}
  	    }
***************
*** 376,404 ****
  		/* look for a match with first char following '%',
  		 * stop at a sep_char unless we're doing "*%"
  		 */
! 		ptr = phier;
! 		while (ptr != pend && (unsigned char) *ghier != TOLOWER(*ptr)
! 		       && (*ptr != g->sep_char ||
  			   (!*ghier && gstar && *gstar == '%' && min
! 			    && ptr - start < *min))) {
! 		    ++ptr;
  		}
! 		if (ptr == pend) {
  		    gptr = ghier;
  		    break;
  		}
! 		if (*ptr == g->sep_char) {
  		    if (!*ghier && min
! 			&& *min < ptr - start && ptr != pend
! 			&& *ptr == g->sep_char
! 			) {
! 			*min = gstar ? ptr - start + 1 : -1;
! 			return (ptr - start);
  		    }
  		    ghier = NULL;
  		    sepfound = 1;
  		} else {
! 		    phier = ++ptr;
  		    gptr = ghier + 1;
  		}
  	    }
--- 375,401 ----
  		/* look for a match with first char following '%',
  		 * stop at a sep_char unless we're doing "*%"
  		 */
! 		while (phier != pend && (unsigned char) *ghier != TOLOWER(*phier)
! 		       && (*phier != g->sep_char ||
  			   (!*ghier && gstar && *gstar == '%' && min
! 			    && phier - start < *min))) {
! 		    ++phier;
  		}
! 		if (phier == pend) {
  		    gptr = ghier;
+ 		    ptr = phier;
  		    break;
  		}
! 		if (*ghier != *phier && *phier == g->sep_char) {
  		    if (!*ghier && min
! 			&& *min < phier - start && phier != pend) {
! 			*min = gstar ? phier - start + 1 : -1;
! 			return (phier - start);
  		    }
  		    ghier = NULL;
  		    sepfound = 1;
  		} else {
! 		    ptr = ++phier;
  		    gptr = ghier + 1;
  		}
  	    }
diff -C 3 -r cyrus-imapd-2.2.12.superold/lib/glob.h cyrus-imapd-2.2.12.old/lib/glob.h
*** cyrus-imapd-2.2.12.superold/lib/glob.h	2003-02-13 23:15:40 +0300
--- cyrus-imapd-2.2.12.old/lib/glob.h	2005-10-31 15:38:39 +0300
***************
*** 78,84 ****
   *  flags    -- see flag values above
   *  suppress -- prefix to suppress
   */
! extern glob *glob_init_suppress P((const char *str, int flags,
  				   const char *suppress));
  
  /* free a glob structure
--- 78,84 ----
   *  flags    -- see flag values above
   *  suppress -- prefix to suppress
   */
! extern glob *glob_init_suppress P((const char *str, char sep_char, int flags,
  				   const char *suppress));
  
  /* free a glob structure
***************
*** 97,103 ****
  extern int glob_test P((glob *g, const char *str, long len, long *min));
  
  /* macros */
! #define glob_init(str, flags) glob_init_suppress((str), (flags), NULL)
  #define glob_inboxcase(g) ((g)->inbox)
  #define GLOB_TEST(g, str) glob_test((g), (str), 0, NULL)
  #define GLOB_SET_SEPARATOR(g, c) ((g)->sep_char = (c))
--- 97,103 ----
  extern int glob_test P((glob *g, const char *str, long len, long *min));
  
  /* macros */
! #define glob_init(str, sep_char, flags) glob_init_suppress((str), (sep_char), (flags), NULL)
  #define glob_inboxcase(g) ((g)->inbox)
  #define GLOB_TEST(g, str) glob_test((g), (str), 0, NULL)
  #define GLOB_SET_SEPARATOR(g, c) ((g)->sep_char = (c))
